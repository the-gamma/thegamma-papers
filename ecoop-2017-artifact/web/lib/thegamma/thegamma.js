(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('monaco')) :
	typeof define === 'function' && define.amd ? define(['exports', 'monaco'], factory) :
	(factory((global.main = global.main || {}),global.na));
}(this, (function (exports,monaco$1) { 'use strict';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

// 7.1.13 ToObject(argument)
var defined = _defined;
var _toObject = function(it){
  return Object(defined(it));
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function(it, key){
  return hasOwnProperty.call(it, key);
};

var toString = {}.toString;

var _cof = function(it){
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _cof;
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _iobject;
var defined$1 = _defined;
var _toIobject = function(it){
  return IObject(defined$1(it));
};

// 7.1.4 ToInteger
var ceil  = Math.ceil;
var floor = Math.floor;
var _toInteger = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.1.15 ToLength
var toInteger = _toInteger;
var min       = Math.min;
var _toLength = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var toInteger$1 = _toInteger;
var max       = Math.max;
var min$1       = Math.min;
var _toIndex = function(index, length){
  index = toInteger$1(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes
var toIObject$1 = _toIobject;
var toLength  = _toLength;
var toIndex   = _toIndex;
var _arrayIncludes = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject$1($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
});

var global$1 = _global;
var SHARED = '__core-js_shared__';
var store  = global$1[SHARED] || (global$1[SHARED] = {});
var _shared = function(key){
  return store[key] || (store[key] = {});
};

var id = 0;
var px = Math.random();
var _uid = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var shared = _shared('keys');
var uid    = _uid;
var _sharedKey = function(key){
  return shared[key] || (shared[key] = uid(key));
};

var has          = _has;
var toIObject    = _toIobject;
var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO     = _sharedKey('IE_PROTO');

var _objectKeysInternal = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys$1       = _objectKeysInternal;
var enumBugKeys = _enumBugKeys;

var _objectKeys = Object.keys || function keys(O){
  return $keys$1(O, enumBugKeys);
};

var _core = createCommonjsModule(function (module) {
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
});

var _aFunction = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding
var aFunction = _aFunction;
var _ctx = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

var _isObject = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var isObject = _isObject;
var _anObject = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

var isObject$1 = _isObject;
var document$1 = _global.document;
var is = isObject$1(document$1) && isObject$1(document$1.createElement);
var _domCreate = function(it){
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function(){
  return Object.defineProperty(_domCreate('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject$2 = _isObject;
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function(it, S){
  if(!isObject$2(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject$2(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject$2(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject$2(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

var anObject       = _anObject;
var IE8_DOM_DEFINE = _ie8DomDefine;
var toPrimitive    = _toPrimitive;
var dP$1             = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP$1(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f
};

var _propertyDesc = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

var dP         = _objectDp;
var createDesc = _propertyDesc;
var _hide = _descriptors ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

var global$2    = _global;
var core$1      = _core;
var ctx       = _ctx;
var hide      = _hide;
var PROTOTYPE = 'prototype';

var $export$1 = function(type, name, source){
  var IS_FORCED = type & $export$1.F
    , IS_GLOBAL = type & $export$1.G
    , IS_STATIC = type & $export$1.S
    , IS_PROTO  = type & $export$1.P
    , IS_BIND   = type & $export$1.B
    , IS_WRAP   = type & $export$1.W
    , exports   = IS_GLOBAL ? core$1 : core$1[name] || (core$1[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global$2 : IS_STATIC ? global$2[name] : (global$2[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global$2)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export$1.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export$1.F = 1;   // forced
$export$1.G = 2;   // global
$export$1.S = 4;   // static
$export$1.P = 8;   // proto
$export$1.B = 16;  // bind
$export$1.W = 32;  // wrap
$export$1.U = 64;  // safe
$export$1.R = 128; // real proto method for `library` 
var _export = $export$1;

// most Object methods by ES6 should accept primitives
var $export = _export;
var core    = _core;
var fails   = _fails;
var _objectSap = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

// 19.1.2.14 Object.keys(O)
var toObject = _toObject;
var $keys    = _objectKeys;

_objectSap('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

var keys$1 = _core.Object.keys;

var keys = createCommonjsModule(function (module) {
module.exports = { "default": keys$1, __esModule: true };
});

var _Object$keys = unwrapExports(keys);

var toInteger$2 = _toInteger;
var defined$2   = _defined;
// true  -> String#at
// false -> String#codePointAt
var _stringAt = function(TO_STRING){
  return function(that, pos){
    var s = String(defined$2(that))
      , i = toInteger$2(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _library = true;

var _redefine = _hide;

var _iterators = {};

var dP$2       = _objectDp;
var anObject$2 = _anObject;
var getKeys  = _objectKeys;

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties){
  anObject$2(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP$2.f(O, P = keys[i++], Properties[P]);
  return O;
};

var _html = _global.document && document.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject$1    = _anObject;
var dPs         = _objectDps;
var enumBugKeys$1 = _enumBugKeys;
var IE_PROTO$1    = _sharedKey('IE_PROTO');
var Empty       = function(){ /* empty */ };
var PROTOTYPE$1   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe')
    , i      = enumBugKeys$1.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE$1][enumBugKeys$1[i]];
  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE$1] = anObject$1(O);
    result = new Empty;
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

var _wks = createCommonjsModule(function (module) {
var store      = _shared('wks')
  , uid        = _uid
  , Symbol     = _global.Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
});

var def = _objectDp.f;
var has$2 = _has;
var TAG = _wks('toStringTag');

var _setToStringTag = function(it, tag, stat){
  if(it && !has$2(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

var create         = _objectCreate;
var descriptor     = _propertyDesc;
var setToStringTag$1 = _setToStringTag;
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function(){ return this; });

var _iterCreate = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag$1(Constructor, NAME + ' Iterator');
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has$3         = _has;
var toObject$1    = _toObject;
var IE_PROTO$2    = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function(O){
  O = toObject$1(O);
  if(has$3(O, IE_PROTO$2))return O[IE_PROTO$2];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

var LIBRARY        = _library;
var $export$2        = _export;
var redefine       = _redefine;
var hide$1           = _hide;
var has$1            = _has;
var Iterators      = _iterators;
var $iterCreate    = _iterCreate;
var setToStringTag = _setToStringTag;
var getPrototypeOf = _objectGpo;
var ITERATOR       = _wks('iterator');
var BUGGY          = !([].keys && 'next' in [].keys());
var FF_ITERATOR    = '@@iterator';
var KEYS           = 'keys';
var VALUES         = 'values';

var returnThis = function(){ return this; };

var _iterDefine = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has$1(IteratorPrototype, ITERATOR))hide$1(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide$1(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export$2($export$2.P + $export$2.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at  = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

// call something on iterator step with safe closing on error
var anObject$3 = _anObject;
var _iterCall = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject$3(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject$3(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator
var Iterators$1  = _iterators;
var ITERATOR$1   = _wks('iterator');
var ArrayProto = Array.prototype;

var _isArrayIter = function(it){
  return it !== undefined && (Iterators$1.Array === it || ArrayProto[ITERATOR$1] === it);
};

var $defineProperty = _objectDp;
var createDesc$1      = _propertyDesc;

var _createProperty = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc$1(0, value));
  else object[index] = value;
};

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof$1 = _cof;
var TAG$1 = _wks('toStringTag');
var ARG = cof$1(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

var _classof = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
    // builtinTag case
    : ARG ? cof$1(O)
    // ES3 arguments fallback
    : (B = cof$1(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var classof   = _classof;
var ITERATOR$2  = _wks('iterator');
var Iterators$2 = _iterators;
var core_getIteratorMethod = _core.getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR$2]
    || it['@@iterator']
    || Iterators$2[classof(it)];
};

var ITERATOR$3     = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$3]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

var _iterDetect = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR$3]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR$3] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

var ctx$1            = _ctx;
var $export$3        = _export;
var toObject$2       = _toObject;
var call           = _iterCall;
var isArrayIter    = _isArrayIter;
var toLength$1       = _toLength;
var createProperty = _createProperty;
var getIterFn      = core_getIteratorMethod;

$export$3($export$3.S + $export$3.F * !_iterDetect(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject$2(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx$1(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength$1(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var from$1 = _core.Array.from;

var from = createCommonjsModule(function (module) {
module.exports = { "default": from$1, __esModule: true };
});

var _Array$from = unwrapExports(from);

var classCallCheck = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
});

var _classCallCheck = unwrapExports(classCallCheck);

var $export$4 = _export;
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export$4($export$4.S + $export$4.F * !_descriptors, 'Object', {defineProperty: _objectDp.f});

var $Object = _core.Object;
var defineProperty$2 = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

var defineProperty = createCommonjsModule(function (module) {
module.exports = { "default": defineProperty$2, __esModule: true };
});

var createClass = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

var _defineProperty = defineProperty;

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
});

var _createClass = unwrapExports(createClass);

var _addToUnscopables = function(){ /* empty */ };

var _iterStep = function(done, value){
  return {value: value, done: !!done};
};

var addToUnscopables = _addToUnscopables;
var step             = _iterStep;
var Iterators$4        = _iterators;
var toIObject$2        = _toIobject;

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function(iterated, kind){
  this._t = toIObject$2(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators$4.Arguments = Iterators$4.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

var global$3        = _global;
var hide$2          = _hide;
var Iterators$3     = _iterators;
var TO_STRING_TAG = _wks('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global$3[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide$2(proto, TO_STRING_TAG, NAME);
  Iterators$3[NAME] = Iterators$3.Array;
}

var anObject$4 = _anObject;
var get      = core_getIteratorMethod;
var core_getIterator = _core.getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject$4(iterFn.call(it));
};

var getIterator$1 = core_getIterator;

var getIterator = createCommonjsModule(function (module) {
module.exports = { "default": getIterator$1, __esModule: true };
});

var _getIterator = unwrapExports(getIterator);

var f$1 = _wks;

var _wksExt = {
	f: f$1
};

var iterator$2 = _wksExt.f('iterator');

var iterator = createCommonjsModule(function (module) {
module.exports = { "default": iterator$2, __esModule: true };
});

var _meta = createCommonjsModule(function (module) {
var META     = _uid('meta')
  , isObject = _isObject
  , has      = _has
  , setDesc  = _objectDp.f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !_fails(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
});

var global$5         = _global;
var core$2           = _core;
var LIBRARY$1        = _library;
var wksExt$1         = _wksExt;
var defineProperty$4 = _objectDp.f;
var _wksDefine = function(name){
  var $Symbol = core$2.Symbol || (core$2.Symbol = LIBRARY$1 ? {} : global$5.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty$4($Symbol, name, {value: wksExt$1.f(name)});
};

var getKeys$1   = _objectKeys;
var toIObject$4 = _toIobject;
var _keyof = function(object, el){
  var O      = toIObject$4(object)
    , keys   = getKeys$1(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

var f$2 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$2
};

var f$3 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$3
};

// all enumerable object keys, includes symbols
var getKeys$2 = _objectKeys;
var gOPS    = _objectGops;
var pIE     = _objectPie;
var _enumKeys = function(it){
  var result     = getKeys$2(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

// 7.2.2 IsArray(argument)
var cof$2 = _cof;
var _isArray = Array.isArray || function isArray(arg){
  return cof$2(arg) == 'Array';
};

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys$3      = _objectKeysInternal;
var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

var f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys$3(O, hiddenKeys);
};

var _objectGopn = {
	f: f$5
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject$5 = _toIobject;
var gOPN$1      = _objectGopn.f;
var toString$1  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN$1(it);
  } catch(e){
    return windowNames.slice();
  }
};

var f$4 = function getOwnPropertyNames(it){
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(toIObject$5(it));
};

var _objectGopnExt = {
	f: f$4
};

var pIE$1            = _objectPie;
var createDesc$3     = _propertyDesc;
var toIObject$6      = _toIobject;
var toPrimitive$2    = _toPrimitive;
var has$5            = _has;
var IE8_DOM_DEFINE$1 = _ie8DomDefine;
var gOPD$1           = Object.getOwnPropertyDescriptor;

var f$6 = _descriptors ? gOPD$1 : function getOwnPropertyDescriptor(O, P){
  O = toIObject$6(O);
  P = toPrimitive$2(P, true);
  if(IE8_DOM_DEFINE$1)try {
    return gOPD$1(O, P);
  } catch(e){ /* empty */ }
  if(has$5(O, P))return createDesc$3(!pIE$1.f.call(O, P), O[P]);
};

var _objectGopd = {
	f: f$6
};

// ECMAScript 6 symbols shim
var global$4         = _global;
var has$4            = _has;
var DESCRIPTORS    = _descriptors;
var $export$5        = _export;
var redefine$1       = _redefine;
var META           = _meta.KEY;
var $fails         = _fails;
var shared$1         = _shared;
var setToStringTag$2 = _setToStringTag;
var uid$1            = _uid;
var wks            = _wks;
var wksExt         = _wksExt;
var wksDefine      = _wksDefine;
var keyOf          = _keyof;
var enumKeys       = _enumKeys;
var isArray        = _isArray;
var anObject$5       = _anObject;
var toIObject$3      = _toIobject;
var toPrimitive$1    = _toPrimitive;
var createDesc$2     = _propertyDesc;
var _create        = _objectCreate;
var gOPNExt        = _objectGopnExt;
var $GOPD          = _objectGopd;
var $DP            = _objectDp;
var $keys$2          = _objectKeys;
var gOPD           = $GOPD.f;
var dP$3             = $DP.f;
var gOPN           = gOPNExt.f;
var $Symbol        = global$4.Symbol;
var $JSON          = global$4.JSON;
var _stringify     = $JSON && $JSON.stringify;
var PROTOTYPE$2      = 'prototype';
var HIDDEN         = wks('_hidden');
var TO_PRIMITIVE   = wks('toPrimitive');
var isEnum         = {}.propertyIsEnumerable;
var SymbolRegistry = shared$1('symbol-registry');
var AllSymbols     = shared$1('symbols');
var OPSymbols      = shared$1('op-symbols');
var ObjectProto$1    = Object[PROTOTYPE$2];
var USE_NATIVE     = typeof $Symbol == 'function';
var QObject        = global$4.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP$3({}, 'a', {
    get: function(){ return dP$3(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto$1, key);
  if(protoDesc)delete ObjectProto$1[key];
  dP$3(it, key, D);
  if(protoDesc && it !== ObjectProto$1)dP$3(ObjectProto$1, key, protoDesc);
} : dP$3;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE$2]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty$1 = function defineProperty(it, key, D){
  if(it === ObjectProto$1)$defineProperty$1(OPSymbols, key, D);
  anObject$5(it);
  key = toPrimitive$1(key, true);
  anObject$5(D);
  if(has$4(AllSymbols, key)){
    if(!D.enumerable){
      if(!has$4(it, HIDDEN))dP$3(it, HIDDEN, createDesc$2(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has$4(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc$2(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP$3(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject$5(it);
  var keys = enumKeys(P = toIObject$3(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty$1(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive$1(key, true));
  if(this === ObjectProto$1 && has$4(AllSymbols, key) && !has$4(OPSymbols, key))return false;
  return E || !has$4(this, key) || !has$4(AllSymbols, key) || has$4(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject$3(it);
  key = toPrimitive$1(key, true);
  if(it === ObjectProto$1 && has$4(AllSymbols, key) && !has$4(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has$4(AllSymbols, key) && !(has$4(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject$3(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has$4(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto$1
    , names  = gOPN(IS_OP ? OPSymbols : toIObject$3(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has$4(AllSymbols, key = names[i++]) && (IS_OP ? has$4(ObjectProto$1, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid$1(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto$1)$set.call(OPSymbols, value);
      if(has$4(this, HIDDEN) && has$4(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc$2(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto$1, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine$1($Symbol[PROTOTYPE$2], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty$1;
  _objectGopn.f = gOPNExt.f = $getOwnPropertyNames;
  _objectPie.f  = $propertyIsEnumerable;
  _objectGops.f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !_library){
    redefine$1(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  };
}

$export$5($export$5.G + $export$5.W + $export$5.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i$1 = 0; symbols.length > i$1; )wks(symbols[i$1++]);

for(var symbols = $keys$2(wks.store), i$1 = 0; symbols.length > i$1; )wksDefine(symbols[i$1++]);

$export$5($export$5.S + $export$5.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has$4(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export$5($export$5.S + $export$5.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty$1,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export$5($export$5.S + $export$5.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag$2($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag$2(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag$2(global$4.JSON, 'JSON', true);

_wksDefine('asyncIterator');

_wksDefine('observable');

var index = _core.Symbol;

var symbol = createCommonjsModule(function (module) {
module.exports = { "default": index, __esModule: true };
});

var _Symbol2 = unwrapExports(symbol);

var _typeof_1 = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

var _iterator = iterator;

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = symbol;

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
});

var _typeof = unwrapExports(_typeof_1);

var hide$3 = _hide;
var _redefineAll = function(target, src, safe){
  for(var key in src){
    if(safe && target[key])target[key] = src[key];
    else hide$3(target, key, src[key]);
  } return target;
};

var _anInstance = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

var _forOf = createCommonjsModule(function (module) {
var ctx         = _ctx
  , call        = _iterCall
  , isArrayIter = _isArrayIter
  , anObject    = _anObject
  , toLength    = _toLength
  , getIterFn   = core_getIteratorMethod
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
});

var global$6      = _global;
var core$3        = _core;
var dP$5          = _objectDp;
var DESCRIPTORS$2 = _descriptors;
var SPECIES     = _wks('species');

var _setSpecies = function(KEY){
  var C = typeof core$3[KEY] == 'function' ? core$3[KEY] : global$6[KEY];
  if(DESCRIPTORS$2 && C && !C[SPECIES])dP$5.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};

var dP$4          = _objectDp.f;
var create$1      = _objectCreate;
var redefineAll = _redefineAll;
var ctx$2         = _ctx;
var anInstance  = _anInstance;
var defined$3     = _defined;
var forOf       = _forOf;
var $iterDefine = _iterDefine;
var step$1        = _iterStep;
var setSpecies  = _setSpecies;
var DESCRIPTORS$1 = _descriptors;
var fastKey$1     = _meta.fastKey;
var SIZE        = DESCRIPTORS$1 ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey$1(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

var _collectionStrong = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create$1(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx$2(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS$1)dP$4(C.prototype, 'size', {
      get: function(){
        return defined$3(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey$1(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step$1(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step$1(0, entry.k);
      if(kind == 'values')return step$1(0, entry.v);
      return step$1(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

var isObject$4 = _isObject;
var isArray$1  = _isArray;
var SPECIES$1  = _wks('species');

var _arraySpeciesConstructor = function(original){
  var C;
  if(isArray$1(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray$1(C.prototype)))C = undefined;
    if(isObject$4(C)){
      C = C[SPECIES$1];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = _arraySpeciesConstructor;

var _arraySpeciesCreate = function(original, length){
  return new (speciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx$3      = _ctx;
var IObject$1  = _iobject;
var toObject$3 = _toObject;
var toLength$2 = _toLength;
var asc      = _arraySpeciesCreate;
var _arrayMethods = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject$3($this)
      , self   = IObject$1(O)
      , f      = ctx$3(callbackfn, that, 3)
      , length = toLength$2(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

var global$7         = _global;
var $export$6        = _export;
var meta           = _meta;
var fails$1          = _fails;
var hide$4           = _hide;
var redefineAll$1    = _redefineAll;
var forOf$1          = _forOf;
var anInstance$1     = _anInstance;
var isObject$3       = _isObject;
var setToStringTag$3 = _setToStringTag;
var dP$6             = _objectDp.f;
var each           = _arrayMethods(0);
var DESCRIPTORS$3    = _descriptors;

var _collection = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global$7[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS$3 || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails$1(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll$1(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function(target, iterable){
      anInstance$1(target, C, NAME, '_c');
      target._c = new Base;
      if(iterable != undefined)forOf$1(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide$4(C.prototype, KEY, function(a, b){
        anInstance$1(this, C, KEY);
        if(!IS_ADDER && IS_WEAK && !isObject$3(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)dP$6(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag$3(C, NAME);

  O[NAME] = C;
  $export$6($export$6.G + $export$6.W + $export$6.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};

var strong = _collectionStrong;

// 23.1 Map Objects
var es6_map = _collection('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);

var forOf$2 = _forOf;

var _arrayFromIterable = function(iter, ITERATOR){
  var result = [];
  forOf$2(iter, false, result.push, result, ITERATOR);
  return result;
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof$1 = _classof;
var from$3    = _arrayFromIterable;
var _collectionToJson = function(NAME){
  return function toJSON(){
    if(classof$1(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from$3(this);
  };
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export$7  = _export;

$export$7($export$7.P + $export$7.R, 'Map', {toJSON: _collectionToJson('Map')});

var map$1 = _core.Map;

var map = createCommonjsModule(function (module) {
module.exports = { "default": map$1, __esModule: true };
});

var _Map = unwrapExports(map);

var defineProperty$5 = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

var _defineProperty = defineProperty;

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};
});

var _defineProperty = unwrapExports(defineProperty$5);

var fableGlobal = function () {
    var globalObj = typeof window !== "undefined" ? window
        : (typeof global !== "undefined" ? global
            : (typeof self !== "undefined" ? self : {}));
    if (typeof globalObj.__FABLE_CORE__ === "undefined") {
        globalObj.__FABLE_CORE__ = {
            types: new Map(),
            symbols: {
                reflection: Symbol("reflection"),
            }
        };
    }
    return globalObj.__FABLE_CORE__;
}();
function setType(fullName, cons) {
    fableGlobal.types.set(fullName, cons);
}

var _Symbol = (fableGlobal.symbols);

var NonDeclaredType = (function () {
    function NonDeclaredType(kind, definition, generics) {
        this.kind = kind;
        this.definition = definition;
        this.generics = generics;
    }
    NonDeclaredType.prototype.Equals = function (other) {
        if (this.kind === other.kind && this.definition === other.definition) {
            return typeof this.generics === "object"
                ? equalsRecords(this.generics, other.generics)
                : this.generics === other.generics;
        }
        return false;
    };
    return NonDeclaredType;
}());
var Any = new NonDeclaredType("Any");
var Unit = new NonDeclaredType("Unit");
function Option(t) {
    return new NonDeclaredType("Option", null, t);
}
function FableArray(t, isTypedArray) {
    if (isTypedArray === void 0) { isTypedArray = false; }
    var def = null, genArg = null;
    if (isTypedArray) {
        def = t;
    }
    else {
        genArg = t;
    }
    return new NonDeclaredType("Array", def, genArg);
}
function Tuple(ts) {
    return new NonDeclaredType("Tuple", null, ts);
}
function GenericParam(definition) {
    return new NonDeclaredType("GenericParam", definition);
}
function Interface(definition) {
    return new NonDeclaredType("Interface", definition);
}
function makeGeneric(typeDef, genArgs) {
    return new NonDeclaredType("GenericType", typeDef, genArgs);
}



function hasInterface(obj, interfaceName) {
    if (interfaceName === "System.Collections.Generic.IEnumerable") {
        return typeof obj[Symbol.iterator] === "function";
    }
    else if (typeof obj[_Symbol.reflection] === "function") {
        var interfaces = obj[_Symbol.reflection]().interfaces;
        return Array.isArray(interfaces) && interfaces.indexOf(interfaceName) > -1;
    }
    return false;
}
function getPropertyNames(obj) {
    if (obj == null) {
        return [];
    }
    var propertyMap = typeof obj[_Symbol.reflection] === "function" ? obj[_Symbol.reflection]().properties : obj;
    return Object.getOwnPropertyNames(propertyMap);
}

function getRestParams(args, idx) {
    for (var _len = args.length, restArgs = Array(_len > idx ? _len - idx : 0), _key = idx; _key < _len; _key++)
        restArgs[_key - idx] = args[_key];
    return restArgs;
}
function toString$2(o) {
    return o != null && typeof o.ToString == "function" ? o.ToString() : String(o);
}

function equals(x, y) {
    if (x === y)
        return true;
    else if (x == null)
        return y == null;
    else if (y == null)
        return false;
    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))
        return false;
    else if (typeof x.Equals === "function")
        return x.Equals(y);
    else if (Array.isArray(x)) {
        if (x.length != y.length)
            return false;
        for (var i = 0; i < x.length; i++)
            if (!equals(x[i], y[i]))
                return false;
        return true;
    }
    else if (ArrayBuffer.isView(x)) {
        if (x.byteLength !== y.byteLength)
            return false;
        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);
        for (var i = 0; i < x.byteLength; i++)
            if (dv1.getUint8(i) !== dv2.getUint8(i))
                return false;
        return true;
    }
    else if (x instanceof Date)
        return x.getTime() == y.getTime();
    else
        return false;
}
function compare(x, y) {
    if (x === y)
        return 0;
    if (x == null)
        return y == null ? 0 : -1;
    else if (y == null)
        return 1;
    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))
        return -1;
    else if (typeof x.CompareTo === "function")
        return x.CompareTo(y);
    else if (Array.isArray(x)) {
        if (x.length != y.length)
            return x.length < y.length ? -1 : 1;
        for (var i = 0, j = 0; i < x.length; i++)
            if ((j = compare(x[i], y[i])) !== 0)
                return j;
        return 0;
    }
    else if (ArrayBuffer.isView(x)) {
        if (x.byteLength != y.byteLength)
            return x.byteLength < y.byteLength ? -1 : 1;
        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);
        for (var i = 0, b1 = 0, b2 = 0; i < x.byteLength; i++) {
            b1 = dv1.getUint8(i), b2 = dv2.getUint8(i);
            if (b1 < b2)
                return -1;
            if (b1 > b2)
                return 1;
        }
        return 0;
    }
    else if (x instanceof Date)
        return compare(x.getTime(), y.getTime());
    else
        return x < y ? -1 : 1;
}
function equalsRecords(x, y) {
    if (x === y) {
        return true;
    }
    else {
        var keys = getPropertyNames(x);
        for (var i = 0; i < keys.length; i++) {
            if (!equals(x[keys[i]], y[keys[i]]))
                return false;
        }
        return true;
    }
}
function compareRecords(x, y) {
    if (x === y) {
        return 0;
    }
    else {
        var keys = getPropertyNames(x);
        for (var i = 0; i < keys.length; i++) {
            var res = compare(x[keys[i]], y[keys[i]]);
            if (res !== 0)
                return res;
        }
        return 0;
    }
}
function equalsUnions(x, y) {
    if (x === y) {
        return true;
    }
    else if (x.Case !== y.Case) {
        return false;
    }
    else {
        for (var i = 0; i < x.Fields.length; i++) {
            if (!equals(x.Fields[i], y.Fields[i]))
                return false;
        }
        return true;
    }
}
function compareUnions(x, y) {
    if (x === y) {
        return 0;
    }
    else {
        var res = compare(x.Case, y.Case);
        if (res !== 0)
            return res;
        for (var i = 0; i < x.Fields.length; i++) {
            res = compare(x.Fields[i], y.Fields[i]);
            if (res !== 0)
                return res;
        }
        return 0;
    }
}
function createDisposable(f) {
    return _a = {
            Dispose: f
        },
        _a[_Symbol.reflection] = function () { return { interfaces: ["System.IDisposable"] }; },
        _a;
    var _a;
}
function createObj(fields) {
    var iter = fields[Symbol.iterator]();
    var cur = iter.next(), o = {};
    while (!cur.done) {
        o[cur.value[0]] = cur.value[1];
        cur = iter.next();
    }
    return o;
}

function round(value, digits) {
    if (digits === void 0) { digits = 0; }
    var m = Math.pow(10, digits);
    var n = +(digits ? value * m : value).toFixed(8);
    var i = Math.floor(n), f = n - i;
    var e = 1e-8;
    var r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n);
    return digits ? r / m : r;
}
function randomNext(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}
function defaultArg(arg, defaultValue, f) {
    return arg == null ? defaultValue : (f != null ? f(arg) : arg);
}

function ofArray(args, base) {
    var acc = base || new List$2();
    for (var i = args.length - 1; i >= 0; i--) {
        acc = new List$2(args[i], acc);
    }
    return acc;
}
var List$2 = (function () {
    function List(head, tail) {
        this.head = head;
        this.tail = tail;
    }
    List.prototype.ToString = function () {
        return "[" + Array.from(this).map(toString$2).join("; ") + "]";
    };
    List.prototype.Equals = function (x) {
        if (this === x) {
            return true;
        }
        else {
            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();
            for (;;) {
                var cur1 = iter1.next(), cur2 = iter2.next();
                if (cur1.done)
                    return cur2.done ? true : false;
                else if (cur2.done)
                    return false;
                else if (!equals(cur1.value, cur2.value))
                    return false;
            }
        }
    };
    List.prototype.CompareTo = function (x) {
        if (this === x) {
            return 0;
        }
        else {
            var acc = 0;
            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();
            for (;;) {
                var cur1 = iter1.next(), cur2 = iter2.next();
                if (cur1.done)
                    return cur2.done ? acc : -1;
                else if (cur2.done)
                    return 1;
                else {
                    acc = compare(cur1.value, cur2.value);
                    if (acc != 0)
                        return acc;
                }
            }
        }
    };
    Object.defineProperty(List.prototype, "length", {
        get: function () {
            var cur = this, acc = 0;
            while (cur.tail != null) {
                cur = cur.tail;
                acc++;
            }
            return acc;
        },
        enumerable: true,
        configurable: true
    });
    List.prototype[Symbol.iterator] = function () {
        var cur = this;
        return {
            next: function () {
                var tmp = cur;
                cur = cur.tail;
                return { done: tmp.tail == null, value: tmp.head };
            }
        };
    };
    List.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Collections.FSharpList",
            interfaces: ["System.IEquatable", "System.IComparable"]
        };
    };
    return List;
}());

function addRangeInPlace(range, xs) {
    var iter = range[Symbol.iterator]();
    var cur = iter.next();
    while (!cur.done) {
        xs.push(cur.value);
        cur = iter.next();
    }
}

var Enumerator = (function () {
    function Enumerator(iter) {
        this.iter = iter;
    }
    Enumerator.prototype.MoveNext = function () {
        var cur = this.iter.next();
        this.current = cur.value;
        return !cur.done;
    };
    Object.defineProperty(Enumerator.prototype, "Current", {
        get: function () {
            return this.current;
        },
        enumerable: true,
        configurable: true
    });
    Enumerator.prototype.Reset = function () {
        throw new Error("JS iterators cannot be reset");
    };
    Enumerator.prototype.Dispose = function () { };
    return Enumerator;
}());


function __failIfNone(res) {
    if (res == null)
        throw new Error("Seq did not contain any matching element");
    return res;
}
function toList(xs) {
    return foldBack$1(function (x, acc) {
        return new List$2(x, acc);
    }, xs, new List$2());
}

function ofArray$1(xs) {
    return delay(function () { return unfold(function (i) { return i < xs.length ? [xs[i], i + 1] : null; }, 0); });
}
function append$1(xs, ys) {
    return delay(function () {
        var firstDone = false;
        var i = xs[Symbol.iterator]();
        var iters = [i, null];
        return unfold(function () {
            var cur;
            if (!firstDone) {
                cur = iters[0].next();
                if (!cur.done) {
                    return [cur.value, iters];
                }
                else {
                    firstDone = true;
                    iters = [null, ys[Symbol.iterator]()];
                }
            }
            cur = iters[1].next();
            return !cur.done ? [cur.value, iters] : null;
        }, iters);
    });
}

function averageBy(f, xs) {
    var count = 1;
    var sum = reduce(function (acc, x) {
        count++;
        return (count === 2 ? f(acc) : acc) + f(x);
    }, xs);
    return sum / count;
}
function concat$1(xs) {
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        var output = null;
        return unfold(function (innerIter) {
            var hasFinished = false;
            while (!hasFinished) {
                if (innerIter == null) {
                    var cur = iter.next();
                    if (!cur.done) {
                        innerIter = cur.value[Symbol.iterator]();
                    }
                    else {
                        hasFinished = true;
                    }
                }
                else {
                    var cur = innerIter.next();
                    if (!cur.done) {
                        output = cur.value;
                        hasFinished = true;
                    }
                    else {
                        innerIter = null;
                    }
                }
            }
            return innerIter != null && output != null ? [output, innerIter] : null;
        }, null);
    });
}
function collect$1(f, xs) {
    return concat$1(map$5(f, xs));
}
function choose$1(f, xs) {
    var trySkipToNext = function (iter) {
        var cur = iter.next();
        if (!cur.done) {
            var y = f(cur.value);
            return y != null ? [y, iter] : trySkipToNext(iter);
        }
        return void 0;
    };
    return delay(function () {
        return unfold(function (iter) {
            return trySkipToNext(iter);
        }, xs[Symbol.iterator]());
    });
}
function compareWith(f, xs, ys) {
    var nonZero = tryFind(function (i) { return i != 0; }, map2(function (x, y) { return f(x, y); }, xs, ys));
    return nonZero != null ? nonZero : count(xs) - count(ys);
}
function delay(f) {
    return _a = {},
        _a[Symbol.iterator] = function () { return f()[Symbol.iterator](); },
        _a;
    var _a;
}
function empty() {
    return unfold(function () { return void 0; });
}





function exists$1(f, xs) {
    function aux(iter) {
        var cur = iter.next();
        return !cur.done && (f(cur.value) || aux(iter));
    }
    return aux(xs[Symbol.iterator]());
}

function filter$2(f, xs) {
    function trySkipToNext(iter) {
        var cur = iter.next();
        while (!cur.done) {
            if (f(cur.value)) {
                return [cur.value, iter];
            }
            cur = iter.next();
        }
        return void 0;
    }
    return delay(function () { return unfold(trySkipToNext, xs[Symbol.iterator]()); });
}

function fold$1(f, acc, xs) {
    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {
        return xs.reduce(f, acc);
    }
    else {
        var cur = void 0;
        for (var i = 0, iter = xs[Symbol.iterator]();; i++) {
            cur = iter.next();
            if (cur.done)
                break;
            acc = f(acc, cur.value, i);
        }
        return acc;
    }
}
function foldBack$1(f, xs, acc) {
    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);
    for (var i = arr.length - 1; i >= 0; i--) {
        acc = f(arr[i], acc, i);
    }
    return acc;
}


function forAll$1(f, xs) {
    return fold$1(function (acc, x) { return acc && f(x); }, true, xs);
}

function tryHead(xs) {
    var iter = xs[Symbol.iterator]();
    var cur = iter.next();
    return cur.done ? null : cur.value;
}
function head(xs) {
    return __failIfNone(tryHead(xs));
}
function initialize$1(n, f) {
    return delay(function () {
        return unfold(function (i) { return i < n ? [f(i), i + 1] : null; }, 0);
    });
}

function tryItem(i, xs) {
    if (i < 0)
        return null;
    if (Array.isArray(xs) || ArrayBuffer.isView(xs))
        return i < xs.length ? xs[i] : null;
    for (var j = 0, iter = xs[Symbol.iterator]();; j++) {
        var cur = iter.next();
        if (cur.done)
            return null;
        if (j === i)
            return cur.value;
    }
}
function item(i, xs) {
    return __failIfNone(tryItem(i, xs));
}
function iterate$1(f, xs) {
    fold$1(function (_, x) { return f(x); }, null, xs);
}

function iterateIndexed(f, xs) {
    fold$1(function (_, x, i) { return f(i, x); }, null, xs);
}

function isEmpty$1(xs) {
    var i = xs[Symbol.iterator]();
    return i.next().done;
}
function tryLast(xs) {
    try {
        return reduce(function (_, x) { return x; }, xs);
    }
    catch (err) {
        return null;
    }
}
function last(xs) {
    return __failIfNone(tryLast(xs));
}
function count(xs) {
    return Array.isArray(xs) || ArrayBuffer.isView(xs)
        ? xs.length
        : fold$1(function (acc, x) { return acc + 1; }, 0, xs);
}
function map$5(f, xs) {
    return delay(function () { return unfold(function (iter) {
        var cur = iter.next();
        return !cur.done ? [f(cur.value), iter] : null;
    }, xs[Symbol.iterator]()); });
}
function mapIndexed$1(f, xs) {
    return delay(function () {
        var i = 0;
        return unfold(function (iter) {
            var cur = iter.next();
            return !cur.done ? [f(i++, cur.value), iter] : null;
        }, xs[Symbol.iterator]());
    });
}
function map2(f, xs, ys) {
    return delay(function () {
        var iter1 = xs[Symbol.iterator]();
        var iter2 = ys[Symbol.iterator]();
        return unfold(function () {
            var cur1 = iter1.next(), cur2 = iter2.next();
            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;
        });
    });
}










function rangeStep(first, step, last) {
    if (step === 0)
        throw new Error("Step cannot be 0");
    return delay(function () { return unfold(function (x) { return step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null; }, first); });
}

function range(first, last) {
    return rangeStep(first, 1, last);
}

function reduce(f, xs) {
    if (Array.isArray(xs) || ArrayBuffer.isView(xs))
        return xs.reduce(f);
    var iter = xs[Symbol.iterator]();
    var cur = iter.next();
    if (cur.done)
        throw new Error("Seq was empty");
    var acc = cur.value;
    for (;;) {
        cur = iter.next();
        if (cur.done)
            break;
        acc = f(acc, cur.value);
    }
    return acc;
}



function scan(f, seed, xs) {
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        return unfold(function (acc) {
            if (acc == null)
                return [seed, seed];
            var cur = iter.next();
            if (!cur.done) {
                acc = f(acc, cur.value);
                return [acc, acc];
            }
            return void 0;
        }, null);
    });
}

function singleton$1(x) {
    return unfold(function (x) { return x != null ? [x, null] : null; }, x);
}
function skip(n, xs) {
    return _a = {},
        _a[Symbol.iterator] = function () {
            var iter = xs[Symbol.iterator]();
            for (var i = 1; i <= n; i++)
                if (iter.next().done)
                    throw new Error("Seq has not enough elements");
            return iter;
        },
        _a;
    var _a;
}
function skipWhile(f, xs) {
    return delay(function () {
        var hasPassed = false;
        return filter$2(function (x) { return hasPassed || (hasPassed = !f(x)); }, xs);
    });
}
function sortWith(f, xs) {
    var ys = Array.from(xs);
    return ofArray$1(ys.sort(f));
}

function sumBy(f, xs) {
    return fold$1(function (acc, x) { return acc + f(x); }, 0, xs);
}

function take(n, xs, truncate) {
    if (truncate === void 0) { truncate = false; }
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        return unfold(function (i) {
            if (i < n) {
                var cur = iter.next();
                if (!cur.done)
                    return [cur.value, i + 1];
                if (!truncate)
                    throw new Error("Seq has not enough elements");
            }
            return void 0;
        }, 0);
    });
}
function truncate(n, xs) {
    return take(n, xs, true);
}
function takeWhile(f, xs) {
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        return unfold(function (i) {
            var cur = iter.next();
            if (!cur.done && f(cur.value))
                return [cur.value, null];
            return void 0;
        }, 0);
    });
}
function tryFind(f, xs, defaultValue) {
    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {
        var cur = iter.next();
        if (cur.done)
            return defaultValue === void 0 ? null : defaultValue;
        if (f(cur.value, i))
            return cur.value;
    }
}
function find(f, xs) {
    return __failIfNone(tryFind(f, xs));
}






function tryPick(f, xs) {
    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {
        var cur = iter.next();
        if (cur.done)
            break;
        var y = f(cur.value, i);
        if (y != null)
            return y;
    }
    return void 0;
}
function pick(f, xs) {
    return __failIfNone(tryPick(f, xs));
}
function unfold(f, acc) {
    return _a = {},
        _a[Symbol.iterator] = function () {
            return {
                next: function () {
                    var res = f(acc);
                    if (res != null) {
                        acc = res[1];
                        return { done: false, value: res[0] };
                    }
                    return { done: true };
                }
            };
        },
        _a;
    var _a;
}
function zip(xs, ys) {
    return map2(function (x, y) { return [x, y]; }, xs, ys);
}

var GenericComparer = (function () {
    function GenericComparer(f) {
        this.Compare = f || compare;
    }
    GenericComparer.prototype[_Symbol.reflection] = function () {
        return { interfaces: ["System.IComparer"] };
    };
    return GenericComparer;
}());

function groupBy$1(f, xs) {
    var keys = [], iter = xs[Symbol.iterator]();
    var acc = create$3(), cur = iter.next();
    while (!cur.done) {
        var k = f(cur.value), vs = tryFind$1(k, acc);
        if (vs == null) {
            keys.push(k);
            acc = add$1(k, [cur.value], acc);
        }
        else {
            vs.push(cur.value);
        }
        cur = iter.next();
    }
    return keys.map(function (k) { return [k, acc.get(k)]; });
}
function countBy(f, xs) {
    return groupBy$1(f, xs).map(function (kv) { return [kv[0], kv[1].length]; });
}
var MapTree = (function () {
    function MapTree(caseName, fields) {
        this.Case = caseName;
        this.Fields = fields;
    }
    return MapTree;
}());
function tree_sizeAux(acc, m) {
    return m.Case === "MapOne"
        ? acc + 1
        : m.Case === "MapNode"
            ? tree_sizeAux(tree_sizeAux(acc + 1, m.Fields[2]), m.Fields[3])
            : acc;
}
function tree_size(x) {
    return tree_sizeAux(0, x);
}
function tree_empty() {
    return new MapTree("MapEmpty", []);
}
function tree_height$1(_arg1) {
    return _arg1.Case === "MapOne" ? 1 : _arg1.Case === "MapNode" ? _arg1.Fields[4] : 0;
}
function tree_mk$1(l, k, v, r) {
    var matchValue = [l, r];
    var $target1 = function () {
        var hl = tree_height$1(l);
        var hr = tree_height$1(r);
        var m = hl < hr ? hr : hl;
        return new MapTree("MapNode", [k, v, l, r, m + 1]);
    };
    if (matchValue[0].Case === "MapEmpty") {
        if (matchValue[1].Case === "MapEmpty") {
            return new MapTree("MapOne", [k, v]);
        }
        else {
            return $target1();
        }
    }
    else {
        return $target1();
    }
}

function tree_rebalance$1(t1, k, v, t2) {
    var t1h = tree_height$1(t1);
    var t2h = tree_height$1(t2);
    if (t2h > t1h + 2) {
        if (t2.Case === "MapNode") {
            if (tree_height$1(t2.Fields[2]) > t1h + 1) {
                if (t2.Fields[2].Case === "MapNode") {
                    return tree_mk$1(tree_mk$1(t1, k, v, t2.Fields[2].Fields[2]), t2.Fields[2].Fields[0], t2.Fields[2].Fields[1], tree_mk$1(t2.Fields[2].Fields[3], t2.Fields[0], t2.Fields[1], t2.Fields[3]));
                }
                else {
                    throw new Error("rebalance");
                }
            }
            else {
                return tree_mk$1(tree_mk$1(t1, k, v, t2.Fields[2]), t2.Fields[0], t2.Fields[1], t2.Fields[3]);
            }
        }
        else {
            throw new Error("rebalance");
        }
    }
    else {
        if (t1h > t2h + 2) {
            if (t1.Case === "MapNode") {
                if (tree_height$1(t1.Fields[3]) > t2h + 1) {
                    if (t1.Fields[3].Case === "MapNode") {
                        return tree_mk$1(tree_mk$1(t1.Fields[2], t1.Fields[0], t1.Fields[1], t1.Fields[3].Fields[2]), t1.Fields[3].Fields[0], t1.Fields[3].Fields[1], tree_mk$1(t1.Fields[3].Fields[3], k, v, t2));
                    }
                    else {
                        throw new Error("rebalance");
                    }
                }
                else {
                    return tree_mk$1(t1.Fields[2], t1.Fields[0], t1.Fields[1], tree_mk$1(t1.Fields[3], k, v, t2));
                }
            }
            else {
                throw new Error("rebalance");
            }
        }
        else {
            return tree_mk$1(t1, k, v, t2);
        }
    }
}
function tree_add$1(comparer, k, v, m) {
    if (m.Case === "MapOne") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return new MapTree("MapNode", [k, v, new MapTree("MapEmpty", []), m, 2]);
        }
        else if (c === 0) {
            return new MapTree("MapOne", [k, v]);
        }
        return new MapTree("MapNode", [k, v, m, new MapTree("MapEmpty", []), 2]);
    }
    else if (m.Case === "MapNode") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return tree_rebalance$1(tree_add$1(comparer, k, v, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);
        }
        else if (c === 0) {
            return new MapTree("MapNode", [k, v, m.Fields[2], m.Fields[3], m.Fields[4]]);
        }
        return tree_rebalance$1(m.Fields[2], m.Fields[0], m.Fields[1], tree_add$1(comparer, k, v, m.Fields[3]));
    }
    return new MapTree("MapOne", [k, v]);
}
function tree_find(comparer, k, m) {
    var res = tree_tryFind(comparer, k, m);
    if (res != null)
        return res;
    throw new Error("key not found");
}
function tree_tryFind(comparer, k, m) {
    if (m.Case === "MapOne") {
        var c = comparer.Compare(k, m.Fields[0]);
        return c === 0 ? m.Fields[1] : null;
    }
    else if (m.Case === "MapNode") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return tree_tryFind(comparer, k, m.Fields[2]);
        }
        else {
            if (c === 0) {
                return m.Fields[1];
            }
            else {
                return tree_tryFind(comparer, k, m.Fields[3]);
            }
        }
    }
    return null;
}
function tree_spliceOutSuccessor$1(m) {
    if (m.Case === "MapOne") {
        return [m.Fields[0], m.Fields[1], new MapTree("MapEmpty", [])];
    }
    else if (m.Case === "MapNode") {
        if (m.Fields[2].Case === "MapEmpty") {
            return [m.Fields[0], m.Fields[1], m.Fields[3]];
        }
        else {
            var kvl = tree_spliceOutSuccessor$1(m.Fields[2]);
            return [kvl[0], kvl[1], tree_mk$1(kvl[2], m.Fields[0], m.Fields[1], m.Fields[3])];
        }
    }
    throw new Error("internal error: Map.spliceOutSuccessor");
}
function tree_remove$1(comparer, k, m) {
    if (m.Case === "MapOne") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c === 0) {
            return new MapTree("MapEmpty", []);
        }
        else {
            return m;
        }
    }
    else if (m.Case === "MapNode") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return tree_rebalance$1(tree_remove$1(comparer, k, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);
        }
        else {
            if (c === 0) {
                var matchValue = [m.Fields[2], m.Fields[3]];
                if (matchValue[0].Case === "MapEmpty") {
                    return m.Fields[3];
                }
                else {
                    if (matchValue[1].Case === "MapEmpty") {
                        return m.Fields[2];
                    }
                    else {
                        var patternInput = tree_spliceOutSuccessor$1(m.Fields[3]);
                        var sv = patternInput[1];
                        var sk = patternInput[0];
                        var r_ = patternInput[2];
                        return tree_mk$1(m.Fields[2], sk, sv, r_);
                    }
                }
            }
            else {
                return tree_rebalance$1(m.Fields[2], m.Fields[0], m.Fields[1], tree_remove$1(comparer, k, m.Fields[3]));
            }
        }
    }
    else {
        return tree_empty();
    }
}
function tree_mem$1(comparer, k, m) {
    if (m.Case === "MapOne") {
        return comparer.Compare(k, m.Fields[0]) === 0;
    }
    else if (m.Case === "MapNode") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return tree_mem$1(comparer, k, m.Fields[2]);
        }
        else {
            if (c === 0) {
                return true;
            }
            else {
                return tree_mem$1(comparer, k, m.Fields[3]);
            }
        }
    }
    else {
        return false;
    }
}
function tree_mkFromEnumerator$1(comparer, acc, e) {
    var cur = e.next();
    while (!cur.done) {
        acc = tree_add$1(comparer, cur.value[0], cur.value[1], acc);
        cur = e.next();
    }
    return acc;
}
function tree_ofSeq$1(comparer, c) {
    var ie = c[Symbol.iterator]();
    return tree_mkFromEnumerator$1(comparer, tree_empty(), ie);
}
function tree_collapseLHS$1(stack) {
    if (stack.tail != null) {
        if (stack.head.Case === "MapOne") {
            return stack;
        }
        else if (stack.head.Case === "MapNode") {
            return tree_collapseLHS$1(ofArray([
                stack.head.Fields[2],
                new MapTree("MapOne", [stack.head.Fields[0], stack.head.Fields[1]]),
                stack.head.Fields[3]
            ], stack.tail));
        }
        else {
            return tree_collapseLHS$1(stack.tail);
        }
    }
    else {
        return new List$2();
    }
}
function tree_mkIterator$1(s) {
    return { stack: tree_collapseLHS$1(new List$2(s, new List$2())), started: false };
}
function tree_moveNext$1(i) {
    function current(i) {
        if (i.stack.tail == null) {
            return null;
        }
        else if (i.stack.head.Case === "MapOne") {
            return [i.stack.head.Fields[0], i.stack.head.Fields[1]];
        }
        throw new Error("Please report error: Map iterator, unexpected stack for current");
    }
    if (i.started) {
        if (i.stack.tail == null) {
            return { done: true, value: null };
        }
        else {
            if (i.stack.head.Case === "MapOne") {
                i.stack = tree_collapseLHS$1(i.stack.tail);
                return {
                    done: i.stack.tail == null,
                    value: current(i)
                };
            }
            else {
                throw new Error("Please report error: Map iterator, unexpected stack for moveNext");
            }
        }
    }
    else {
        i.started = true;
        return {
            done: i.stack.tail == null,
            value: current(i)
        };
    }
    
}
var FableMap = (function () {
    function FableMap() {
    }
    FableMap.prototype.ToString = function () {
        return "map [" + Array.from(this).map(toString$2).join("; ") + "]";
    };
    FableMap.prototype.Equals = function (m2) {
        return this.CompareTo(m2) === 0;
    };
    FableMap.prototype.CompareTo = function (m2) {
        var _this = this;
        return this === m2 ? 0 : compareWith(function (kvp1, kvp2) {
            var c = _this.comparer.Compare(kvp1[0], kvp2[0]);
            return c !== 0 ? c : compare(kvp1[1], kvp2[1]);
        }, this, m2);
    };
    FableMap.prototype[Symbol.iterator] = function () {
        var i = tree_mkIterator$1(this.tree);
        return {
            next: function () { return tree_moveNext$1(i); }
        };
    };
    FableMap.prototype.entries = function () {
        return this[Symbol.iterator]();
    };
    FableMap.prototype.keys = function () {
        return map$5(function (kv) { return kv[0]; }, this);
    };
    FableMap.prototype.values = function () {
        return map$5(function (kv) { return kv[1]; }, this);
    };
    FableMap.prototype.get = function (k) {
        return tree_find(this.comparer, k, this.tree);
    };
    FableMap.prototype.has = function (k) {
        return tree_mem$1(this.comparer, k, this.tree);
    };
    FableMap.prototype.set = function (k, v) {
        throw new Error("not supported");
    };
    FableMap.prototype.delete = function (k) {
        throw new Error("not supported");
    };
    FableMap.prototype.clear = function () {
        throw new Error("not supported");
    };
    Object.defineProperty(FableMap.prototype, "size", {
        get: function () {
            return tree_size(this.tree);
        },
        enumerable: true,
        configurable: true
    });
    FableMap.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Collections.FSharpMap",
            interfaces: ["System.IEquatable", "System.IComparable", "System.Collections.Generic.IDictionary"]
        };
    };
    return FableMap;
}());
function from$5(comparer, tree) {
    var map$$1 = new FableMap();
    map$$1.tree = tree;
    map$$1.comparer = comparer || new GenericComparer();
    return map$$1;
}
function create$3(ie, comparer) {
    comparer = comparer || new GenericComparer();
    return from$5(comparer, ie ? tree_ofSeq$1(comparer, ie) : tree_empty());
}
function add$1(k, v, map$$1) {
    return from$5(map$$1.comparer, tree_add$1(map$$1.comparer, k, v, map$$1.tree));
}
function remove$1(item$$1, map$$1) {
    return from$5(map$$1.comparer, tree_remove$1(map$$1.comparer, item$$1, map$$1.tree));
}

function tryGetValue(map$$1, key, defaultValue) {
    return map$$1.has(key) ? [true, map$$1.get(key)] : [false, defaultValue];
}


function tryFind$1(k, map$$1) {
    return tree_tryFind(map$$1.comparer, k, map$$1.tree);
}

function append$$1(xs, ys) {
    return fold$1(function (acc, x) { return new List$2(x, acc); }, ys, reverse$$1(xs));
}
function choose$$1(f, xs) {
    var r = fold$1(function (acc, x) {
        var y = f(x);
        return y != null ? new List$2(y, acc) : acc;
    }, new List$2(), xs);
    return reverse$$1(r);
}
function collect$$1(f, xs) {
    return fold$1(function (acc, x) { return append$$1(acc, f(x)); }, new List$2(), xs);
}
function concat$$1(xs) {
    return collect$$1(function (x) { return x; }, xs);
}
function filter$1(f, xs) {
    return reverse$$1(fold$1(function (acc, x) { return f(x) ? new List$2(x, acc) : acc; }, new List$2(), xs));
}


function map$4(f, xs) {
    return reverse$$1(fold$1(function (acc, x) { return new List$2(f(x), acc); }, new List$2(), xs));
}
function mapIndexed$$1(f, xs) {
    return reverse$$1(fold$1(function (acc, x, i) { return new List$2(f(i, x), acc); }, new List$2(), xs));
}


function reverse$$1(xs) {
    return fold$1(function (acc, x) { return new List$2(x, acc); }, new List$2(), xs);
}

function distinctBy(f, xs) {
    return choose$1(function (tup) { return tup[0]; }, scan(function (tup, x) {
        var acc = tup[1];
        var k = f(x);
        return acc.has(k) ? [null, acc] : [x, add(k, acc)];
    }, [null, create$2()], xs));
}
function distinct(xs) {
    return distinctBy(function (x) { return x; }, xs);
}
var SetTree = (function () {
    function SetTree(caseName, fields) {
        this.Case = caseName;
        this.Fields = fields;
    }
    return SetTree;
}());
var tree_tolerance = 2;
function tree_countAux(s, acc) {
    return s.Case === "SetOne" ? acc + 1 : s.Case === "SetEmpty" ? acc : tree_countAux(s.Fields[1], tree_countAux(s.Fields[2], acc + 1));
}
function tree_count(s) {
    return tree_countAux(s, 0);
}
function tree_SetOne(n) {
    return new SetTree("SetOne", [n]);
}
function tree_SetNode(x, l, r, h) {
    return new SetTree("SetNode", [x, l, r, h]);
}
function tree_height(t) {
    return t.Case === "SetOne" ? 1 : t.Case === "SetNode" ? t.Fields[3] : 0;
}
function tree_mk(l, k, r) {
    var matchValue = [l, r];
    var $target1 = function () {
        var hl = tree_height(l);
        var hr = tree_height(r);
        var m = hl < hr ? hr : hl;
        return tree_SetNode(k, l, r, m + 1);
    };
    if (matchValue[0].Case === "SetEmpty") {
        if (matchValue[1].Case === "SetEmpty") {
            return tree_SetOne(k);
        }
        else {
            return $target1();
        }
    }
    else {
        return $target1();
    }
}
function tree_rebalance(t1, k, t2) {
    var t1h = tree_height(t1);
    var t2h = tree_height(t2);
    if (t2h > t1h + tree_tolerance) {
        if (t2.Case === "SetNode") {
            if (tree_height(t2.Fields[1]) > t1h + 1) {
                if (t2.Fields[1].Case === "SetNode") {
                    return tree_mk(tree_mk(t1, k, t2.Fields[1].Fields[1]), t2.Fields[1].Fields[0], tree_mk(t2.Fields[1].Fields[2], t2.Fields[0], t2.Fields[2]));
                }
                else {
                    throw new Error("rebalance");
                }
            }
            else {
                return tree_mk(tree_mk(t1, k, t2.Fields[1]), t2.Fields[0], t2.Fields[2]);
            }
        }
        else {
            throw new Error("rebalance");
        }
    }
    else {
        if (t1h > t2h + tree_tolerance) {
            if (t1.Case === "SetNode") {
                if (tree_height(t1.Fields[2]) > t2h + 1) {
                    if (t1.Fields[2].Case === "SetNode") {
                        return tree_mk(tree_mk(t1.Fields[1], t1.Fields[0], t1.Fields[2].Fields[1]), t1.Fields[2].Fields[0], tree_mk(t1.Fields[2].Fields[2], k, t2));
                    }
                    else {
                        throw new Error("rebalance");
                    }
                }
                else {
                    return tree_mk(t1.Fields[1], t1.Fields[0], tree_mk(t1.Fields[2], k, t2));
                }
            }
            else {
                throw new Error("rebalance");
            }
        }
        else {
            return tree_mk(t1, k, t2);
        }
    }
}
function tree_add(comparer, k, t) {
    if (t.Case === "SetOne") {
        var c = comparer.Compare(k, t.Fields[0]);
        if (c < 0) {
            return tree_SetNode(k, new SetTree("SetEmpty", []), t, 2);
        }
        else if (c === 0) {
            return t;
        }
        else {
            return tree_SetNode(k, t, new SetTree("SetEmpty", []), 2);
        }
    }
    else if (t.Case === "SetEmpty") {
        return tree_SetOne(k);
    }
    else {
        var c = comparer.Compare(k, t.Fields[0]);
        if (c < 0) {
            return tree_rebalance(tree_add(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);
        }
        else if (c === 0) {
            return t;
        }
        else {
            return tree_rebalance(t.Fields[1], t.Fields[0], tree_add(comparer, k, t.Fields[2]));
        }
    }
}
function tree_mem(comparer, k, t) {
    if (t.Case === "SetOne") {
        return comparer.Compare(k, t.Fields[0]) === 0;
    }
    else if (t.Case === "SetEmpty") {
        return false;
    }
    else {
        var c = comparer.Compare(k, t.Fields[0]);
        if (c < 0) {
            return tree_mem(comparer, k, t.Fields[1]);
        }
        else if (c === 0) {
            return true;
        }
        else {
            return tree_mem(comparer, k, t.Fields[2]);
        }
    }
}
function tree_collapseLHS(stack) {
    return stack.tail != null
        ? stack.head.Case === "SetOne"
            ? stack
            : stack.head.Case === "SetNode"
                ? tree_collapseLHS(ofArray([
                    stack.head.Fields[1],
                    tree_SetOne(stack.head.Fields[0]),
                    stack.head.Fields[2]
                ], stack.tail))
                : tree_collapseLHS(stack.tail)
        : new List$2();
}
function tree_mkIterator(s) {
    return { stack: tree_collapseLHS(new List$2(s, new List$2())), started: false };
}

function tree_moveNext(i) {
    function current(i) {
        if (i.stack.tail == null) {
            return null;
        }
        else if (i.stack.head.Case === "SetOne") {
            return i.stack.head.Fields[0];
        }
        throw new Error("Please report error: Set iterator, unexpected stack for current");
    }
    if (i.started) {
        if (i.stack.tail == null) {
            return { done: true, value: null };
        }
        else {
            if (i.stack.head.Case === "SetOne") {
                i.stack = tree_collapseLHS(i.stack.tail);
                return {
                    done: i.stack.tail == null,
                    value: current(i)
                };
            }
            else {
                throw new Error("Please report error: Set iterator, unexpected stack for moveNext");
            }
        }
    }
    else {
        i.started = true;
        return {
            done: i.stack.tail == null,
            value: current(i)
        };
    }
    
}
function tree_compareStacks(comparer, l1, l2) {
    var $target8 = function (n1k, t1) { return tree_compareStacks(comparer, ofArray([new SetTree("SetEmpty", []), tree_SetOne(n1k)], t1), l2); };
    var $target9 = function (n1k, n1l, n1r, t1) { return tree_compareStacks(comparer, ofArray([n1l, tree_SetNode(n1k, new SetTree("SetEmpty", []), n1r, 0)], t1), l2); };
    var $target11 = function (n2k, n2l, n2r, t2) { return tree_compareStacks(comparer, l1, ofArray([n2l, tree_SetNode(n2k, new SetTree("SetEmpty", []), n2r, 0)], t2)); };
    if (l1.tail != null) {
        if (l2.tail != null) {
            if (l2.head.Case === "SetOne") {
                if (l1.head.Case === "SetOne") {
                    var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                    if (c !== 0) {
                        return c;
                    }
                    else {
                        return tree_compareStacks(comparer, t1, t2);
                    }
                }
                else {
                    if (l1.head.Case === "SetNode") {
                        if (l1.head.Fields[1].Case === "SetEmpty") {
                            var emp = l1.head.Fields[1], n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                            if (c !== 0) {
                                return c;
                            }
                            else {
                                return tree_compareStacks(comparer, ofArray([n1r], t1), ofArray([emp], t2));
                            }
                        }
                        else {
                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                        }
                    }
                    else {
                        var n2k = l2.head.Fields[0], t2 = l2.tail;
                        return tree_compareStacks(comparer, l1, ofArray([new SetTree("SetEmpty", []), tree_SetOne(n2k)], t2));
                    }
                }
            }
            else {
                if (l2.head.Case === "SetNode") {
                    if (l2.head.Fields[1].Case === "SetEmpty") {
                        if (l1.head.Case === "SetOne") {
                            var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                            if (c !== 0) {
                                return c;
                            }
                            else {
                                return tree_compareStacks(comparer, ofArray([new SetTree("SetEmpty", [])], t1), ofArray([n2r], t2));
                            }
                        }
                        else {
                            if (l1.head.Case === "SetNode") {
                                if (l1.head.Fields[1].Case === "SetEmpty") {
                                    var n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                                    if (c !== 0) {
                                        return c;
                                    }
                                    else {
                                        return tree_compareStacks(comparer, ofArray([n1r], t1), ofArray([n2r], t2));
                                    }
                                }
                                else {
                                    return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                                }
                            }
                            else {
                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);
                            }
                        }
                    }
                    else {
                        if (l1.head.Case === "SetOne") {
                            return $target8(l1.head.Fields[0], l1.tail);
                        }
                        else {
                            if (l1.head.Case === "SetNode") {
                                return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                            }
                            else {
                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);
                            }
                        }
                    }
                }
                else {
                    if (l1.head.Case === "SetOne") {
                        return $target8(l1.head.Fields[0], l1.tail);
                    }
                    else {
                        if (l1.head.Case === "SetNode") {
                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                        }
                        else {
                            return tree_compareStacks(comparer, l1.tail, l2.tail);
                        }
                    }
                }
            }
        }
        else {
            return 1;
        }
    }
    else {
        if (l2.tail != null) {
            return -1;
        }
        else {
            return 0;
        }
    }
}
function tree_compare(comparer, s1, s2) {
    if (s1.Case === "SetEmpty") {
        if (s2.Case === "SetEmpty") {
            return 0;
        }
        else {
            return -1;
        }
    }
    else {
        if (s2.Case === "SetEmpty") {
            return 1;
        }
        else {
            return tree_compareStacks(comparer, ofArray([s1]), ofArray([s2]));
        }
    }
}
function tree_mkFromEnumerator(comparer, acc, e) {
    var cur = e.next();
    while (!cur.done) {
        acc = tree_add(comparer, cur.value, acc);
        cur = e.next();
    }
    return acc;
}
function tree_ofSeq(comparer, c) {
    var ie = c[Symbol.iterator]();
    return tree_mkFromEnumerator(comparer, new SetTree("SetEmpty", []), ie);
}
var FableSet = (function () {
    function FableSet() {
    }
    FableSet.prototype.ToString = function () {
        return "set [" + Array.from(this).map(toString$2).join("; ") + "]";
    };
    FableSet.prototype.Equals = function (s2) {
        return this.CompareTo(s2) === 0;
    };
    FableSet.prototype.CompareTo = function (s2) {
        return this === s2 ? 0 : tree_compare(this.comparer, this.tree, s2.tree);
    };
    FableSet.prototype[Symbol.iterator] = function () {
        var i = tree_mkIterator(this.tree);
        return {
            next: function () { return tree_moveNext(i); }
        };
    };
    FableSet.prototype.values = function () {
        return this[Symbol.iterator]();
    };
    FableSet.prototype.has = function (v) {
        return tree_mem(this.comparer, v, this.tree);
    };
    FableSet.prototype.add = function (v) {
        throw new Error("not supported");
    };
    FableSet.prototype.delete = function (v) {
        throw new Error("not supported");
    };
    FableSet.prototype.clear = function () {
        throw new Error("not supported");
    };
    Object.defineProperty(FableSet.prototype, "size", {
        get: function () {
            return tree_count(this.tree);
        },
        enumerable: true,
        configurable: true
    });
    FableSet.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Collections.FSharpSet",
            interfaces: ["System.IEquatable", "System.IComparable"]
        };
    };
    return FableSet;
}());
function from$4(comparer, tree) {
    var s = new FableSet();
    s.tree = tree;
    s.comparer = comparer || new GenericComparer();
    return s;
}
function create$2(ie, comparer) {
    comparer = comparer || new GenericComparer();
    return from$4(comparer, ie ? tree_ofSeq(comparer, ie) : new SetTree("SetEmpty", []));
}

function add(item$$1, s) {
    return from$4(s.comparer, tree_add(s.comparer, item$$1, s.tree));
}

var Long = (function () {
    function Long(low, high, unsigned) {
        this.eq = this.equals;
        this.neq = this.notEquals;
        this.lt = this.lessThan;
        this.lte = this.lessThanOrEqual;
        this.gt = this.greaterThan;
        this.gte = this.greaterThanOrEqual;
        this.comp = this.compare;
        this.neg = this.negate;
        this.abs = this.absolute;
        this.sub = this.subtract;
        this.mul = this.multiply;
        this.div = this.divide;
        this.mod = this.modulo;
        this.shl = this.shiftLeft;
        this.shr = this.shiftRight;
        this.shru = this.shiftRightUnsigned;
        this.Equals = this.equals;
        this.CompareTo = this.compare;
        this.ToString = this.toString;
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
    }
    Long.prototype.toInt = function () {
        return this.unsigned ? this.low >>> 0 : this.low;
    };
    Long.prototype.toNumber = function () {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    Long.prototype.toString = function (radix) {
        if (radix === void 0) { radix = 10; }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) {
            if (this.eq(MIN_VALUE)) {
                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            }
            else
                return '-' + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };
    Long.prototype.getHighBits = function () {
        return this.high;
    };
    Long.prototype.getHighBitsUnsigned = function () {
        return this.high >>> 0;
    };
    Long.prototype.getLowBits = function () {
        return this.low;
    };
    Long.prototype.getLowBitsUnsigned = function () {
        return this.low >>> 0;
    };
    Long.prototype.getNumBitsAbs = function () {
        if (this.isNegative())
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };
    Long.prototype.isZero = function () {
        return this.high === 0 && this.low === 0;
    };
    Long.prototype.isNegative = function () {
        return !this.unsigned && this.high < 0;
    };
    Long.prototype.isPositive = function () {
        return this.unsigned || this.high >= 0;
    };
    Long.prototype.isOdd = function () {
        return (this.low & 1) === 1;
    };
    Long.prototype.isEven = function () {
        return (this.low & 1) === 0;
    };
    Long.prototype.equals = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };
    Long.prototype.notEquals = function (other) {
        return !this.eq(other);
    };
    Long.prototype.lessThan = function (other) {
        return this.comp(other) < 0;
    };
    Long.prototype.lessThanOrEqual = function (other) {
        return this.comp(other) <= 0;
    };
    Long.prototype.greaterThan = function (other) {
        return this.comp(other) > 0;
    };
    Long.prototype.greaterThanOrEqual = function (other) {
        return this.comp(other) >= 0;
    };
    Long.prototype.compare = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };
    Long.prototype.negate = function () {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };
    Long.prototype.absolute = function () {
        if (!this.unsigned && this.isNegative())
            return this.negate();
        else
            return this;
    };
    Long.prototype.add = function (addend) {
        if (!isLong(addend))
            addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };
    Long.prototype.subtract = function (subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };
    Long.prototype.multiply = function (multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        }
        else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };
    Long.prototype.divide = function (divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx = 0, rem = ZERO, res = ZERO;
        if (!this.unsigned) {
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    var halfThis = this.shr(1);
                    var approx_1 = halfThis.div(divisor).shl(1);
                    if (approx_1.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    }
                    else {
                        rem = this.sub(divisor.mul(approx_1));
                        res = approx_1.add(rem.div(divisor));
                        return res;
                    }
                }
            }
            else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            }
            else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        }
        else {
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1)))
                return UONE;
            res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
                approxRes = ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };
    Long.prototype.modulo = function (divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };
    
    Long.prototype.not = function () {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };
    
    Long.prototype.and = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    Long.prototype.or = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    Long.prototype.xor = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    Long.prototype.shiftLeft = function (numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits = numBits & 63;
        if (numBits === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };
    Long.prototype.shiftRight = function (numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits = numBits & 63;
        if (numBits === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };
    Long.prototype.shiftRightUnsigned = function (numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits = numBits & 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            }
            else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };
    Long.prototype.toSigned = function () {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };
    Long.prototype.toUnsigned = function () {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };
    Long.prototype.toBytes = function (le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    };
    Long.prototype.toBytesLE = function () {
        var hi = this.high, lo = this.low;
        return [
            lo & 0xff,
            (lo >>> 8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
            hi & 0xff,
            (hi >>> 8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    };
    Long.prototype.toBytesBE = function () {
        var hi = this.high, lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 8) & 0xff,
            hi & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 8) & 0xff,
            lo & 0xff
        ];
    };
    Long.prototype[_Symbol.reflection] = function () {
        return {
            type: "System.Int64",
            interfaces: ["FSharpRecord", "System.IComparable"],
            properties: {
                low: "number",
                high: "number",
                unsigned: "boolean"
            }
        };
    };
    return Long;
}());
var INT_CACHE = {};
var UINT_CACHE = {};
function isLong(obj) {
    return (obj && obj instanceof Long);
}
function fromInt(value, unsigned) {
    if (unsigned === void 0) { unsigned = false; }
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    }
    else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}
function fromNumber(value, unsigned) {
    if (unsigned === void 0) { unsigned = false; }
    if (isNaN(value) || !isFinite(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    }
    else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
    if (unsigned === void 0) { unsigned = false; }
    if (radix === void 0) { radix = 10; }
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        radix = unsigned,
            unsigned = false;
    }
    else {
        unsigned = !!unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    var p = str.indexOf('-');
    if (p > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        }
        else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}
function fromValue(val) {
    if (val instanceof Long)
        return val;
    if (typeof val === 'number')
        return fromNumber(val);
    if (typeof val === 'string')
        return fromString(val);
    return fromBits(val.low, val.high, val.unsigned);
}
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
var UZERO = fromInt(0, true);
var ONE = fromInt(1);
var UONE = fromInt(1, true);
var NEG_ONE = fromInt(-1);
var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

function parse(v, kind) {
    if (kind == null) {
        kind = typeof v == "string" && v.slice(-1) == "Z" ? 1 : 2;
    }
    var date = (v == null) ? new Date() : new Date(v);
    if (kind === 2) {
        date.kind = kind;
    }
    if (isNaN(date.getTime())) {
        throw new Error("The string is not a valid Date.");
    }
    return date;
}


function now() {
    return parse();
}










function hour(d) {
    return d.kind === 2 ? d.getHours() : d.getUTCHours();
}
function millisecond(d) {
    return d.kind === 2 ? d.getMilliseconds() : d.getUTCMilliseconds();
}
function minute(d) {
    return d.kind === 2 ? d.getMinutes() : d.getUTCMinutes();
}

function second(d) {
    return d.kind === 2 ? d.getSeconds() : d.getUTCSeconds();
}


function ticks$$1(d) {
    return fromNumber(d.getTime())
        .add(62135596800000)
        .sub(d.kind == 2 ? d.getTimezoneOffset() * 60 * 1000 : 0)
        .mul(10000);
}

function escape(str) {
    return str.replace(/[\-\[\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

var fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\d+)?(?:\.(\d+))?(\w)/;



function toHex(value) {
    return value < 0
        ? "ff" + (16777215 - (Math.abs(value) - 1)).toString(16)
        : value.toString(16);
}
function fsFormat(str) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var _cont;
    function isObject(x) {
        return x !== null && typeof x === "object" && !(x instanceof Number) && !(x instanceof String) && !(x instanceof Boolean);
    }
    function formatOnce(str, rep) {
        return str.replace(fsFormatRegExp, function (_, prefix, flags, pad, precision, format) {
            switch (format) {
                case "f":
                case "F":
                    rep = rep.toFixed(precision || 6);
                    break;
                case "g":
                case "G":
                    rep = rep.toPrecision(precision);
                    break;
                case "e":
                case "E":
                    rep = rep.toExponential(precision);
                    break;
                case "O":
                    rep = toString$2(rep);
                    break;
                case "A":
                    try {
                        rep = JSON.stringify(rep, function (k, v) {
                            return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v)
                                : v && typeof v.ToString === "function" ? toString$2(v) : v;
                        });
                    }
                    catch (err) {
                        rep = "{" + Object.getOwnPropertyNames(rep).map(function (k) { return k + ": " + String(rep[k]); }).join(", ") + "}";
                    }
                    break;
                case "x":
                    rep = toHex(Number(rep));
                    break;
                case "X":
                    rep = toHex(Number(rep)).toUpperCase();
                    break;
            }
            var plusPrefix = flags.indexOf("+") >= 0 && parseInt(rep) >= 0;
            if (!isNaN(pad = parseInt(pad))) {
                var ch = pad >= 0 && flags.indexOf("0") >= 0 ? "0" : " ";
                rep = padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);
            }
            var once = prefix + (plusPrefix ? "+" + rep : rep);
            return once.replace(/%/g, "%%");
        });
    }
    function makeFn(str) {
        return function (rep) {
            var str2 = formatOnce(str, rep);
            return fsFormatRegExp.test(str2)
                ? makeFn(str2) : _cont(str2.replace(/%%/g, "%"));
        };
    }
    if (args.length === 0) {
        return function (cont) {
            _cont = cont;
            return fsFormatRegExp.test(str) ? makeFn(str) : _cont(str);
        };
    }
    else {
        for (var i = 0; i < args.length; i++) {
            str = formatOnce(str, args[i]);
        }
        return str.replace(/%%/g, "%");
    }
}

function endsWith(str, search) {
    var idx = str.lastIndexOf(search);
    return idx >= 0 && idx == str.length - search.length;
}


function isNullOrEmpty(str) {
    return typeof str !== "string" || str.length == 0;
}
function isNullOrWhiteSpace(str) {
    return typeof str !== "string" || /^\s*$/.test(str);
}
function join(delimiter, xs) {
    xs = typeof xs == "string" ? getRestParams(arguments, 1) : xs;
    return (Array.isArray(xs) ? xs : Array.from(xs)).join(delimiter);
}
function newGuid() {
    var uuid = "";
    for (var i = 0; i < 32; i++) {
        var random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20)
            uuid += "-";
        uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
    }
    return uuid;
}
function padLeft(str, len, ch, isRight) {
    ch = ch || " ";
    str = String(str);
    len = len - str.length;
    for (var i = -1; ++i < len;)
        str = isRight ? str + ch : ch + str;
    return str;
}


function replace$$1(str, search, replace$$1) {
    return str.replace(new RegExp(escape(search), "g"), replace$$1);
}

function split$$1(str, splitters, count, removeEmpty) {
    count = typeof count == "number" ? count : null;
    removeEmpty = typeof removeEmpty == "number" ? removeEmpty : null;
    if (count < 0)
        throw new Error("Count cannot be less than zero");
    if (count === 0)
        return [];
    splitters = Array.isArray(splitters) ? splitters : getRestParams(arguments, 1);
    splitters = splitters.map(function (x) { return escape(x); });
    splitters = splitters.length > 0 ? splitters : [" "];
    var m;
    var i = 0;
    var splits = [];
    var reg = new RegExp(splitters.join("|"), "g");
    while ((count == null || count > 1) && (m = reg.exec(str)) !== null) {
        if (!removeEmpty || (m.index - i) > 0) {
            count = count != null ? count - 1 : count;
            splits.push(str.substring(i, m.index));
        }
        i = reg.lastIndex;
    }
    if (!removeEmpty || (str.length - i) > 0)
        splits.push(str.substring(i));
    return splits;
}
function trim(str, side) {
    var chars = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        chars[_i - 2] = arguments[_i];
    }
    if (side == "both" && chars.length == 0)
        return str.trim();
    if (side == "start" || side == "both") {
        var reg = chars.length == 0 ? /^\s+/ : new RegExp("^[" + escape(chars.join("")) + "]+");
        str = str.replace(reg, "");
    }
    if (side == "end" || side == "both") {
        var reg = chars.length == 0 ? /\s+$/ : new RegExp("[" + escape(chars.join("")) + "]+$");
        str = str.replace(reg, "");
    }
    return str;
}

var Trampoline = (function () {
    function Trampoline() {
        this.callCount = 0;
    }
    Object.defineProperty(Trampoline, "maxTrampolineCallCount", {
        get: function () {
            return 2000;
        },
        enumerable: true,
        configurable: true
    });
    Trampoline.prototype.incrementAndCheck = function () {
        return this.callCount++ > Trampoline.maxTrampolineCallCount;
    };
    Trampoline.prototype.hijack = function (f) {
        this.callCount = 0;
        setTimeout(f, 0);
    };
    return Trampoline;
}());
function protectedCont(f) {
    return function (ctx) {
        if (ctx.cancelToken.isCancelled)
            ctx.onCancel("cancelled");
        else if (ctx.trampoline.incrementAndCheck())
            ctx.trampoline.hijack(function () {
                try {
                    f(ctx);
                }
                catch (err) {
                    ctx.onError(err);
                }
            });
        else
            try {
                f(ctx);
            }
            catch (err) {
                ctx.onError(err);
            }
    };
}
function protectedBind(computation, binder) {
    return protectedCont(function (ctx) {
        computation({
            onSuccess: function (x) { return binder(x)(ctx); },
            onError: ctx.onError,
            onCancel: ctx.onCancel,
            cancelToken: ctx.cancelToken,
            trampoline: ctx.trampoline
        });
    });
}
function protectedReturn(value) {
    return protectedCont(function (ctx) { return ctx.onSuccess(value); });
}
var AsyncBuilder = (function () {
    function AsyncBuilder() {
    }
    AsyncBuilder.prototype.Bind = function (computation, binder) {
        return protectedBind(computation, binder);
    };
    AsyncBuilder.prototype.Combine = function (computation1, computation2) {
        return this.Bind(computation1, function () { return computation2; });
    };
    AsyncBuilder.prototype.Delay = function (generator) {
        return protectedCont(function (ctx) { return generator()(ctx); });
    };
    AsyncBuilder.prototype.For = function (sequence, body) {
        var iter = sequence[Symbol.iterator]();
        var cur = iter.next();
        return this.While(function () { return !cur.done; }, this.Delay(function () {
            var res = body(cur.value);
            cur = iter.next();
            return res;
        }));
    };
    AsyncBuilder.prototype.Return = function (value) {
        return protectedReturn(value);
    };
    AsyncBuilder.prototype.ReturnFrom = function (computation) {
        return computation;
    };
    AsyncBuilder.prototype.TryFinally = function (computation, compensation) {
        return protectedCont(function (ctx) {
            computation({
                onSuccess: function (x) {
                    compensation();
                    ctx.onSuccess(x);
                },
                onError: function (x) {
                    compensation();
                    ctx.onError(x);
                },
                onCancel: function (x) {
                    compensation();
                    ctx.onCancel(x);
                },
                cancelToken: ctx.cancelToken,
                trampoline: ctx.trampoline
            });
        });
    };
    AsyncBuilder.prototype.TryWith = function (computation, catchHandler) {
        return protectedCont(function (ctx) {
            computation({
                onSuccess: ctx.onSuccess,
                onCancel: ctx.onCancel,
                cancelToken: ctx.cancelToken,
                trampoline: ctx.trampoline,
                onError: function (ex) {
                    try {
                        catchHandler(ex)(ctx);
                    }
                    catch (ex2) {
                        ctx.onError(ex2);
                    }
                }
            });
        });
    };
    AsyncBuilder.prototype.Using = function (resource, binder) {
        return this.TryFinally(binder(resource), function () { return resource.Dispose(); });
    };
    AsyncBuilder.prototype.While = function (guard, computation) {
        var _this = this;
        if (guard())
            return this.Bind(computation, function () { return _this.While(guard, computation); });
        else
            return this.Return(void 0);
    };
    AsyncBuilder.prototype.Zero = function () {
        return protectedCont(function (ctx) { return ctx.onSuccess(void 0); });
    };
    return AsyncBuilder;
}());
var singleton$2 = new AsyncBuilder();

var Choice = (function () {
    function Choice(t, d) {
        this.Case = t;
        this.Fields = d;
    }
    Object.defineProperty(Choice.prototype, "valueIfChoice1", {
        get: function () {
            return this.Case === "Choice1Of2" ? this.Fields[0] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Choice.prototype, "valueIfChoice2", {
        get: function () {
            return this.Case === "Choice2Of2" ? this.Fields[0] : null;
        },
        enumerable: true,
        configurable: true
    });
    Choice.prototype.Equals = function (other) {
        return equalsUnions(this, other);
    };
    Choice.prototype.CompareTo = function (other) {
        return compareUnions(this, other);
    };
    Choice.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Core.FSharpChoice",
            interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"]
        };
    };
    return Choice;
}());

var Async$1 = (function () {
    function Async() {
    }
    return Async;
}());
function emptyContinuation(x) {
}
function awaitPromise(p) {
    return fromContinuations(function (conts) {
        return p.then(conts[0]).catch(function (err) {
            return (err == "cancelled" ? conts[2] : conts[1])(err);
        });
    });
}

var defaultCancellationToken = { isCancelled: false };

function fromContinuations(f) {
    return protectedCont(function (ctx) { return f([ctx.onSuccess, ctx.onError, ctx.onCancel]); });
}

function parallel(computations) {
    return awaitPromise(Promise.all(map$5(function (w) { return startAsPromise(w); }, computations)));
}
function sleep(millisecondsDueTime) {
    return protectedCont(function (ctx) {
        setTimeout(function () { return ctx.cancelToken.isCancelled ? ctx.onCancel("cancelled") : ctx.onSuccess(void 0); }, millisecondsDueTime);
    });
}
function start(computation, cancellationToken) {
    return startWithContinuations(computation, cancellationToken);
}
function startImmediate(computation, cancellationToken) {
    return start(computation, cancellationToken);
}
function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {
    if (typeof continuation !== "function") {
        cancelToken = continuation;
        continuation = null;
    }
    var trampoline = new Trampoline();
    computation({
        onSuccess: continuation ? continuation : emptyContinuation,
        onError: exceptionContinuation ? exceptionContinuation : emptyContinuation,
        onCancel: cancellationContinuation ? cancellationContinuation : emptyContinuation,
        cancelToken: cancelToken ? cancelToken : defaultCancellationToken,
        trampoline: trampoline
    });
}
function startAsPromise(computation, cancellationToken) {
    return new Promise(function (resolve, reject) {
        return startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : defaultCancellationToken);
    });
}

function isLocalHost() {
  if (typeof window == 'undefined' ? true : window.location.hostname === "localhost") {
    return true;
  } else {
    return window.location.hostname === "127.0.0.1";
  }
}
var enabledCategories = !isLocalHost() ? create$2(new List$2(), new GenericComparer(compare)) : create$2(ofArray(["RUNTIME", "API", "LIVE", "SYSTEM", "PARSING", "BINDER", "COMPLETIONS", "EDITORS", "TYPECHECKER", "PROVIDERS", "SERVICE", "CODEGEN", "INTERPRETER", "RUNTIME"]), new GenericComparer(compare));
var Log = function () {
  function Log() {
    _classCallCheck(this, Log);
  }

  _createClass(Log, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Common.Log",
        properties: {}
      };
    }
  }], [{
    key: "setEnabled",
    value: function (cats) {
      enabledCategories = cats;
    }
  }, {
    key: "event",
    value: function (category, evt, article, data) {
      if (typeof logEvent != 'undefined') logEvent(category, evt, article, data);
    }
  }, {
    key: "message",
    value: function (level, category, msg) {
      for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      var args_1 = args == null ? [] : args;
      var category_1 = category.toLocaleUpperCase();

      if (!isLocalHost() ? level === "EXCEPTION" : false) {
        if (typeof logEvent != 'undefined') logEvent("system", "exception", "", {
          category: category_1,
          msg: msg,
          args: args_1
        });
      }

      if ((level === "EXCEPTION" ? true : level === "ERROR") ? true : enabledCategories.has(category_1)) {
        var dt = now();

        var p2 = function p2(s) {
          return padLeft(String(s), 2, "0");
        };

        var p4 = function p4(s_1) {
          return padLeft(String(s_1), 4, "0");
        };

        var prefix = fsFormat("[%s:%s:%s:%s] %s: ")(function (x) {
          return x;
        })(p2(hour(dt)))(p2(minute(dt)))(p2(second(dt)))(p4(millisecond(dt)))(category_1);
        var color = void 0;

        switch (level) {
          case "TRACE":
            color = "color:#808080";
            break;

          case "EXCEPTION":
            color = "color:#c00000";
            break;

          case "ERROR":
            color = "color:#900000";
            break;

          default:
            color = "";
        }

        console.log.apply(console, _Array$from(append$1(["%c" + prefix + msg, color], args_1)));
      }
    }
  }, {
    key: "trace",
    value: function (category, msg) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      Log.message.apply(Log, ["TRACE", category, msg].concat(args));
    }
  }, {
    key: "exn",
    value: function (category, msg) {
      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      Log.message.apply(Log, ["EXCEPTION", category, msg].concat(args));
    }
  }, {
    key: "error",
    value: function (category, msg) {
      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      Log.message.apply(Log, ["ERROR", category, msg].concat(args));
    }
  }]);

  return Log;
}();
setType("TheGamma.Common.Log", Log);
var Http = function () {
  function Http() {
    _classCallCheck(this, Http);
  }

  _createClass(Http, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Common.Http",
        properties: {}
      };
    }
  }], [{
    key: "Request",
    value: function (meth, url, data, cookies) {
      return fromContinuations(function (tupledArg) {
        var xhr = new XMLHttpRequest();
        xhr.open(meth, url, true);
        var $var1 = cookies != null ? cookies !== "" ? [0, cookies] : [1] : [1];

        switch ($var1[0]) {
          case 0:
            xhr.setRequestHeader("X-Cookie", $var1[1]);
            break;

          case 1:
            break;
        }

        xhr.onreadystatechange = function (_arg1) {
          if (xhr.readyState > 3 ? xhr.status === 200 : false) {
            tupledArg[0](xhr.responseText);
          }

          return {};
        };

        xhr.send(data != null ? data : "");
      });
    }
  }]);

  return Http;
}();
setType("TheGamma.Common.Http", Http);

function Async_AwaitFuture_Static(f) {
  return fromContinuations(function (tupledArg) {
    f.Then(tupledArg[0]);
  });
}

function Async_Future_Static(n, op, start$$1) {
  var res = new Choice("Choice1Of3", [null]);
  var handlers = new List$2();
  var running = false;

  var trigger = function trigger(h) {
    if (res.Case === "Choice2Of3") {
      var v = res.Fields[0];
      h(v);
    } else if (res.Case === "Choice3Of3") {
      var e = res.Fields[0];
      throw e;
    } else {
      handlers = new List$2(h, handlers);
    }
  };

  var ensureStarted = function ensureStarted() {
    if (!running) {
      iterate$1(function (n_1) {
        Log.trace("system", "Starting future '%s'....", n_1);
      }, defaultArg(n, [], function (x) {
        return [x];
      }));
      running = true;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Combine(builder_.TryWith(builder_.Delay(function () {
            return builder_.Bind(op, function (_arg1) {
              iterate$1(function (n_2) {
                Log.trace("system", "Future '%s' evaluated to: %O", n_2, _arg1);
              }, defaultArg(n, [], function (x) {
                return [x];
              }));
              res = new Choice("Choice2Of3", [_arg1]);
              return builder_.Zero();
            });
          }), function (_arg2) {
            Log.exn("system", "Evaluating future failed: %O", _arg2);
            res = new Choice("Choice3Of3", [_arg2]);
            return builder_.Zero();
          }), builder_.Delay(function () {
            return builder_.For(handlers, function (_arg3) {
              trigger(_arg3);
              return builder_.Zero();
            });
          }));
        });
      }(singleton$2));
    }
  };

  if (start$$1 === true) {
    ensureStarted(null);
  }

  return _defineProperty({
    Then: function (f) {
      ensureStarted(null);
      trigger(f);
    }
  }, _Symbol.reflection, function () {
    return {
      interfaces: ["TheGamma.Common.Future"]
    };
  });
}

function Async_StartAsFuture_Static(op) {
  return function (arg00) {
    return function (arg10) {
      return function (arg20) {
        return Async_Future_Static(arg00, arg10, arg20);
      };
    };
  }(null)(op)(true);
}

function Async_CreateNamedFuture_Static(name, op) {
  return function (arg00) {
    return function (arg10) {
      return function (arg20) {
        return Async_Future_Static(arg00, arg10, arg20);
      };
    };
  }(name)(op)(false);
}

function Async_StartAsNamedFuture_Static(name, op) {
  return function (arg00) {
    return function (arg10) {
      return function (arg20) {
        return Async_Future_Static(arg00, arg10, arg20);
      };
    };
  }(name)(op)(true);
}

var Async = function (__exports) {
  var _Array = __exports.Array = function (__exports) {
    var Parallel = __exports.Parallel = function (__exports) {
      var map$$1 = __exports.map = function (f, ar) {
        return function (builder_) {
          return builder_.Delay(function () {
            var res = new Array(ar.length).fill(null);
            var work = parallel(toList(delay(function () {
              return map$5(function (i) {
                return function (builder__1) {
                  return builder__1.Delay(function () {
                    return builder__1.Bind(f(ar[i]), function (_arg1) {
                      res[i] = _arg1;
                      return builder__1.Zero();
                    });
                  });
                }(singleton$2);
              }, range(0, ar.length - 1));
            })));
            return builder_.Bind(work, function (_arg2) {
              return builder_.Return(res);
            });
          });
        }(singleton$2);
      };

      return __exports;
    }({});

    var map$$1 = __exports.map = function (f, ar) {
      return function (builder_) {
        return builder_.Delay(function () {
          var res = new Array(ar.length).fill(null);
          return builder_.Combine(builder_.For(range(0, ar.length - 1), function (_arg1) {
            return builder_.Bind(f(ar[_arg1]), function (_arg2) {
              res[_arg1] = _arg2;
              return builder_.Zero();
            });
          }), builder_.Delay(function () {
            return builder_.Return(res);
          }));
        });
      }(singleton$2);
    };

    return __exports;
  }({});

  var collect$$1 = __exports.collect = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$2()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(collect$$1(f, l.tail), function (_arg2) {
            return builder_.Return(append$$1(_arg1, _arg2));
          });
        });
      });
    }(singleton$2);
  };

  var choose$$1 = __exports.choose = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$2()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(choose$$1(f, l.tail), function (_arg2) {
            return builder_.Return(_arg1 != null ? new List$2(_arg1, _arg2) : _arg2);
          });
        });
      });
    }(singleton$2);
  };

  var map$$1 = __exports.map = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$2()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(map$$1(f, l.tail), function (_arg2) {
            return builder_.Return(new List$2(_arg1, _arg2));
          });
        });
      });
    }(singleton$2);
  };

  var foldMap = __exports.foldMap = function (f, st, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return([st, new List$2()]) : builder_.Bind(f(st)(l.head), function (_arg1) {
          return builder_.Bind(foldMap(f, _arg1[1], l.tail), function (_arg2) {
            return builder_.Return([_arg2[0], new List$2(_arg1[0], _arg2[1])]);
          });
        });
      });
    }(singleton$2);
  };

  var fold$$1 = __exports.fold = function (f, st, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(st) : builder_.Bind(f(st)(l.head), function (_arg1) {
          return builder_.ReturnFrom(fold$$1(f, _arg1, l.tail));
        });
      });
    }(singleton$2);
  };

  return __exports;
}({});
var ListDictionaryNode = function () {
  function ListDictionaryNode(result, nested) {
    _classCallCheck(this, ListDictionaryNode);

    this.Result = result;
    this.Nested = nested;
  }

  _createClass(ListDictionaryNode, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Common.ListDictionaryNode",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Result: Option(GenericParam("T")),
          Nested: makeGeneric(_Map, {
            TKey: GenericParam("K"),
            TValue: makeGeneric(ListDictionaryNode, {
              K: GenericParam("K"),
              T: GenericParam("T")
            })
          })
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return ListDictionaryNode;
}();
setType("TheGamma.Common.ListDictionaryNode", ListDictionaryNode);
var ListDictionaryModule = function (__exports) {
  var tryFind$$1 = __exports.tryFind = function (ks, dict) {
    var loop = function loop(ks_1) {
      return function (node) {
        var _loop = function _loop() {
          var matchValue = [ks_1, node];
          var $var2 = matchValue[0].tail != null ? function () {
            var ks_2 = matchValue[0].tail;
            var k = matchValue[0].head;
            var d = matchValue[1].Nested;
            return d.has(k);
          }() ? [1, matchValue[1].Nested, matchValue[0].head, matchValue[0].tail] : [2] : matchValue[1].Result != null ? [0, matchValue[1].Result] : [2];

          switch ($var2[0]) {
            case 0:
              return {
                v: $var2[1]
              };

            case 1:
              ks_1 = $var2[3];
              node = $var2[1].get($var2[2]);
              return "continue|loop";

            case 2:
              return {
                v: null
              };
          }
        };

        loop: while (true) {
          var _ret = _loop();

          switch (_ret) {
            case "continue|loop":
              continue loop;

            default:
              if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
          }
        }
      };
    };

    return loop(ks)(new ListDictionaryNode(null, dict));
  };

  var set = __exports.set = function (ks, v, dict) {
    var loop = function loop(ks_1) {
      return function (dict_1) {
        if (ks_1.tail != null) {
          if (!dict_1.has(ks_1.head)) {
            dict_1.set(ks_1.head, function () {
              var Nested = new _Map();
              return new ListDictionaryNode(null, Nested);
            }());
          }

          if (ks_1.tail.tail == null) {
            dict_1.get(ks_1.head).Result = v;
          } else {
            loop(ks_1.tail)(dict_1.get(ks_1.head).Nested);
          }
        } else {
          throw new Error("Empty key not supported");
        }
      };
    };

    loop(ks)(dict);
  };

  var count$$1 = __exports.count = function (dict) {
    var loop = function loop(node) {
      var nest = sumBy(function (kv) {
        return loop(kv[1]);
      }, node.Nested);

      if (function () {
        return node.Result != null;
      }(null)) {
        return 1 + nest;
      } else {
        return nest;
      }
    };

    return sumBy(function (kv_1) {
      return loop(kv_1[1]);
    }, dict);
  };

  return __exports;
}({});
var List = function (__exports) {
  var groupWith = __exports.groupWith = function (f, list) {
    var groups = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(list), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var e = _step.value;
        var added = false;
        var i = 0;

        while (!added ? i < groups.length : false) {
          if (f(e)(groups[i][0])) {
            groups[i][1].push(e);
            added = true;
          }

          i = i + 1;
        }

        if (!added) {
          groups.push([e, _Array$from(ofArray([e]))]);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return toList(map$5(function ($var3) {
      return toList($var3[1]);
    }, groups));
  };

  var unreduce = __exports.unreduce = function (f, s) {
    return toList(unfold(function (s_1) {
      return defaultArg(f(s_1), null, function (v) {
        return [v, v];
      });
    }, s));
  };

  return __exports;
}({});

var Position = function () {
    function Position(line, column) {
        _classCallCheck(this, Position);

        this.line = line;
        this.column = column;
    }

    _createClass(Position, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Position",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    line: "number",
                    column: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return Position;
}();
setType("TheGamma.Babel.Position", Position);
var SourceLocation = function () {
    function SourceLocation(start, end) {
        _classCallCheck(this, SourceLocation);

        this.start = start;
        this.end = end;
    }

    _createClass(SourceLocation, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.SourceLocation",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    start: Position,
                    end: Position
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return SourceLocation;
}();
setType("TheGamma.Babel.SourceLocation", SourceLocation);
var AssignmentOperator = function () {
    function AssignmentOperator(caseName, fields) {
        _classCallCheck(this, AssignmentOperator);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(AssignmentOperator, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.AssignmentOperator",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    AssignAndBitwise: [],
                    AssignDivide: [],
                    AssignEqual: [],
                    AssignMinus: [],
                    AssignModulus: [],
                    AssignMultiply: [],
                    AssignOrBitwise: [],
                    AssignPlus: [],
                    AssignShiftLeft: [],
                    AssignShiftRightSignPropagating: [],
                    AssignShiftRightZeroFill: [],
                    AssignXorBitwise: []
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return AssignmentOperator;
}();
setType("TheGamma.Babel.AssignmentOperator", AssignmentOperator);
var BinaryOperator = function () {
    function BinaryOperator(caseName, fields) {
        _classCallCheck(this, BinaryOperator);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(BinaryOperator, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.BinaryOperator",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    BinaryAndBitwise: [],
                    BinaryDivide: [],
                    BinaryEqual: [],
                    BinaryEqualStrict: [],
                    BinaryExponent: [],
                    BinaryGreater: [],
                    BinaryGreaterOrEqual: [],
                    BinaryIn: [],
                    BinaryInstanceOf: [],
                    BinaryLess: [],
                    BinaryLessOrEqual: [],
                    BinaryMinus: [],
                    BinaryModulus: [],
                    BinaryMultiply: [],
                    BinaryOrBitwise: [],
                    BinaryPlus: [],
                    BinaryShiftLeft: [],
                    BinaryShiftRightSignPropagating: [],
                    BinaryShiftRightZeroFill: [],
                    BinaryUnequal: [],
                    BinaryUnequalStrict: [],
                    BinaryXorBitwise: []
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return BinaryOperator;
}();
setType("TheGamma.Babel.BinaryOperator", BinaryOperator);
var Pattern = function () {
    function Pattern(caseName, fields) {
        _classCallCheck(this, Pattern);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(Pattern, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Pattern",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    IdentifierPattern: ["string", Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return Pattern;
}();
setType("TheGamma.Babel.Pattern", Pattern);
var VariableDeclarationKind = function () {
    function VariableDeclarationKind(caseName, fields) {
        _classCallCheck(this, VariableDeclarationKind);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(VariableDeclarationKind, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.VariableDeclarationKind",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    Const: [],
                    Let: [],
                    Var: []
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return VariableDeclarationKind;
}();
setType("TheGamma.Babel.VariableDeclarationKind", VariableDeclarationKind);
var VariableDeclarator = function () {
    function VariableDeclarator(caseName, fields) {
        _classCallCheck(this, VariableDeclarator);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(VariableDeclarator, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.VariableDeclarator",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    VariableDeclarator: [Pattern, Option(Expression), Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return VariableDeclarator;
}();
setType("TheGamma.Babel.VariableDeclarator", VariableDeclarator);
var Expression = function () {
    function Expression(caseName, fields) {
        _classCallCheck(this, Expression);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(Expression, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Expression",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    ArrayExpression: [makeGeneric(List$2, {
                        T: Expression
                    }), Option(SourceLocation)],
                    AssignmentExpression: [AssignmentOperator, Expression, Expression, Option(SourceLocation)],
                    BinaryExpression: [BinaryOperator, Expression, Expression, Option(SourceLocation)],
                    BooleanLiteral: ["boolean", Option(SourceLocation)],
                    CallExpression: [Expression, makeGeneric(List$2, {
                        T: Expression
                    }), Option(SourceLocation)],
                    FunctionExpression: [Option("string"), makeGeneric(List$2, {
                        T: Pattern
                    }), Statement, "boolean", "boolean", Option(SourceLocation)],
                    IdentifierExpression: ["string", Option(SourceLocation)],
                    MemberExpression: [Expression, Expression, "boolean", Option(SourceLocation)],
                    NewExpression: [Expression, makeGeneric(List$2, {
                        T: Expression
                    }), Option(SourceLocation)],
                    NullLiteral: [Option(SourceLocation)],
                    NumericLiteral: ["number", Option(SourceLocation)],
                    StringLiteral: ["string", Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return Expression;
}();
setType("TheGamma.Babel.Expression", Expression);
var Statement = function () {
    function Statement(caseName, fields) {
        _classCallCheck(this, Statement);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(Statement, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Statement",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    BlockStatement: [makeGeneric(List$2, {
                        T: Statement
                    }), Option(SourceLocation)],
                    EmptyStatement: [Option(SourceLocation)],
                    ExpressionStatement: [Expression, Option(SourceLocation)],
                    ReturnStatement: [Expression, Option(SourceLocation)],
                    VariableDeclaration: [VariableDeclarationKind, makeGeneric(List$2, {
                        T: VariableDeclarator
                    }), Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return Statement;
}();
setType("TheGamma.Babel.Statement", Statement);
var Program$1 = function () {
    function Program(location, body) {
        _classCallCheck(this, Program);

        this.location = location;
        this.body = body;
    }

    _createClass(Program, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Program",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    location: Option(SourceLocation),
                    body: makeGeneric(List$2, {
                        T: Statement
                    })
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return Program;
}();
setType("TheGamma.Babel.Program", Program$1);
var Serializer = function (__exports) {
    var createObj$$1 = __exports.createObj = function (props) {
        return createObj(concat$$1(props));
    };

    var serializeBinaryOperator = __exports.serializeBinaryOperator = function (_arg1) {
        if (_arg1.Case === "BinaryUnequal") {
            return "!=";
        } else if (_arg1.Case === "BinaryEqualStrict") {
            return "===";
        } else if (_arg1.Case === "BinaryUnequalStrict") {
            return "!==";
        } else if (_arg1.Case === "BinaryLess") {
            return "<";
        } else if (_arg1.Case === "BinaryLessOrEqual") {
            return "<=";
        } else if (_arg1.Case === "BinaryGreater") {
            return ">";
        } else if (_arg1.Case === "BinaryGreaterOrEqual") {
            return ">=";
        } else if (_arg1.Case === "BinaryShiftLeft") {
            return "<<";
        } else if (_arg1.Case === "BinaryShiftRightSignPropagating") {
            return ">>";
        } else if (_arg1.Case === "BinaryShiftRightZeroFill") {
            return ">>>";
        } else if (_arg1.Case === "BinaryMinus") {
            return "-";
        } else if (_arg1.Case === "BinaryPlus") {
            return "+";
        } else if (_arg1.Case === "BinaryMultiply") {
            return "*";
        } else if (_arg1.Case === "BinaryDivide") {
            return "/";
        } else if (_arg1.Case === "BinaryModulus") {
            return "%";
        } else if (_arg1.Case === "BinaryExponent") {
            return "**";
        } else if (_arg1.Case === "BinaryOrBitwise") {
            return "|";
        } else if (_arg1.Case === "BinaryXorBitwise") {
            return "^";
        } else if (_arg1.Case === "BinaryAndBitwise") {
            return "&";
        } else if (_arg1.Case === "BinaryIn") {
            return "in";
        } else if (_arg1.Case === "BinaryInstanceOf") {
            return "instanceof";
        } else {
            return "==";
        }
    };

    var serializeAssignOperator = __exports.serializeAssignOperator = function (_arg1) {
        if (_arg1.Case === "AssignMinus") {
            return "-=";
        } else if (_arg1.Case === "AssignPlus") {
            return "+=";
        } else if (_arg1.Case === "AssignMultiply") {
            return "*=";
        } else if (_arg1.Case === "AssignDivide") {
            return "/=";
        } else if (_arg1.Case === "AssignModulus") {
            return "%=";
        } else if (_arg1.Case === "AssignShiftLeft") {
            return "<<=";
        } else if (_arg1.Case === "AssignShiftRightSignPropagating") {
            return ">>=";
        } else if (_arg1.Case === "AssignShiftRightZeroFill") {
            return ">>>=";
        } else if (_arg1.Case === "AssignOrBitwise") {
            return "|=";
        } else if (_arg1.Case === "AssignXorBitwise") {
            return "^=";
        } else if (_arg1.Case === "AssignAndBitwise") {
            return "&=";
        } else {
            return "=";
        }
    };

    var serializePattern = __exports.serializePattern = function (pat) {
        return createObj$$1(ofArray([ofArray([["type", "Identifier"]]), ofArray([["name", pat.Fields[0]]]), function () {
            var $var36 = pat.Fields[1];

            if ($var36 != null) {
                return ofArray([["loc", $var36]]);
            } else {
                return new List$2();
            }
        }()]));
    };

    var serializeDeclarator = __exports.serializeDeclarator = function (_arg1) {
        return createObj$$1(ofArray([ofArray([["type", "VariableDeclarator"]]), ofArray([["id", serializePattern(_arg1.Fields[0])]]), function () {
            var $var37 = defaultArg(_arg1.Fields[1], null, function (expr) {
                return serializeExpression(expr);
            });

            if ($var37 != null) {
                return ofArray([["init", $var37]]);
            } else {
                return new List$2();
            }
        }(), function () {
            var $var38 = _arg1.Fields[2];

            if ($var38 != null) {
                return ofArray([["loc", $var38]]);
            } else {
                return new List$2();
            }
        }()]));
    };

    var serializeExpression = __exports.serializeExpression = function (expr) {
        if (expr.Case === "NewExpression") {
            return createObj$$1(ofArray([ofArray([["type", "NewExpression"]]), ofArray([["callee", serializeExpression(expr.Fields[0])]]), ofArray([["arguments", _Array$from(map$4(function (expr_1) {
                return serializeExpression(expr_1);
            }, expr.Fields[1]))]]), function () {
                var $var39 = expr.Fields[2];

                if ($var39 != null) {
                    return ofArray([["loc", $var39]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "FunctionExpression") {
            return createObj$$1(ofArray([ofArray([["type", "FunctionExpression"]]), function () {
                var $var40 = expr.Fields[0];

                if ($var40 != null) {
                    return ofArray([["id", $var40]]);
                } else {
                    return new List$2();
                }
            }(), ofArray([["params", _Array$from(map$4(function (pat) {
                return serializePattern(pat);
            }, expr.Fields[1]))]]), ofArray([["body", serializeStatement(expr.Fields[2])]]), ofArray([["generator", expr.Fields[3]]]), ofArray([["async", expr.Fields[4]]]), function () {
                var $var41 = expr.Fields[5];

                if ($var41 != null) {
                    return ofArray([["loc", $var41]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "AssignmentExpression") {
            return createObj$$1(ofArray([ofArray([["type", "AssignmentExpression"]]), ofArray([["left", serializeExpression(expr.Fields[1])]]), ofArray([["right", serializeExpression(expr.Fields[2])]]), ofArray([["operator", serializeAssignOperator(expr.Fields[0])]]), function () {
                var $var42 = expr.Fields[3];

                if ($var42 != null) {
                    return ofArray([["loc", $var42]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "CallExpression") {
            return createObj$$1(ofArray([ofArray([["type", "CallExpression"]]), ofArray([["callee", serializeExpression(expr.Fields[0])]]), ofArray([["arguments", _Array$from(map$4(function (expr_2) {
                return serializeExpression(expr_2);
            }, expr.Fields[1]))]]), function () {
                var $var43 = expr.Fields[2];

                if ($var43 != null) {
                    return ofArray([["loc", $var43]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "MemberExpression") {
            return createObj$$1(ofArray([ofArray([["type", "MemberExpression"]]), ofArray([["object", serializeExpression(expr.Fields[0])]]), ofArray([["property", serializeExpression(expr.Fields[1])]]), ofArray([["computed", expr.Fields[2]]]), function () {
                var $var44 = expr.Fields[3];

                if ($var44 != null) {
                    return ofArray([["loc", $var44]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "BinaryExpression") {
            return createObj$$1(ofArray([ofArray([["type", "BinaryExpression"]]), ofArray([["left", serializeExpression(expr.Fields[1])]]), ofArray([["right", serializeExpression(expr.Fields[2])]]), ofArray([["operator", serializeBinaryOperator(expr.Fields[0])]]), function () {
                var $var45 = expr.Fields[3];

                if ($var45 != null) {
                    return ofArray([["loc", $var45]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "ArrayExpression") {
            return createObj$$1(ofArray([ofArray([["type", "ArrayExpression"]]), ofArray([["elements", _Array$from(map$4(function (expr_3) {
                return serializeExpression(expr_3);
            }, expr.Fields[0]))]]), function () {
                var $var46 = expr.Fields[1];

                if ($var46 != null) {
                    return ofArray([["loc", $var46]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "NullLiteral") {
            return createObj$$1(ofArray([ofArray([["type", "NullLiteral"]]), function () {
                var $var47 = expr.Fields[0];

                if ($var47 != null) {
                    return ofArray([["loc", $var47]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "StringLiteral") {
            return createObj$$1(ofArray([ofArray([["type", "StringLiteral"]]), ofArray([["value", expr.Fields[0]]]), function () {
                var $var48 = expr.Fields[1];

                if ($var48 != null) {
                    return ofArray([["loc", $var48]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "BooleanLiteral") {
            return createObj$$1(ofArray([ofArray([["type", "BooleanLiteral"]]), ofArray([["value", expr.Fields[0]]]), function () {
                var $var49 = expr.Fields[1];

                if ($var49 != null) {
                    return ofArray([["loc", $var49]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (expr.Case === "NumericLiteral") {
            return createObj$$1(ofArray([ofArray([["type", "NumericLiteral"]]), ofArray([["value", expr.Fields[0]]]), function () {
                var $var50 = expr.Fields[1];

                if ($var50 != null) {
                    return ofArray([["loc", $var50]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else {
            return createObj$$1(ofArray([ofArray([["type", "Identifier"]]), ofArray([["name", expr.Fields[0]]]), function () {
                var $var51 = expr.Fields[1];

                if ($var51 != null) {
                    return ofArray([["loc", $var51]]);
                } else {
                    return new List$2();
                }
            }()]));
        }
    };

    var serializeStatement = __exports.serializeStatement = function (stm) {
        if (stm.Case === "BlockStatement") {
            return createObj$$1(ofArray([ofArray([["type", "BlockStatement"]]), function () {
                var $var52 = stm.Fields[1];

                if ($var52 != null) {
                    return ofArray([["loc", $var52]]);
                } else {
                    return new List$2();
                }
            }(), ofArray([["body", _Array$from(map$4(function (stm_1) {
                return serializeStatement(stm_1);
            }, stm.Fields[0]))]])]));
        } else if (stm.Case === "EmptyStatement") {
            return createObj$$1(ofArray([ofArray([["type", "EmptyStatement"]]), function () {
                var $var53 = stm.Fields[0];

                if ($var53 != null) {
                    return ofArray([["loc", $var53]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else if (stm.Case === "ReturnStatement") {
            return createObj$$1(ofArray([ofArray([["type", "ReturnStatement"]]), function () {
                var $var54 = stm.Fields[1];

                if ($var54 != null) {
                    return ofArray([["loc", $var54]]);
                } else {
                    return new List$2();
                }
            }(), ofArray([["argument", serializeExpression(stm.Fields[0])]])]));
        } else if (stm.Case === "VariableDeclaration") {
            var kind = stm.Fields[0].Case === "Let" ? "let" : stm.Fields[0].Case === "Const" ? "const" : "var";
            return createObj$$1(ofArray([ofArray([["type", "VariableDeclaration"]]), ofArray([["kind", kind]]), ofArray([["declarations", _Array$from(map$4(function (arg00_) {
                return serializeDeclarator(arg00_);
            }, stm.Fields[1]))]]), function () {
                var $var55 = stm.Fields[2];

                if ($var55 != null) {
                    return ofArray([["loc", $var55]]);
                } else {
                    return new List$2();
                }
            }()]));
        } else {
            return createObj$$1(ofArray([ofArray([["type", "ExpressionStatement"]]), function () {
                var $var56 = stm.Fields[1];

                if ($var56 != null) {
                    return ofArray([["loc", $var56]]);
                } else {
                    return new List$2();
                }
            }(), ofArray([["expression", serializeExpression(stm.Fields[0])]])]));
        }
    };

    var serializeProgram = __exports.serializeProgram = function (prog) {
        return createObj$$1(ofArray([ofArray([["type", "Program"]]), function () {
            var $var57 = prog.location;

            if ($var57 != null) {
                return ofArray([["loc", $var57]]);
            } else {
                return new List$2();
            }
        }(), ofArray([["sourceType", "module"]]), ofArray([["body", _Array$from(map$4(function (stm) {
            return serializeStatement(stm);
        }, prog.body))]]), ofArray([["directives", []]])]));
    };

    return __exports;
}({});

var _Range = function () {
  function _Range(start, end) {
    _classCallCheck(this, _Range);

    this.Start = start;
    this.End = end;
  }

  _createClass(_Range, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Range",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Start: "number",
          End: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return _Range;
}();

setType("TheGamma.Range", _Range);

var _Error = function () {
  function _Error(number, message, range) {
    _classCallCheck(this, _Error);

    this.Number = number;
    this.Message = message;
    this.Range = range;
  }

  _createClass(_Error, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Error",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Number: "number",
          Message: "string",
          Range: GenericParam("Range")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return _Error;
}();

setType("TheGamma.Error", _Error);
var Operator = function () {
  function Operator(caseName, fields) {
    _classCallCheck(this, Operator);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Operator, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Operator",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Divide: [],
          Equals: [],
          GreaterThan: [],
          GreaterThanOrEqual: [],
          LessThan: [],
          LessThanOrEqual: [],
          Minus: [],
          Multiply: [],
          Plus: [],
          Power: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Operator;
}();
setType("TheGamma.Operator", Operator);
var TokenKind = function () {
  function TokenKind(caseName, fields) {
    _classCallCheck(this, TokenKind);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(TokenKind, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TokenKind",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Arrow: [],
          Boolean: ["boolean"],
          By: [],
          Comma: [],
          Dot: [],
          EndOfFile: [],
          Equals: [],
          Error: ["string"],
          Fun: [],
          Ident: ["string"],
          LParen: [],
          LSquare: [],
          Let: [],
          Newline: [],
          Number: ["string", "number"],
          Operator: [Operator],
          QIdent: ["string"],
          RParen: [],
          RSquare: [],
          String: ["string"],
          To: [],
          White: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return TokenKind;
}();
setType("TheGamma.TokenKind", TokenKind);
var Token = function () {
  function Token(token, range) {
    _classCallCheck(this, Token);

    this.Token = token;
    this.Range = range;
  }

  _createClass(Token, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Token",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Token: TokenKind,
          Range: _Range
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Token;
}();
setType("TheGamma.Token", Token);
var Emitter = function () {
  function Emitter(emit) {
    _classCallCheck(this, Emitter);

    this.Emit = emit;
  }

  _createClass(Emitter, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Emitter",
        interfaces: ["FSharpRecord"],
        properties: {
          Emit: "function"
        }
      };
    }
  }]);

  return Emitter;
}();
setType("TheGamma.Emitter", Emitter);
var Metadata = function () {
  function Metadata(context, type, data) {
    _classCallCheck(this, Metadata);

    this.Context = context;
    this.Type = type;
    this.Data = data;
  }

  _createClass(Metadata, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Metadata",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Context: "string",
          Type: "string",
          Data: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return Metadata;
}();
setType("TheGamma.Metadata", Metadata);
var Documentation = function () {
  function Documentation(caseName, fields) {
    _classCallCheck(this, Documentation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Documentation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Documentation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Details: ["string", "string"],
          None: [],
          Text: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Documentation;
}();
setType("TheGamma.Documentation", Documentation);
var Member = function () {
  function Member(caseName, fields) {
    _classCallCheck(this, Member);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Member, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Member",
        interfaces: ["FSharpUnion"],
        cases: {
          Method: ["string", makeGeneric(List$2, {
            T: Tuple(["string", "boolean", Type])
          }), Type, makeGeneric(List$2, {
            T: Metadata
          }), Emitter],
          Property: ["string", Type, makeGeneric(List$2, {
            T: Metadata
          }), Emitter]
        }
      };
    }
  }, {
    key: "Name",
    get: function () {
      var $var58 = this.Case === "Method" ? [0, this.Fields[0]] : [0, this.Fields[0]];

      switch ($var58[0]) {
        case 0:
          return $var58[1];
      }
    }
  }]);

  return Member;
}();
setType("TheGamma.Member", Member);
var ObjectType = function () {
  function ObjectType(members) {
    _classCallCheck(this, ObjectType);

    this.Members = members;
  }

  _createClass(ObjectType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.ObjectType",
        interfaces: ["FSharpRecord"],
        properties: {
          Members: FableArray(Member)
        }
      };
    }
  }]);

  return ObjectType;
}();
setType("TheGamma.ObjectType", ObjectType);
var PrimitiveType = function () {
  function PrimitiveType(caseName, fields) {
    _classCallCheck(this, PrimitiveType);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(PrimitiveType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.PrimitiveType",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Bool: [],
          Number: [],
          String: [],
          Unit: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return PrimitiveType;
}();
setType("TheGamma.PrimitiveType", PrimitiveType);
var Type = function () {
  function Type(caseName, fields) {
    _classCallCheck(this, Type);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Type, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Type",
        interfaces: ["FSharpUnion"],
        cases: {
          Any: [],
          App: [Type, makeGeneric(List$2, {
            T: Type
          })],
          Delayed: ["string", Interface("TheGamma.Common.Future")],
          Forall: [makeGeneric(List$2, {
            T: "string"
          }), Type],
          Function: [makeGeneric(List$2, {
            T: Type
          }), Type],
          List: [Type],
          Object: [ObjectType],
          Parameter: ["string"],
          Primitive: [PrimitiveType]
        }
      };
    }
  }]);

  return Type;
}();
setType("TheGamma.Type", Type);
var Name = function () {
  function Name(name) {
    _classCallCheck(this, Name);

    this.Name = name;
  }

  _createClass(Name, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Name",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Name: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Name;
}();
setType("TheGamma.Name", Name);
var Constant = function () {
  function Constant(caseName, fields) {
    _classCallCheck(this, Constant);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Constant, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Constant",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Boolean: ["boolean"],
          Empty: [],
          Number: ["number"],
          String: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Constant;
}();
setType("TheGamma.Constant", Constant);
var EntityKind = function () {
  function EntityKind(caseName, fields) {
    _classCallCheck(this, EntityKind);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(EntityKind, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.EntityKind",
        interfaces: ["FSharpUnion"],
        cases: {
          ArgumentList: [makeGeneric(List$2, {
            T: Entity
          })],
          Binding: [Name, Entity],
          CallSite: [Entity, Name, Choice],
          ChainElement: ["boolean", Name, Entity, Option(Entity), Option(Entity)],
          Constant: [Constant],
          Function: [Entity, Entity],
          GlobalValue: [Name, Option(Expression)],
          LetCommand: [Entity, Entity],
          List: [makeGeneric(List$2, {
            T: Entity
          })],
          NamedMember: [Name, Entity],
          NamedParam: [Name, Entity],
          Operator: [Entity, Operator, Entity],
          Program: [makeGeneric(List$2, {
            T: Entity
          })],
          Root: [],
          RunCommand: [Entity],
          Variable: [Name, Entity]
        }
      };
    }
  }]);

  return EntityKind;
}();
setType("TheGamma.EntityKind", EntityKind);
var Entity = function () {
  function Entity(kind, symbol, value, meta, type, errors) {
    _classCallCheck(this, Entity);

    this.Kind = kind;
    this.Symbol = symbol;
    this.Value = value;
    this.Meta = meta;
    this.Type = type;
    this.Errors = errors;
  }

  _createClass(Entity, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Entity",
        interfaces: ["FSharpRecord"],
        properties: {
          Kind: EntityKind,
          Symbol: Interface("TheGamma.Common.Symbol"),
          Value: Option(EntityValue),
          Meta: makeGeneric(List$2, {
            T: Metadata
          }),
          Type: Option(Type),
          Errors: makeGeneric(List$2, {
            T: makeGeneric(_Error, {
              Range: _Range
            })
          })
        }
      };
    }
  }]);

  return Entity;
}();
setType("TheGamma.Entity", Entity);
var EntityValue = function () {
  function EntityValue(value, preview) {
    _classCallCheck(this, EntityValue);

    this.Value = value;
    this.Preview = preview;
  }

  _createClass(EntityValue, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.EntityValue",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Value: Interface("TheGamma.RuntimeValue"),
          Preview: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return EntityValue;
}();
setType("TheGamma.EntityValue", EntityValue);

var _Node = function () {
  function _Node(whiteBefore, whiteAfter, range, node, entity) {
    _classCallCheck(this, _Node);

    this.WhiteBefore = whiteBefore;
    this.WhiteAfter = whiteAfter;
    this.Range = range;
    this.Node = node;
    this.Entity = entity;
  }

  _createClass(_Node, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Node",
        interfaces: ["FSharpRecord"],
        properties: {
          WhiteBefore: makeGeneric(List$2, {
            T: Token
          }),
          WhiteAfter: makeGeneric(List$2, {
            T: Token
          }),
          Range: _Range,
          Node: GenericParam("T"),
          Entity: Option(Entity)
        }
      };
    }
  }]);

  return _Node;
}();

setType("TheGamma.Node", _Node);
var Argument = function () {
  function Argument(name, value) {
    _classCallCheck(this, Argument);

    this.Name = name;
    this.Value = value;
  }

  _createClass(Argument, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Argument",
        interfaces: ["FSharpRecord"],
        properties: {
          Name: Option(makeGeneric(_Node, {
            T: Name
          })),
          Value: makeGeneric(_Node, {
            T: Expr
          })
        }
      };
    }
  }]);

  return Argument;
}();
setType("TheGamma.Argument", Argument);
var Program$$1 = function () {
  function Program$$1(body) {
    _classCallCheck(this, Program$$1);

    this.Body = body;
  }

  _createClass(Program$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Program",
        interfaces: ["FSharpRecord"],
        properties: {
          Body: makeGeneric(_Node, {
            T: makeGeneric(List$2, {
              T: makeGeneric(_Node, {
                T: Command
              })
            })
          })
        }
      };
    }
  }]);

  return Program$$1;
}();
setType("TheGamma.Program", Program$$1);
var Command = function () {
  function Command(caseName, fields) {
    _classCallCheck(this, Command);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Command, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Command",
        interfaces: ["FSharpUnion"],
        cases: {
          Expr: [makeGeneric(_Node, {
            T: Expr
          })],
          Let: [makeGeneric(_Node, {
            T: Name
          }), makeGeneric(_Node, {
            T: Expr
          })]
        }
      };
    }
  }]);

  return Command;
}();
setType("TheGamma.Command", Command);
var Expr = function () {
  function Expr(caseName, fields) {
    _classCallCheck(this, Expr);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Expr, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Expr",
        interfaces: ["FSharpUnion"],
        cases: {
          Binary: [makeGeneric(_Node, {
            T: Expr
          }), makeGeneric(_Node, {
            T: Operator
          }), makeGeneric(_Node, {
            T: Expr
          })],
          Boolean: ["boolean"],
          Call: [Option(makeGeneric(_Node, {
            T: Expr
          })), makeGeneric(_Node, {
            T: Name
          }), makeGeneric(_Node, {
            T: makeGeneric(List$2, {
              T: Argument
            })
          })],
          Empty: [],
          Function: [makeGeneric(_Node, {
            T: Name
          }), makeGeneric(_Node, {
            T: Expr
          })],
          List: [makeGeneric(List$2, {
            T: makeGeneric(_Node, {
              T: Expr
            })
          })],
          Number: ["number"],
          Property: [makeGeneric(_Node, {
            T: Expr
          }), makeGeneric(_Node, {
            T: Name
          })],
          String: ["string"],
          Variable: [makeGeneric(_Node, {
            T: Name
          })]
        }
      };
    }
  }]);

  return Expr;
}();
setType("TheGamma.Expr", Expr);

var ProvidedType = function () {
  function ProvidedType(caseName, fields) {
    _classCallCheck(this, ProvidedType);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(ProvidedType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.ProvidedType",
        interfaces: ["FSharpUnion"],
        cases: {
          GlobalValue: ["string", makeGeneric(List$2, {
            T: Metadata
          }), Expression, Type],
          NamedType: ["string", makeGeneric(List$2, {
            T: "string"
          }), Type]
        }
      };
    }
  }]);

  return ProvidedType;
}();
setType("TheGamma.TypeProviders.ProvidedType", ProvidedType);
var ProviderHelpers = function (__exports) {
  var docMeta = __exports.docMeta = function (doc) {
    return new Metadata("http://thegamma.net", "Documentation", doc);
  };

  return __exports;
}({});
var FSharpProvider = function (__exports) {
  var AnyType = __exports.AnyType = function () {
    function AnyType(kind) {
      _classCallCheck(this, AnyType);

      this.kind = kind;
    }

    _createClass(AnyType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.AnyType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return AnyType;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.AnyType", AnyType);

  var GenericParameterType = __exports.GenericParameterType = function () {
    function GenericParameterType(kind, name) {
      _classCallCheck(this, GenericParameterType);

      this.kind = kind;
      this.name = name;
    }

    _createClass(GenericParameterType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.GenericParameterType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            name: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return GenericParameterType;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.GenericParameterType", GenericParameterType);

  var ArrayType = __exports.ArrayType = function () {
    function ArrayType(kind, element) {
      _classCallCheck(this, ArrayType);

      this.kind = kind;
      this.element = element;
    }

    _createClass(ArrayType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.ArrayType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            element: AnyType
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return ArrayType;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.ArrayType", ArrayType);

  var PrimitiveType$$1 = __exports.PrimitiveType = function () {
    function PrimitiveType$$1(kind, name) {
      _classCallCheck(this, PrimitiveType$$1);

      this.kind = kind;
      this.name = name;
    }

    _createClass(PrimitiveType$$1, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.PrimitiveType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            name: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return PrimitiveType$$1;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.PrimitiveType", PrimitiveType$$1);

  var FunctionType = __exports.FunctionType = function () {
    function FunctionType(kind, _arguments, returns) {
      _classCallCheck(this, FunctionType);

      this.kind = kind;
      this.arguments = _arguments;
      this.returns = returns;
    }

    _createClass(FunctionType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.FunctionType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            arguments: FableArray(AnyType),
            returns: AnyType
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return FunctionType;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.FunctionType", FunctionType);

  var NamedType = __exports.NamedType = function () {
    function NamedType(kind, name, typargs) {
      _classCallCheck(this, NamedType);

      this.kind = kind;
      this.name = name;
      this.typargs = typargs;
    }

    _createClass(NamedType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.NamedType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            name: "string",
            typargs: FableArray(AnyType)
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return NamedType;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.NamedType", NamedType);

  var Member$$1 = __exports.Member = function () {
    function Member$$1(kind) {
      _classCallCheck(this, Member$$1);

      this.kind = kind;
    }

    _createClass(Member$$1, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.Member",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return Member$$1;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.Member", Member$$1);

  var Argument$$1 = __exports.Argument = function () {
    function Argument$$1(name, optional, type) {
      _classCallCheck(this, Argument$$1);

      this.name = name;
      this.optional = optional;
      this.type = type;
    }

    _createClass(Argument$$1, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.Argument",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            name: "string",
            optional: "boolean",
            type: AnyType
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return Argument$$1;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.Argument", Argument$$1);

  var MethodMember = __exports.MethodMember = function () {
    function MethodMember(kind, name, typepars, _arguments, returns) {
      _classCallCheck(this, MethodMember);

      this.kind = kind;
      this.name = name;
      this.typepars = typepars;
      this.arguments = _arguments;
      this.returns = returns;
    }

    _createClass(MethodMember, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.MethodMember",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            name: "string",
            typepars: FableArray(AnyType),
            arguments: FableArray(Argument$$1),
            returns: AnyType
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return MethodMember;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.MethodMember", MethodMember);

  var PropertyMember = __exports.PropertyMember = function () {
    function PropertyMember(kind, name, returns) {
      _classCallCheck(this, PropertyMember);

      this.kind = kind;
      this.name = name;
      this.returns = returns;
    }

    _createClass(PropertyMember, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.PropertyMember",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            name: "string",
            returns: AnyType
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return PropertyMember;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.PropertyMember", PropertyMember);

  var ExportedType = __exports.ExportedType = function () {
    function ExportedType(name, typepars, _static, instance, members) {
      _classCallCheck(this, ExportedType);

      this.name = name;
      this.typepars = typepars;
      this.static = _static;
      this.instance = instance;
      this.members = members;
    }

    _createClass(ExportedType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.FSharpProvider.ExportedType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            name: "string",
            typepars: FableArray(AnyType),
            static: "boolean",
            instance: FableArray("string"),
            members: FableArray(Member$$1)
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return ExportedType;
  }();

  setType("TheGamma.TypeProviders.FSharpProvider.ExportedType", ExportedType);

  var provideFSharpTypes = __exports.provideFSharpTypes = function (lookupNamed, url) {
    var mapType = function mapType(t) {
      switch (t.kind) {
        case "primitive":
          var matchValue = t.name;

          switch (matchValue) {
            case "object":
              return new Type("Any", []);

            case "int":
            case "float":
              return new Type("Primitive", [new PrimitiveType("Number", [])]);

            case "string":
              return new Type("Primitive", [new PrimitiveType("String", [])]);

            case "bool":
              return new Type("Primitive", [new PrimitiveType("Bool", [])]);

            case "unit":
              return new Type("Primitive", [new PrimitiveType("Unit", [])]);

            default:
              throw new Error("provideFSharpType: Unsupported type: " + matchValue);
          }

        case "function":
          var t_1 = t;
          return new Type("Function", [toList(t_1.arguments.map(mapType)), mapType(t_1.returns)]);

        case "named":
          var t_2 = t;
          return lookupNamed(t_2.name)(ofArray(t_2.typargs.map(mapType)));

        case "parameter":
          return new Type("Parameter", [t.name]);

        case "array":
          return new Type("List", [mapType(t.element)]);

        default:
          throw new Error("provideFSharpType: Unexpected type");
      }
    };

    var getTypeParameters = function getTypeParameters(typars) {
      return ofArray(typars.map(function (t_3) {
        var matchValue_1 = mapType(t_3);

        if (matchValue_1.Case === "Parameter") {
          return matchValue_1.Fields[0];
        } else {
          throw new Error("importProvidedType: expected type parameter");
        }
      }));
    };

    var importProvidedType = function importProvidedType(exp) {
      return function (arg00) {
        return function (arg10) {
          return Async_CreateNamedFuture_Static(arg00, arg10);
        };
      }(exp.name)(function (builder_) {
        return builder_.Delay(function () {
          var mems = _Array$from(choose$1(function (m) {
            if (m.kind === "method") {
              var _ret = function () {
                var m_1 = m;
                var args = toList(delay(function () {
                  return map$5(function (a) {
                    return [a.name, a.optional, mapType(a.type)];
                  }, m_1.arguments);
                }));
                var emitter = new Emitter(function (tupledArg) {
                  return new Expression("CallExpression", [new Expression("MemberExpression", [tupledArg[0], new Expression("IdentifierExpression", [m_1.name, null]), false, null]), tupledArg[1], null]);
                });
                var typ = void 0;
                var matchValue_2 = getTypeParameters(m_1.typepars);

                if (matchValue_2.tail == null) {
                  typ = mapType(m_1.returns);
                } else {
                  typ = new Type("Forall", [matchValue_2, mapType(m_1.returns)]);
                }

                return {
                  v: new Member("Method", [m_1.name, args, typ, ofArray([ProviderHelpers.docMeta(new Documentation("Text", [""]))]), emitter])
                };
              }();

              if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
            } else {
              return null;
            }
          }, exp.members));

          var matchValue_3 = getTypeParameters(exp.typepars);

          if (matchValue_3.tail == null) {
            return builder_.Return(new Type("Object", [new ObjectType(mems)]));
          } else {
            var obj = new Type("Object", [new ObjectType(mems)]);
            return builder_.Return(new Type("Forall", [matchValue_3, obj]));
          }
        });
      }(singleton$2));
    };

    return function (builder__1) {
      return builder__1.Delay(function () {
        return builder__1.Bind(Http.Request("GET", url), function (_arg1) {
          var expTys = JSON.parse(_arg1);
          return builder__1.Return(toList(delay(function () {
            return map$5(function (exp_1) {
              var guid = url + "," + exp_1.name;
              var ty = new Type("Delayed", [guid, importProvidedType(exp_1)]);

              if (exp_1.static) {
                var _ret2 = function () {
                  var e = fold$1(function (chain, s) {
                    return chain != null ? new Expression("MemberExpression", [chain, new Expression("IdentifierExpression", [s, null]), false, null]) : new Expression("IdentifierExpression", [s, null]);
                  }, null, exp_1.instance);
                  var ty_1 = void 0;
                  var matchValue_4 = getTypeParameters(exp_1.typepars);

                  if (matchValue_4.tail == null) {
                    ty_1 = ty;
                  } else {
                    ty_1 = new Type("App", [ty, toList(delay(function () {
                      return map$5(function (v) {
                        return new Type("Any", []);
                      }, matchValue_4);
                    }))]);
                  }

                  return {
                    v: new ProvidedType("GlobalValue", [exp_1.name, new List$2(), e, ty_1])
                  };
                }();

                if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
              } else {
                return new ProvidedType("NamedType", [exp_1.name, getTypeParameters(exp_1.typepars), ty]);
              }
            }, expTys);
          })));
        });
      });
    }(singleton$2);
  };

  return __exports;
}({});
var RestProvider = function (__exports) {
  var AnyType = __exports.AnyType = function () {
    function AnyType(kind) {
      _classCallCheck(this, AnyType);

      this.kind = kind;
    }

    _createClass(AnyType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.AnyType",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return AnyType;
  }();

  setType("TheGamma.TypeProviders.RestProvider.AnyType", AnyType);

  var TypeNested = __exports.TypeNested = function () {
    function TypeNested(kind, endpoint) {
      _classCallCheck(this, TypeNested);

      this.kind = kind;
      this.endpoint = endpoint;
    }

    _createClass(TypeNested, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.TypeNested",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            kind: "string",
            endpoint: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return TypeNested;
  }();

  setType("TheGamma.TypeProviders.RestProvider.TypeNested", TypeNested);

  var TypePrimitive = __exports.TypePrimitive = function () {
    function TypePrimitive(kind, type, endpoint) {
      _classCallCheck(this, TypePrimitive);

      this.kind = kind;
      this.type = type;
      this.endpoint = endpoint;
    }

    _createClass(TypePrimitive, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.TypePrimitive",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            kind: "string",
            type: Any,
            endpoint: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return TypePrimitive;
  }();

  setType("TheGamma.TypeProviders.RestProvider.TypePrimitive", TypePrimitive);

  var Parameter = __exports.Parameter = function () {
    function Parameter(name, type) {
      _classCallCheck(this, Parameter);

      this.name = name;
      this.type = type;
    }

    _createClass(Parameter, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.Parameter",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            name: "string",
            type: "string"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return Parameter;
  }();

  setType("TheGamma.TypeProviders.RestProvider.Parameter", Parameter);

  var Documentation$$1 = __exports.Documentation = function () {
    function Documentation$$1(title, details) {
      _classCallCheck(this, Documentation$$1);

      this.title = title;
      this.details = details;
    }

    _createClass(Documentation$$1, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.Documentation",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            title: Option("string"),
            details: Option("string")
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return Documentation$$1;
  }();

  setType("TheGamma.TypeProviders.RestProvider.Documentation", Documentation$$1);

  var Member$$1 = __exports.Member = function () {
    function Member$$1(name, returns, parameters, documentation, schema, trace) {
      _classCallCheck(this, Member$$1);

      this.name = name;
      this.returns = returns;
      this.parameters = parameters;
      this.documentation = documentation;
      this.schema = schema;
      this.trace = trace;
    }

    _createClass(Member$$1, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.Member",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            name: "string",
            returns: AnyType,
            parameters: Option(FableArray(Parameter)),
            documentation: Option(Any),
            schema: Option(Any),
            trace: FableArray("string")
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return Member$$1;
  }();

  setType("TheGamma.TypeProviders.RestProvider.Member", Member$$1);

  var ResultType = __exports.ResultType = function () {
    function ResultType(caseName, fields) {
      _classCallCheck(this, ResultType);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ResultType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.ResultType",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Generic: ["string", FableArray(ResultType)],
            Primitive: ["string"],
            Record: [FableArray(Tuple(["string", ResultType]))]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return ResultType;
  }();

  setType("TheGamma.TypeProviders.RestProvider.ResultType", ResultType);

  var RawField = __exports.RawField = function () {
    function RawField(name, type) {
      _classCallCheck(this, RawField);

      this.name = name;
      this.type = type;
    }

    _createClass(RawField, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.RawField",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            name: "string",
            type: Any
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return RawField;
  }();

  setType("TheGamma.TypeProviders.RestProvider.RawField", RawField);

  var RawResultType = __exports.RawResultType = function () {
    function RawResultType(name, fields, params) {
      _classCallCheck(this, RawResultType);

      this.name = name;
      this.fields = fields;
      this.params = params;
    }

    _createClass(RawResultType, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.TypeProviders.RestProvider.RawResultType",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            name: "string",
            fields: FableArray(RawField),
            params: FableArray(Any)
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return RawResultType;
  }();

  setType("TheGamma.TypeProviders.RestProvider.RawResultType", RawResultType);

  var parseDoc = __exports.parseDoc = function (json) {
    if (function () {
      return json == null;
    }(null)) {
      return new Documentation("None", []);
    } else if (typeof json === "string") {
      return new Documentation("Text", [json]);
    } else {
      var doc = json;
      var matchValue = [doc.title, doc.details];
      var $var145 = matchValue[0] != null ? matchValue[1] != null ? [0, matchValue[1], matchValue[0]] : [1] : [1];

      switch ($var145[0]) {
        case 0:
          return new Documentation("Details", [$var145[2], $var145[1]]);

        case 1:
          return new Documentation("None", []);
      }
    }
  };

  var fromRawType = __exports.fromRawType = function (json) {
    if (typeof json === "string") {
      return new ResultType("Primitive", [json]);
    } else {
      var res = json;

      if (res.name === "record") {
        return new ResultType("Record", [res.fields.map(function (f) {
          return [f.name, fromRawType(f.type)];
        })]);
      } else {
        return new ResultType("Generic", [res.name, _Array$from(map$5(function (json_1) {
          return fromRawType(json_1);
        }, res.params))]);
      }
    }
  };

  var load = __exports.load = function (url, cookies) {
    return function (builder_) {
      return builder_.Delay(function () {
        return builder_.Bind(Http.Request("GET", url, null, cookies), function (_arg1) {
          var members = JSON.parse(_arg1);
          return builder_.Return(members);
        });
      });
    }(singleton$2);
  };

  var trimLeft = __exports.trimLeft = function (c, s) {
    return _Array$from(skipWhile(function (y) {
      return c === y;
    }, s.split(""))).join('');
  };

  var trimRight = __exports.trimRight = function (c, s) {
    return _Array$from(skipWhile(function (y) {
      return c === y;
    }, s.split("").slice().reverse())).slice().reverse().join('');
  };

  var concatUrl = __exports.concatUrl = function (a, b) {
    return trimRight("/", a) + "/" + trimLeft("/", b);
  };

  var addTraceCall = __exports.addTraceCall = function (inst, trace) {
    if (isEmpty$1(trace)) {
      return inst;
    } else {
      var trace_1 = new Expression("StringLiteral", [join("&", trace), null]);
      var mem = new Expression("MemberExpression", [inst, new Expression("IdentifierExpression", ["addTrace", null]), false, null]);
      return new Expression("CallExpression", [mem, ofArray([trace_1]), null]);
    }
  };

  var propAccess = __exports.propAccess = function (trace) {
    return new Emitter(function (tupledArg) {
      return addTraceCall(tupledArg[0], trace);
    });
  };

  var methCall = __exports.methCall = function (argNames, trace) {
    return new Emitter(function (tupledArg) {
      var withTrace = addTraceCall(tupledArg[0], trace);
      return function () {
        var folder = function folder(inst) {
          return function (tupledArg_1) {
            var trace_1 = new Expression("BinaryExpression", [new BinaryOperator("BinaryPlus", []), new Expression("StringLiteral", [tupledArg_1[0] + "=", null]), tupledArg_1[1], null]);
            var mem = new Expression("MemberExpression", [inst, new Expression("IdentifierExpression", ["addTrace", null]), false, null]);
            return new Expression("CallExpression", [mem, ofArray([trace_1]), null]);
          };
        };

        return function (source) {
          return fold$1(function ($var146, $var147) {
            return folder($var146)($var147);
          }, withTrace, source);
        };
      }()(zip(argNames, tupledArg[1]));
    });
  };

  var dataCall = __exports.dataCall = function (parser, trace, endp) {
    return new Emitter(function (tupledArg) {
      var tr = propAccess(trace).Emit([tupledArg[0], tupledArg[1]]);
      var mem = new Expression("MemberExpression", [tr, new Expression("IdentifierExpression", ["getValue", null]), false, null]);
      return parser(new Expression("CallExpression", [mem, ofArray([new Expression("StringLiteral", [endp, null])]), null]));
    });
  };

  var ident = __exports.ident = function (s) {
    return new Expression("IdentifierExpression", [s, null]);
  };

  var str = __exports.str = function (v) {
    return new Expression("StringLiteral", [v, null]);
  };

  var op_Dynamic = __exports.op_Dynamic = function (e, s) {
    return new Expression("MemberExpression", [e, new Expression("IdentifierExpression", [s, null]), false, null]);
  };

  var op_DivideAtDivide = __exports.op_DivideAtDivide = function (e, args) {
    return new Expression("CallExpression", [e, args, null]);
  };

  var func = __exports.func = function (v, f) {
    var body = new Statement("BlockStatement", [ofArray([new Statement("ReturnStatement", [f(ident(v)), null])]), null]);
    return new Expression("FunctionExpression", [null, ofArray([new Pattern("IdentifierPattern", [v, null])]), body, false, false, null]);
  };

  var getTypeAndEmitter = __exports.getTypeAndEmitter = function (lookupNamed, ty) {
    var $var148 = ty.Case === "Generic" ? ty.Fields[0] === "seq" ? ty.Fields[1].length === 1 ? ty.Fields[1][0].Case === "Generic" ? ty.Fields[1][0].Fields[0] === "tuple" ? function () {
      var testExpr = ty.Fields[1][0].Fields[1];
      return testExpr.length === 2;
    }() ? [2, ty.Fields[1][0].Fields[1][0], ty.Fields[1][0].Fields[1][1]] : [3, ty.Fields[1][0]] : [3, ty.Fields[1][0]] : [3, ty.Fields[1][0]] : [5] : [5] : ty.Case === "Record" ? [4, ty.Fields[0]] : ty.Fields[0] === "string" ? [0] : ty.Fields[0] === "int" ? [1] : ty.Fields[0] === "float" ? [1] : [5];

    var _ret3 = function () {
      switch ($var148[0]) {
        case 0:
          return {
            v: [new Type("Primitive", [new PrimitiveType("String", [])]), function (x) {
              return x;
            }]
          };

        case 1:
          return {
            v: [new Type("Primitive", [new PrimitiveType("Number", [])]), function (e) {
              return new Expression("CallExpression", [new Expression("IdentifierExpression", ["Number", null]), ofArray([e]), null]);
            }]
          };

        case 2:
          var patternInput = getTypeAndEmitter(lookupNamed, $var148[1]);
          var patternInput_1 = getTypeAndEmitter(lookupNamed, $var148[2]);
          var typ = lookupNamed("series")(ofArray([patternInput[0], patternInput_1[0]]));
          return {
            v: [typ, function (d) {
              return op_DivideAtDivide(op_Dynamic(ident("series"), "create"), ofArray([op_DivideAtDivide(ident("convertTupleSequence"), ofArray([func("v", patternInput[1]), func("v", patternInput_1[1]), d])), str("key"), str("value"), str("")]));
            }]
          };

        case 3:
          var patternInput_2 = getTypeAndEmitter(lookupNamed, $var148[1]);
          var serTy = lookupNamed("series")(ofArray([new Type("Primitive", [new PrimitiveType("Number", [])]), patternInput_2[0]]));
          return {
            v: [serTy, function (d_1) {
              return op_DivideAtDivide(op_Dynamic(ident("series"), "ordinal"), ofArray([op_DivideAtDivide(ident("convertSequence"), ofArray([func("v", patternInput_2[1]), d_1])), str("key"), str("value"), str("")]));
            }]
          };

        case 4:
          var membs = $var148[1].map(function (tupledArg) {
            var patternInput_3 = getTypeAndEmitter(lookupNamed, tupledArg[1]);
            var emitter = new Emitter(function (tupledArg_1) {
              return patternInput_3[1](op_Dynamic(tupledArg_1[0], tupledArg[0]));
            });
            return new Member("Property", [tupledArg[0], patternInput_3[0], ofArray([ProviderHelpers.docMeta(new Documentation("Text", [""]))]), emitter]);
          });
          var obj = new Type("Object", [new ObjectType(membs)]);
          return {
            v: [obj, function (x_1) {
              return x_1;
            }]
          };

        case 5:
          console.log("getTypeAndEmitter: Cannot handle %O", ty);
          throw new Error("getTypeAndEmitter: Cannot handle type");
      }
    }();

    if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
  };

  var mapParamType = __exports.mapParamType = function (_arg1) {
    switch (_arg1) {
      case "int":
      case "float":
        return new PrimitiveType("Number", []);

      default:
        throw new Error("mapParamType: Unsupported parameter type");
    }
  };

  var restTypeCache = __exports.restTypeCache = new _Map();

  var createRestType = __exports.createRestType = function (lookupNamed, root, cookies, url) {
    var guid = concatUrl(root, url) + cookies;
    var matchValue = tryGetValue(restTypeCache, guid, null);

    if (matchValue[0]) {
      return matchValue[1];
    } else {
      var future = function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(load(concatUrl(root, url), cookies), function (_arg1) {
            return builder_.Return(new Type("Object", [new ObjectType(_arg1.map(function (m) {
              var schema = m.schema != null ? ofArray([function () {
                var Type$$1 = m.schema["@type"];
                return new Metadata("http://schema.org", Type$$1, m.schema);
              }()]) : new List$2();
              var matchValue_1 = m.returns.kind;

              switch (matchValue_1) {
                case "nested":
                  var returns = m.returns;
                  var retTyp = createRestType(lookupNamed, root, cookies, returns.endpoint);

                  if (m.parameters == null) {
                    return new Member("Property", [m.name, retTyp, new List$2(ProviderHelpers.docMeta(parseDoc(m.documentation)), schema), propAccess(m.trace)]);
                  } else {
                    var args = toList(delay(function () {
                      return map$5(function (p) {
                        return [p.name, false, new Type("Primitive", [mapParamType(p.type)])];
                      }, m.parameters);
                    }));
                    var argNames = toList(delay(function () {
                      return map$5(function (p_1) {
                        return p_1.name;
                      }, m.parameters);
                    }));
                    return new Member("Method", [m.name, args, retTyp, ofArray([ProviderHelpers.docMeta(parseDoc(m.documentation))]), methCall(argNames, m.trace)]);
                  }

                case "primitive":
                  var returns_1 = m.returns;
                  var ty = fromRawType(returns_1.type);
                  var patternInput = getTypeAndEmitter(lookupNamed, ty);
                  return new Member("Property", [m.name, patternInput[0], new List$2(ProviderHelpers.docMeta(parseDoc(m.documentation)), schema), dataCall(patternInput[1], m.trace, returns_1.endpoint)]);

                default:
                  throw new Error("?");
              }
            }))]));
          });
        });
      }(singleton$2);

      var ty_1 = new Type("Delayed", [guid, function (arg00) {
        return function (arg10) {
          return Async_CreateNamedFuture_Static(arg00, arg10);
        };
      }(guid)(future)]);
      restTypeCache.set(guid, ty_1);
      return ty_1;
    }
  };

  var provideRestType = __exports.provideRestType = function (lookupNamed, name, root, cookies) {
    var ctx = ident("RuntimeContext");
    return new ProvidedType("GlobalValue", [name, new List$2(), new Expression("NewExpression", [ctx, ofArray([str(root), str(cookies), str("")]), null]), createRestType(lookupNamed, root, cookies, "/")]);
  };

  return __exports;
}({});

var SeriesInternals = function (__exports) {
  var slice = __exports.slice = function (lo, hi, arr) {
    return _Array$from(initialize$1(hi - lo + 1, function (i) {
      return arr[lo + i];
    }));
  };

  var dictAny = __exports.dictAny = function (v) {
    return new _Map(v);
  };

  var zipUnsorted = __exports.zipUnsorted = function (arr1, arr2) {
    var d1 = dictAny(arr1);
    var d2 = dictAny(arr2);
    var res = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(d1), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var kv1 = _step.value;
        var v2 = d2.has(kv1[0]) ? d2.get(kv1[0]) : null;
        res.push([kv1[0], [kv1[1], v2]]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(d2), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var kv2 = _step2.value;

        if (!d1.has(kv2[0])) {
          res.push([kv2[0], [null, kv2[1]]]);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return _Array$from(res);
  };

  var isSortedUsing = __exports.isSortedUsing = function (test, proj, arr) {
    var loop = function loop(i) {
      loop: while (true) {
        if (i === arr.length) {
          return true;
        } else if (test(proj(arr[i - 1]))(proj(arr[i]))) {
          i = i + 1;
          continue loop;
        } else {
          return false;
        }
      }
    };

    if (arr.length === 0) {
      return true;
    } else {
      return loop(1);
    }
  };

  var zipSorted = __exports.zipSorted = function (arr1, arr2) {
    var i1 = 0;
    var i2 = 0;
    var res = [];

    while (i1 < arr1.length ? i2 < arr2.length : false) {
      var patternInput = [arr1[i1], arr2[i2]];
      var v2 = patternInput[1][1];
      var v1 = patternInput[0][1];
      var k2 = patternInput[1][0];
      var k1 = patternInput[0][0];

      if (function (a) {
        return function (b) {
          return (a < b ? -1 : a == b ? 0 : 1) === 0;
        };
      }(k1)(k2)) {
        res.push([k1, [v1, v2]]);
        i1 = i1 + 1;
        i2 = i2 + 1;
      } else if (function (a_1) {
        return function (b_1) {
          return (a_1 < b_1 ? -1 : a_1 == b_1 ? 0 : 1) < 0;
        };
      }(k1)(k2)) {
        res.push([k1, [v1, null]]);
        i1 = i1 + 1;
      } else if (function (a_2) {
        return function (b_2) {
          return (a_2 < b_2 ? -1 : a_2 == b_2 ? 0 : 1) < 0;
        };
      }(k2)(k1)) {
        res.push([k2, [null, v2]]);
        i2 = i2 + 1;
      }
    }

    while (i1 < arr1.length) {
      var patternInput_1 = arr1[i1];
      res.push([patternInput_1[0], [patternInput_1[1], null]]);
      i1 = i1 + 1;
    }

    while (i2 < arr2.length) {
      var patternInput_2 = arr2[i2];
      res.push([patternInput_2[0], [null, patternInput_2[1]]]);
      i2 = i2 + 2;
    }

    return _Array$from(res);
  };

  var zipAny = __exports.zipAny = function (arr1, arr2) {
    var op_LessEqualsDot = function op_LessEqualsDot(a) {
      return function (b) {
        return (a < b ? -1 : a == b ? 0 : 1) <= 0;
      };
    };

    var op_GreaterEqualsDot = function op_GreaterEqualsDot(a_1) {
      return function (b_1) {
        return (a_1 < b_1 ? -1 : a_1 == b_1 ? 0 : 1) >= 0;
      };
    };

    if (isSortedUsing(op_LessEqualsDot, function (tuple) {
      return tuple[0];
    }, arr1) ? isSortedUsing(op_LessEqualsDot, function (tuple_1) {
      return tuple_1[0];
    }, arr2) : false) {
      return zipSorted(arr1, arr2);
    } else if (isSortedUsing(op_GreaterEqualsDot, function (tuple_2) {
      return tuple_2[0];
    }, arr1) ? isSortedUsing(op_GreaterEqualsDot, function (tuple_3) {
      return tuple_3[0];
    }, arr2) : false) {
      return zipSorted(arr1.slice().reverse(), arr2.slice().reverse()).slice().reverse();
    } else {
      return zipUnsorted(arr1, arr2);
    }
  };

  return __exports;
}({});
var helpers = function () {
  function helpers() {
    _classCallCheck(this, helpers);
  }

  _createClass(helpers, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Series.helpers",
        properties: {}
      };
    }
  }]);

  return helpers;
}();
setType("TheGamma.Series.helpers", helpers);

var series = function () {
  function series(data, keyName, valueName, seriesName) {
    _classCallCheck(this, series);

    this.data = data;
    this.keyName = keyName;
    this.valueName = valueName;
    this.seriesName = seriesName;
  }

  _createClass(series, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Series.series",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          data: Interface("TheGamma.Common.Future"),
          keyName: "string",
          valueName: "string",
          seriesName: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "set",
    value: function (data, keyName, valueName, seriesName) {
      return new series(data, keyName != null ? keyName : this.keyName, valueName != null ? valueName : this.valueName, seriesName != null ? seriesName : this.seriesName);
    }
  }, {
    key: "setProperties",
    value: function (keyName, valueName, seriesName) {
      var keyName_1 = keyName != null ? keyName : this.keyName;
      var valueName_1 = valueName != null ? valueName : this.valueName;
      var seriesName_1 = seriesName != null ? seriesName : this.seriesName;
      return new series(this.data, keyName_1, valueName_1, seriesName_1);
    }
  }, {
    key: "sortKeys",
    value: function (reverse$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var5 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var5.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var5.keyName, $var5.valueName, $var5.seriesName);
        };
      }(function (arr) {
        return (equals(reverse$$1, true) ? function (array) {
          return array.slice().reverse();
        } : function (x) {
          return x;
        })(_Array$from(sortWith(function (tupledArg, tupledArg_1) {
          return tupledArg[0] < tupledArg_1[0] ? -1 : tupledArg[0] == tupledArg_1[0] ? 0 : 1;
        }, arr)));
      })(this);
    }
  }, {
    key: "sortValues",
    value: function (reverse$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var6 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var6.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var6.keyName, $var6.valueName, $var6.seriesName);
        };
      }(function (arr) {
        return (equals(reverse$$1, true) ? function (array) {
          return array.slice().reverse();
        } : function (x) {
          return x;
        })(_Array$from(sortWith(function (tupledArg, tupledArg_1) {
          return tupledArg[1] < tupledArg_1[1] ? -1 : tupledArg[1] == tupledArg_1[1] ? 0 : 1;
        }, arr)));
      })(this);
    }
  }, {
    key: "sortBy",
    value: function (f, reverse$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var7 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var7.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var7.keyName, $var7.valueName, $var7.seriesName);
        };
      }(function (arr) {
        return (equals(reverse$$1, true) ? function (array) {
          return array.slice().reverse();
        } : function (x) {
          return x;
        })(_Array$from(sortWith(function (tupledArg, tupledArg_1) {
          return f(tupledArg[1]) < f(tupledArg_1[1]) ? -1 : f(tupledArg[1]) == f(tupledArg_1[1]) ? 0 : 1;
        }, arr)));
      })(this);
    }
  }, {
    key: "reverse",
    value: function () {
      return function (arg00) {
        return function (arg10) {
          var $var8 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var8.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var8.keyName, $var8.valueName, $var8.seriesName);
        };
      }(function (array) {
        return array.slice().reverse();
      })(this);
    }
  }, {
    key: "take",
    value: function (count$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var9 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var9.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var9.keyName, $var9.valueName, $var9.seriesName);
        };
      }(function (arr) {
        return SeriesInternals.slice(0, (arr.length < count$$1 ? arr.length : count$$1) - 1, arr);
      })(this);
    }
  }, {
    key: "skip",
    value: function (count$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var10 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var10.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var10.keyName, $var10.valueName, $var10.seriesName);
        };
      }(function (arr) {
        return SeriesInternals.slice(arr.length < count$$1 ? arr.length : count$$1, arr.length - 1, arr);
      })(this);
    }
  }, {
    key: "shuffle",
    value: function () {
      return function (arg00) {
        return function (arg10) {
          var $var11 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var11.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var11.keyName, $var11.valueName, $var11.seriesName);
        };
      }(function (arr) {
        var rnd = {};
        return _Array$from(sortWith(function (x, y) {
          return compare(function (_arg7) {
            return randomNext(0, 2147483647);
          }(x), function (_arg7) {
            return randomNext(0, 2147483647);
          }(y));
        }, arr));
      })(this);
    }
  }, {
    key: "map",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var12 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var12.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var12.keyName, $var12.valueName, $var12.seriesName);
        };
      }(function () {
        var mapping = function mapping(tupledArg) {
          return [tupledArg[0], f(tupledArg[1])];
        };

        return function (array) {
          return array.map(mapping);
        };
      }())(this);
    }
  }, {
    key: "mapKeys",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var13 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var13.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var13.keyName, $var13.valueName, $var13.seriesName);
        };
      }(function () {
        var mapping = function mapping(tupledArg) {
          return [f(tupledArg[0]), tupledArg[1]];
        };

        return function (array) {
          return array.map(mapping);
        };
      }())(this);
    }
  }, {
    key: "mapPairs",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var14 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var14.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var14.keyName, $var14.valueName, $var14.seriesName);
        };
      }(function () {
        var mapping = function mapping(tupledArg) {
          return [tupledArg[0], f(tupledArg[0])(tupledArg[1])];
        };

        return function (array) {
          return array.map(mapping);
        };
      }())(this);
    }
  }, {
    key: "filter",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var15 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var15.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var15.keyName, $var15.valueName, $var15.seriesName);
        };
      }(function () {
        var predicate = function predicate($var16) {
          return f(function (tuple) {
            return tuple[1];
          }($var16));
        };

        return function (array) {
          return array.filter(predicate);
        };
      }())(this);
    }
  }, {
    key: "choose",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var17 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var17.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var17.keyName, $var17.valueName, $var17.seriesName);
        };
      }(function () {
        var chooser = function chooser(tupledArg) {
          var matchValue = f(tupledArg[1]);

          if (matchValue != null) {
            return [tupledArg[0], matchValue];
          } else {
            return null;
          }
        };

        return function (array) {
          return _Array$from(choose$1(chooser, array));
        };
      }())(this);
    }
  }, {
    key: "joinOuter",
    value: function (s2) {
      var _this = this;

      var data = function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(_this.data), function (_arg4) {
            return builder_.Bind(Async_AwaitFuture_Static(s2.data), function (_arg5) {
              return builder_.Return(SeriesInternals.zipAny(_arg4, _arg5));
            });
          });
        });
      }(singleton$2);

      return series.create(data, this.keyName, "Values", this.seriesName + " and " + s2.seriesName);
    }
  }, {
    key: "joinInner",
    value: function (s2) {
      return this.joinOuter(s2).choose(function (_arg6) {
        var $var18 = _arg6[0] != null ? _arg6[1] != null ? [0, _arg6[0], _arg6[1]] : [1] : [1];

        switch ($var18[0]) {
          case 0:
            return [$var18[1], $var18[2]];

          case 1:
            return null;
        }
      });
    }
  }, {
    key: "appendScalar",
    value: function (key, _value) {
      return function (arg00) {
        return function (arg10) {
          var $var19 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var19.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var19.keyName, $var19.valueName, $var19.seriesName);
        };
      }(function (arr) {
        return arr.concat([[key, _value]]);
      })(this);
    }
  }, {
    key: "append",
    value: function (s2) {
      var _this2 = this;

      return this.set(Async_StartAsFuture_Static(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(_this2.data), function (_arg7) {
            return builder_.Bind(Async_AwaitFuture_Static(s2.data), function (_arg8) {
              return builder_.Return(_arg7.concat(_arg8));
            });
          });
        });
      }(singleton$2)));
    }
  }, {
    key: "realign",
    value: function (newKeys, defaultValue) {
      return function (arg00) {
        return function (arg10) {
          var $var20 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var20.data), function (_arg2) {
                return builder_.ReturnFrom(arg00(_arg2));
              });
            });
          }(singleton$2));
          return new series(nd, $var20.keyName, $var20.valueName, $var20.seriesName);
        };
      }(function (arr) {
        return function (builder__1) {
          return builder__1.Delay(function () {
            return builder__1.Bind(Async_AwaitFuture_Static(newKeys.data), function (_arg9) {
              var newKeys_1 = _arg9.map(function (tupledArg) {
                return tupledArg[1];
              });

              var lookup = create$3(arr, new GenericComparer(compare));
              return builder__1.Return(newKeys_1.map(function (k) {
                var matchValue = tryFind$1(k, lookup);

                if (matchValue == null) {
                  return [k, defaultValue];
                } else {
                  return [k, matchValue];
                }
              }));
            });
          });
        }(singleton$2);
      })(this);
    }
  }, {
    key: "preview",
    value: function () {
      return this.take(10);
    }
  }], [{
    key: "create",
    value: function (data, keyName, valueName, seriesName) {
      return new series(Async_StartAsFuture_Static(data), keyName, valueName, seriesName);
    }
  }, {
    key: "values",
    value: function (_values) {
      var data = Async_StartAsFuture_Static(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Return(_Array$from(mapIndexed$1(function (i, v) {
            return [i, v];
          }, _values)));
        });
      }(singleton$2));
      return new series(data, "key", "value", "");
    }
  }, {
    key: "range",
    value: function (from, to) {
      return series.values(Int32Array.from(range(from, to)));
    }
  }, {
    key: "rangeBy",
    value: function (from, to, step) {
      return series.values(Int32Array.from(rangeStep(from, step, to)));
    }
  }, {
    key: "ordinal",
    value: function (data, keyName, valueName, seriesName) {
      var data_1 = Async_StartAsFuture_Static(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(data, function (_arg3) {
            return builder_.Return(_Array$from(mapIndexed$1(function (i, v) {
              return [i, v];
            }, _arg3)));
          });
        });
      }(singleton$2));
      return new series(data_1, keyName, valueName, seriesName);
    }
  }]);

  return series;
}();

setType("TheGamma.Series.series", series);

function convertTupleSequence(f, g, data) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(data, function (_arg1) {
        return builder_.Return(_arg1.map(function (tupledArg) {
          return [f(tupledArg[0]), g(tupledArg[1])];
        }));
      });
    });
  }(singleton$2);
}

function trimLeft(c, s) {
  return _Array$from(skipWhile(function (y) {
    return c === y;
  }, s.split(""))).join('');
}
function trimRight(c, s) {
  return _Array$from(skipWhile(function (y) {
    return c === y;
  }, s.split("").slice().reverse())).slice().reverse().join('');
}
function concatUrl(a, b) {
  return trimRight("/", a) + "/" + trimLeft("/", b);
}
var RuntimeContext = function () {
  _createClass(RuntimeContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProvidersRuntime.RuntimeContext",
        properties: {
          root: "string",
          trace: "string"
        }
      };
    }
  }]);

  function RuntimeContext(root, cookies, trace) {
    _classCallCheck(this, RuntimeContext);

    this["root@19"] = root;
    this.cookies = cookies;
    this["trace@19"] = trace;
  }

  _createClass(RuntimeContext, [{
    key: "addTrace",
    value: function (suffix) {
      var _this = this;

      var traces = toList(delay(function () {
        return append$1(!isNullOrEmpty(_this["trace@19"]) ? singleton$1(_this["trace@19"]) : empty(), delay(function () {
          return !isNullOrEmpty(suffix) ? singleton$1(suffix) : empty();
        }));
      }));
      return new RuntimeContext(this["root@19"], this.cookies, join("&", traces));
    }
  }, {
    key: "getValue",
    value: function (endpoint) {
      var _this2 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Http.Request("POST", concatUrl(_this2["root@19"], endpoint), _this2["trace@19"], _this2.cookies), function (_arg1) {
            return builder_.Return(JSON.parse(_arg1));
          });
        });
      }(singleton$2);
    }
  }, {
    key: "root",
    get: function () {
      return this["root@19"];
    }
  }, {
    key: "trace",
    get: function () {
      return this["trace@19"];
    }
  }]);

  return RuntimeContext;
}();
setType("TheGamma.TypeProvidersRuntime.RuntimeContext", RuntimeContext);
var PivotContext = function () {
  _createClass(PivotContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProvidersRuntime.PivotContext",
        properties: {}
      };
    }
  }]);

  function PivotContext(root, calls) {
    _classCallCheck(this, PivotContext);

    this.root = root;
    this.calls = calls;
  }

  _createClass(PivotContext, [{
    key: "addCall",
    value: function (callid, values) {
      return new PivotContext(this.root, [[callid, values]].concat(this.calls));
    }
  }, {
    key: "getData",
    value: function (tfs, isPreview) {
      var _this3 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          var url = function () {
            var folder = function folder(tfs_1) {
              return function (tupledArg) {
                if (tupledArg[1].length !== 1) {
                  throw new Error("PivotContext.getData: Expected one argument");
                }

                return replace$$1(tfs_1, tupledArg[0], toString$2(tupledArg[1][0]));
              };
            };

            return function (array) {
              return fold$1(function ($var120, $var121) {
                return folder($var120)($var121);
              }, tfs, array);
            };
          }()(_this3.calls);

          var url_1 = _this3.root + "?" + url + (isPreview ? "&preview" : "");
          Log.trace("runtime", "Pivot: %s", url_1);
          return builder_.Bind(Http.Request("GET", url_1), function (_arg1) {
            return builder_.Return(JSON.parse(_arg1));
          });
        });
      }(singleton$2);
    }
  }]);

  return PivotContext;
}();
setType("TheGamma.TypeProvidersRuntime.PivotContext", PivotContext);

var ChartData = function () {
  function ChartData(data) {
    _classCallCheck(this, ChartData);

    this.data = data;
  }

  _createClass(ChartData, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.ChartData",
        interfaces: ["FSharpRecord"],
        properties: {
          data: Async$1
        }
      };
    }
  }]);

  return ChartData;
}();
setType("TheGamma.GoogleCharts.ChartData", ChartData);
var LazyCharting = function (__exports) {
  var chartsToDraw = __exports.chartsToDraw = [];
  var googleLoaded = (Object.defineProperty(__exports, 'googleLoaded', {
    get: function get() {
      return googleLoaded;
    },
    set: function set(x) {
      return googleLoaded = x;
    }
  }), false);

  var drawChartOnLoad = __exports.drawChartOnLoad = function (f) {
    if (googleLoaded) {
      f(null);
    } else {
      chartsToDraw.push(f);
    }
  };

  if (typeof google != "undefined") google.load('visualization', '1', {
    'packages': ['corechart'],
    'callback': function () {
      (function () {
        googleLoaded = true;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _getIterator(chartsToDraw), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var f = _step.value;
            f(null);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      })();
    }
  });
  return __exports;
}({});
var Helpers = function (__exports) {
  var copy = __exports.copy = function (o, prop) {
    if (o == null) {
      return undefined;
    } else {
      return o[prop];
    }
  };

  var orDefault = __exports.orDefault = function (newValue) {
    if (newValue != null) {
      return newValue;
    } else {
      return undefined;
    }
  };

  var right = __exports.right = function (o, prop, newValue) {
    if (newValue != null) {
      return newValue;
    } else if (o == null) {
      return undefined;
    } else {
      return o[prop];
    }
  };

  var showChart = __exports.showChart = function (chart, outputId) {
    LazyCharting.drawChartOnLoad(function () {
      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            return builder_.Bind(chart["data"].data, function (_arg1) {
              var ctor = eval("(function(a) { return new google.visualization." + chart.typeName + " (a); })");
              var ch = ctor(document.getElementById(outputId));
              if (chart.options.height == undefined) chart.options.height = 400;
              ch.draw(_arg1, chart.options);
              return builder_.Zero();
            });
          }), function (_arg2) {
            Log.error("google", "Error when getting data or rendering chart: %O", _arg2);
            return builder_.Zero();
          });
        });
      }(singleton$2));
    });
  };

  return __exports;
}({});
var ChartDataOperations = function (__exports) {
  var collect$$1 = __exports.collect = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$2()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(collect$$1(f, l.tail), function (_arg2) {
            return builder_.Return(append$$1(_arg1, _arg2));
          });
        });
      });
    }(singleton$2);
  };

  var oneKeyValue = __exports.oneKeyValue = function (keyType, v) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn(keyType, v.keyName);
        data.addColumn("number", v.seriesName);
        return builder_.Bind(Async_AwaitFuture_Static(v.mapPairs(function (k) {
          return function (v_1) {
            return [k, v_1];
          };
        }).data), function (_arg1) {
          (function (arg00) {
            data.addRows(arg00);
          })(_arg1.map(function (tuple) {
            return tuple[1];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  var oneKeyTwoValues = __exports.oneKeyTwoValues = function (keyType, v) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn(keyType, v.keyName);
        data.addColumn("number", v.seriesName);
        data.addColumn("number", v.seriesName);
        return builder_.Bind(Async_AwaitFuture_Static(v.mapPairs(function (k) {
          return function (tupledArg) {
            return [k, tupledArg[0], tupledArg[1]];
          };
        }).data), function (_arg1) {
          (function (arg00) {
            data.addRows(arg00);
          })(_arg1.map(function (tuple) {
            return tuple[1];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  var oneKeyAppendValues = __exports.oneKeyAppendValues = function (keyType, vs, colors) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn(keyType, vs[0].keyName);
        data.addColumn("number", vs[0].valueName);
        data.addColumn({
          type: "string",
          role: "style"
        });
        return builder_.Bind(collect$$1(function (tupledArg) {
          return function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Bind(Async_AwaitFuture_Static(tupledArg[0].mapPairs(function (k) {
                return function (v) {
                  return [k, v, tupledArg[1]];
                };
              }).data), function (_arg1) {
                return builder__1.Return(ofArray(_arg1.map(function (tuple) {
                  return tuple[1];
                })));
              });
            });
          }(singleton$2);
        }, ofArray(_Array$from(zip(vs, colors)))), function (_arg2) {
          (function (arg00) {
            data.addRows(arg00);
          })(_Array$from(toList(sortWith(function (x, y) {
            return -compare(function (tupledArg_2) {
              return tupledArg_2[1];
            }(x), function (tupledArg_2) {
              return tupledArg_2[1];
            }(y));
          }, _arg2))).map(function (tupledArg_1) {
            return [tupledArg_1[0], tupledArg_1[1], tupledArg_1[2]];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  var oneKeyNValues = __exports.oneKeyNValues = function (keyType, v) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        return builder_.Bind(Async_AwaitFuture_Static(v.data), function (_arg1) {
          var v_1 = _arg1.map(function (tuple) {
            return tuple[1];
          });

          data.addColumn(keyType, v_1[0].keyName);
          return builder_.Combine(builder_.For(range(0, v_1.length - 1), function (_arg2) {
            data.addColumn("number", v_1[_arg2].seriesName);
            return builder_.Zero();
          }), builder_.Delay(function () {
            var head$$1 = v_1[0].map(function (v_2) {
              return create$3(ofArray([[0, v_2]]), new GenericComparer(compare));
            });

            var tail$$1 = _Array$from(mapIndexed$1(function (i, v_3) {
              return [i + 1, v_3];
            }, SeriesInternals.slice(1, v_1.length - 1, v_1)));

            var all = fold$1(function (s1, tupledArg) {
              return s1.joinOuter(tupledArg[1]).map(function (tupledArg_1) {
                var matchValue = [defaultArg(tupledArg_1[0], create$3(null, new GenericComparer(compare))), tupledArg_1[1]];

                if (matchValue[1] == null) {
                  return matchValue[0];
                } else {
                  var r = matchValue[1];
                  return add$1(tupledArg[0], r, matchValue[0]);
                }
              });
            }, head$$1, tail$$1);
            return builder_.Bind(Async_AwaitFuture_Static(all.mapPairs(function (k) {
              return function (vals) {
                var data_1 = _Array$from(initialize$1(v_1.length, function (i_1) {
                  return defaultArg(tryFind$1(i_1, vals), undefined);
                }));

                return _Array$from(append$1([k], data_1));
              };
            }).data), function (_arg3) {
              (function (arg00) {
                data.addRows(arg00);
              })(_arg3.map(function (tuple_1) {
                return tuple_1[1];
              }));

              return builder_.Return(data);
            });
          }));
        });
      });
    }(singleton$2));
  };

  var twoValues = __exports.twoValues = function (v1, v2) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn("number", v1.seriesName);
        data.addColumn("number", v2.seriesName);
        return builder_.Bind(Async_AwaitFuture_Static(v1.joinInner(v2).map(function (tupledArg) {
          return [tupledArg[0], tupledArg[1]];
        }).data), function (_arg1) {
          (function (arg00) {
            data.addRows(arg00);
          })(_arg1.map(function (tuple) {
            return tuple[1];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  return __exports;
}({});

var ChartSizeAxis = function () {
    function ChartSizeAxis(maxSize, maxValue, minSize, minValue) {
        _classCallCheck(this, ChartSizeAxis);

        this.maxSize = maxSize;
        this.maxValue = maxValue;
        this.minSize = minSize;
        this.minValue = minValue;
    }

    _createClass(ChartSizeAxis, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartSizeAxis",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    maxSize: "number",
                    maxValue: "number",
                    minSize: "number",
                    minValue: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartSizeAxis;
}();
setType("TheGamma.GoogleCharts.Options.ChartSizeAxis", ChartSizeAxis);
var ChartTextStyle = function () {
    function ChartTextStyle(fontName, fontSize, bold, italic, color, auraColor, opacity) {
        _classCallCheck(this, ChartTextStyle);

        this.fontName = fontName;
        this.fontSize = fontSize;
        this.bold = bold;
        this.italic = italic;
        this.color = color;
        this.auraColor = auraColor;
        this.opacity = opacity;
    }

    _createClass(ChartTextStyle, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartTextStyle",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    fontName: "string",
                    fontSize: "number",
                    bold: "boolean",
                    italic: "boolean",
                    color: "string",
                    auraColor: "string",
                    opacity: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartTextStyle;
}();
setType("TheGamma.GoogleCharts.Options.ChartTextStyle", ChartTextStyle);
var ChartTooltip = function () {
    function ChartTooltip(isHtml, showColorCode, textStyle, trigger) {
        _classCallCheck(this, ChartTooltip);

        this.isHtml = isHtml;
        this.showColorCode = showColorCode;
        this.textStyle = textStyle;
        this.trigger = trigger;
    }

    _createClass(ChartTooltip, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartTooltip",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    isHtml: "boolean",
                    showColorCode: "boolean",
                    textStyle: ChartTextStyle,
                    trigger: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartTooltip;
}();
setType("TheGamma.GoogleCharts.Options.ChartTooltip", ChartTooltip);
var ChartLegend = function () {
    function ChartLegend(alignment, maxLines, position, textStyle, numberFormat) {
        _classCallCheck(this, ChartLegend);

        this.alignment = alignment;
        this.maxLines = maxLines;
        this.position = position;
        this.textStyle = textStyle;
        this.numberFormat = numberFormat;
    }

    _createClass(ChartLegend, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartLegend",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    alignment: "string",
                    maxLines: "number",
                    position: "string",
                    textStyle: ChartTextStyle,
                    numberFormat: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartLegend;
}();
setType("TheGamma.GoogleCharts.Options.ChartLegend", ChartLegend);
var ChartColorAxis = function () {
    function ChartColorAxis(minValue, maxValue, values, colors, legend) {
        _classCallCheck(this, ChartColorAxis);

        this.minValue = minValue;
        this.maxValue = maxValue;
        this.values = values;
        this.colors = colors;
        this.legend = legend;
    }

    _createClass(ChartColorAxis, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartColorAxis",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    minValue: "number",
                    maxValue: "number",
                    values: FableArray(Float64Array, true),
                    colors: FableArray("string"),
                    legend: ChartLegend
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartColorAxis;
}();
setType("TheGamma.GoogleCharts.Options.ChartColorAxis", ChartColorAxis);
var GeoChartMagnifyingGlass = function () {
    function GeoChartMagnifyingGlass(enable, zoomFactor) {
        _classCallCheck(this, GeoChartMagnifyingGlass);

        this.enable = enable;
        this.zoomFactor = zoomFactor;
    }

    _createClass(GeoChartMagnifyingGlass, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.GeoChartMagnifyingGlass",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    enable: "boolean",
                    zoomFactor: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return GeoChartMagnifyingGlass;
}();
setType("TheGamma.GoogleCharts.Options.GeoChartMagnifyingGlass", GeoChartMagnifyingGlass);
var GeoChartOptions = function () {
    function GeoChartOptions(backgroundColor, colorAxis, datalessRegionColor, displayMode, enableRegionInteractivity, height, keepAspectRatio, legend, region, magnifyingGlass, markerOpacity, resolution, sizeAxis, tooltip, width) {
        _classCallCheck(this, GeoChartOptions);

        this.backgroundColor = backgroundColor;
        this.colorAxis = colorAxis;
        this.datalessRegionColor = datalessRegionColor;
        this.displayMode = displayMode;
        this.enableRegionInteractivity = enableRegionInteractivity;
        this.height = height;
        this.keepAspectRatio = keepAspectRatio;
        this.legend = legend;
        this.region = region;
        this.magnifyingGlass = magnifyingGlass;
        this.markerOpacity = markerOpacity;
        this.resolution = resolution;
        this.sizeAxis = sizeAxis;
        this.tooltip = tooltip;
        this.width = width;
    }

    _createClass(GeoChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.GeoChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    backgroundColor: Any,
                    colorAxis: ChartColorAxis,
                    datalessRegionColor: "string",
                    displayMode: "string",
                    enableRegionInteractivity: "boolean",
                    height: "number",
                    keepAspectRatio: "boolean",
                    legend: ChartLegend,
                    region: "string",
                    magnifyingGlass: GeoChartMagnifyingGlass,
                    markerOpacity: "number",
                    resolution: "string",
                    sizeAxis: ChartSizeAxis,
                    tooltip: ChartTooltip,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return GeoChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.GeoChartOptions", GeoChartOptions);
var ChartBoxStyleGradient = function () {
    function ChartBoxStyleGradient(color1, color2, x1, y1, x2, y2, useObjectBoundingBoxUnits) {
        _classCallCheck(this, ChartBoxStyleGradient);

        this.color1 = color1;
        this.color2 = color2;
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.useObjectBoundingBoxUnits = useObjectBoundingBoxUnits;
    }

    _createClass(ChartBoxStyleGradient, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBoxStyleGradient",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color1: "string",
                    color2: "string",
                    x1: "string",
                    y1: "string",
                    x2: "string",
                    y2: "string",
                    useObjectBoundingBoxUnits: "boolean"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBoxStyleGradient;
}();
setType("TheGamma.GoogleCharts.Options.ChartBoxStyleGradient", ChartBoxStyleGradient);
var ChartBoxStyle = function () {
    function ChartBoxStyle(stroke, strokeWidth, rx, ry, gradient) {
        _classCallCheck(this, ChartBoxStyle);

        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
        this.rx = rx;
        this.ry = ry;
        this.gradient = gradient;
    }

    _createClass(ChartBoxStyle, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBoxStyle",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    stroke: "string",
                    strokeWidth: "number",
                    rx: "number",
                    ry: "number",
                    gradient: ChartBoxStyleGradient
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBoxStyle;
}();
setType("TheGamma.GoogleCharts.Options.ChartBoxStyle", ChartBoxStyle);
var ChartAnnotations = function () {
    function ChartAnnotations(boxStyle, textStyle) {
        _classCallCheck(this, ChartAnnotations);

        this.boxStyle = boxStyle;
        this.textStyle = textStyle;
    }

    _createClass(ChartAnnotations, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartAnnotations",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    boxStyle: ChartBoxStyle,
                    textStyle: ChartTextStyle
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartAnnotations;
}();
setType("TheGamma.GoogleCharts.Options.ChartAnnotations", ChartAnnotations);
var ChartCrosshairFocused = function () {
    function ChartCrosshairFocused(color, opacity) {
        _classCallCheck(this, ChartCrosshairFocused);

        this.color = color;
        this.opacity = opacity;
    }

    _createClass(ChartCrosshairFocused, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartCrosshairFocused",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    opacity: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartCrosshairFocused;
}();
setType("TheGamma.GoogleCharts.Options.ChartCrosshairFocused", ChartCrosshairFocused);
var ChartCrosshairSelected = function () {
    function ChartCrosshairSelected(color, opacity) {
        _classCallCheck(this, ChartCrosshairSelected);

        this.color = color;
        this.opacity = opacity;
    }

    _createClass(ChartCrosshairSelected, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartCrosshairSelected",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    opacity: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartCrosshairSelected;
}();
setType("TheGamma.GoogleCharts.Options.ChartCrosshairSelected", ChartCrosshairSelected);
var ChartCrosshair = function () {
    function ChartCrosshair(color, focused, opacity, orientation, selected, trigger) {
        _classCallCheck(this, ChartCrosshair);

        this.color = color;
        this.focused = focused;
        this.opacity = opacity;
        this.orientation = orientation;
        this.selected = selected;
        this.trigger = trigger;
    }

    _createClass(ChartCrosshair, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartCrosshair",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    focused: ChartCrosshairFocused,
                    opacity: "number",
                    orientation: "string",
                    selected: ChartCrosshairSelected,
                    trigger: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartCrosshair;
}();
setType("TheGamma.GoogleCharts.Options.ChartCrosshair", ChartCrosshair);
var ChartExplorer = function () {
    function ChartExplorer(actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
        _classCallCheck(this, ChartExplorer);

        this.actions = actions;
        this.axis = axis;
        this.keepInBounds = keepInBounds;
        this.maxZoomIn = maxZoomIn;
        this.maxZoomOut = maxZoomOut;
        this.zoomDelta = zoomDelta;
    }

    _createClass(ChartExplorer, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartExplorer",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    actions: FableArray("string"),
                    axis: "string",
                    keepInBounds: "boolean",
                    maxZoomIn: "number",
                    maxZoomOut: "number",
                    zoomDelta: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartExplorer;
}();
setType("TheGamma.GoogleCharts.Options.ChartExplorer", ChartExplorer);
var ChartStroke = function () {
    function ChartStroke(stroke, strokeWidth, fill) {
        _classCallCheck(this, ChartStroke);

        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
        this.fill = fill;
    }

    _createClass(ChartStroke, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartStroke",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    stroke: "string",
                    strokeWidth: "number",
                    fill: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartStroke;
}();
setType("TheGamma.GoogleCharts.Options.ChartStroke", ChartStroke);
var ChartArea = function () {
    function ChartArea(top, left, width, height) {
        _classCallCheck(this, ChartArea);

        this.top = top;
        this.left = left;
        this.width = width;
        this.height = height;
    }

    _createClass(ChartArea, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartArea",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    top: Any,
                    left: Any,
                    width: Any,
                    height: Any
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ChartArea;
}();
setType("TheGamma.GoogleCharts.Options.ChartArea", ChartArea);
var TransitionAnimation = function () {
    function TransitionAnimation(duration, easing) {
        _classCallCheck(this, TransitionAnimation);

        this.duration = duration;
        this.easing = easing;
    }

    _createClass(TransitionAnimation, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TransitionAnimation",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    duration: "number",
                    easing: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TransitionAnimation;
}();
setType("TheGamma.GoogleCharts.Options.TransitionAnimation", TransitionAnimation);
var ChartGridlines = function () {
    function ChartGridlines(color, count) {
        _classCallCheck(this, ChartGridlines);

        this.color = color;
        this.count = count;
    }

    _createClass(ChartGridlines, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartGridlines",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    count: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartGridlines;
}();
setType("TheGamma.GoogleCharts.Options.ChartGridlines", ChartGridlines);
var ChartViewWindow = function () {
    function ChartViewWindow(max, min) {
        _classCallCheck(this, ChartViewWindow);

        this.max = max;
        this.min = min;
    }

    _createClass(ChartViewWindow, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartViewWindow",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    max: "number",
                    min: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartViewWindow;
}();
setType("TheGamma.GoogleCharts.Options.ChartViewWindow", ChartViewWindow);
var ChartAxis = function () {
    function ChartAxis(baseline, baselineColor, direction, format, gridlines, minorGridlines, logScale, textPosition, textStyle, ticks, title, titleTextStyle, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode, viewWindow) {
        _classCallCheck(this, ChartAxis);

        this.baseline = baseline;
        this.baselineColor = baselineColor;
        this.direction = direction;
        this.format = format;
        this.gridlines = gridlines;
        this.minorGridlines = minorGridlines;
        this.logScale = logScale;
        this.textPosition = textPosition;
        this.textStyle = textStyle;
        this.ticks = ticks;
        this.title = title;
        this.titleTextStyle = titleTextStyle;
        this.allowContainerBoundaryTextCufoff = allowContainerBoundaryTextCufoff;
        this.slantedText = slantedText;
        this.slantedTextAngle = slantedTextAngle;
        this.maxAlternation = maxAlternation;
        this.maxTextLines = maxTextLines;
        this.minTextSpacing = minTextSpacing;
        this.showTextEvery = showTextEvery;
        this.maxValue = maxValue;
        this.minValue = minValue;
        this.viewWindowMode = viewWindowMode;
        this.viewWindow = viewWindow;
    }

    _createClass(ChartAxis, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartAxis",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    baseline: "number",
                    baselineColor: "string",
                    direction: "number",
                    format: "string",
                    gridlines: ChartGridlines,
                    minorGridlines: ChartGridlines,
                    logScale: "boolean",
                    textPosition: "string",
                    textStyle: ChartTextStyle,
                    ticks: FableArray(Any),
                    title: "string",
                    titleTextStyle: ChartTextStyle,
                    allowContainerBoundaryTextCufoff: "boolean",
                    slantedText: "boolean",
                    slantedTextAngle: "number",
                    maxAlternation: "number",
                    maxTextLines: "number",
                    minTextSpacing: "number",
                    showTextEvery: "number",
                    maxValue: "number",
                    minValue: "number",
                    viewWindowMode: "string",
                    viewWindow: ChartViewWindow
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ChartAxis;
}();
setType("TheGamma.GoogleCharts.Options.ChartAxis", ChartAxis);
var ChartBoundingBox = function () {
    function ChartBoundingBox(left, top, width, height) {
        _classCallCheck(this, ChartBoundingBox);

        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
    }

    _createClass(ChartBoundingBox, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBoundingBox",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    left: "number",
                    top: "number",
                    width: "number",
                    height: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBoundingBox;
}();
setType("TheGamma.GoogleCharts.Options.ChartBoundingBox", ChartBoundingBox);
var GroupWidth = function () {
    function GroupWidth(groupWidth) {
        _classCallCheck(this, GroupWidth);

        this.groupWidth = groupWidth;
    }

    _createClass(GroupWidth, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.GroupWidth",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    groupWidth: Any
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return GroupWidth;
}();
setType("TheGamma.GoogleCharts.Options.GroupWidth", GroupWidth);
var Trendline = function () {
    function Trendline(color, lineWidth, labelInLegend, opacity, pointSize, pointsVisible, showR2, type, visibleInLegend) {
        _classCallCheck(this, Trendline);

        this.color = color;
        this.lineWidth = lineWidth;
        this.labelInLegend = labelInLegend;
        this.opacity = opacity;
        this.pointSize = pointSize;
        this.pointsVisible = pointsVisible;
        this.showR2 = showR2;
        this.type = type;
        this.visibleInLegend = visibleInLegend;
    }

    _createClass(Trendline, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.Trendline",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    lineWidth: "number",
                    labelInLegend: "string",
                    opacity: "number",
                    pointSize: "number",
                    pointsVisible: "boolean",
                    showR2: "boolean",
                    type: "string",
                    visibleInLegend: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return Trendline;
}();
setType("TheGamma.GoogleCharts.Options.Trendline", Trendline);
var ScatterChartOptions = function () {
    function ScatterChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, chartArea, colors, crosshair, curveType, dataOpacity, enableInteractivity, explorer, fontSize, fontName, forceIFrame, hAxis, height, legend, lineWidth, pointSize, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, trendlines, vAxis, width) {
        _classCallCheck(this, ScatterChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.crosshair = crosshair;
        this.curveType = curveType;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.forceIFrame = forceIFrame;
        this.hAxis = hAxis;
        this.height = height;
        this.legend = legend;
        this.lineWidth = lineWidth;
        this.pointSize = pointSize;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.trendlines = trendlines;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(ScatterChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ScatterChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    crosshair: ChartCrosshair,
                    curveType: "string",
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    fontSize: "number",
                    fontName: "string",
                    forceIFrame: "boolean",
                    hAxis: ChartAxis,
                    height: "number",
                    legend: ChartLegend,
                    lineWidth: "number",
                    pointSize: "number",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    trendlines: FableArray(Trendline),
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ScatterChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.ScatterChartOptions", ScatterChartOptions);
var ColumnChartOptions = function () {
    function ColumnChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, bar, chartArea, colors, enableInteractivity, focusTarget, fontSize, fontName, hAxis, height, isStacked, legend, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, ColumnChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.chartArea = chartArea;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.isStacked = isStacked;
        this.legend = legend;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(ColumnChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ColumnChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ColumnChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.ColumnChartOptions", ColumnChartOptions);
var LineChartOptions = function () {
    function LineChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, chartArea, colors, crosshair, curveType, dataOpacity, enableInteractivity, explorer, focusTarget, fontSize, fontName, hAxis, height, interpolateNulls, legend, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, LineChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.crosshair = crosshair;
        this.curveType = curveType;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.legend = legend;
        this.lineWidth = lineWidth;
        this.orientation = orientation;
        this.pointSize = pointSize;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(LineChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.LineChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    crosshair: ChartCrosshair,
                    curveType: "string",
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    interpolateNulls: "boolean",
                    legend: ChartLegend,
                    lineWidth: "number",
                    orientation: "string",
                    pointSize: "number",
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return LineChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.LineChartOptions", LineChartOptions);
var BarChartOptions = function () {
    function BarChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, bar, chartArea, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, hAxes, hAxis, height, isStacked, legend, reverseCategories, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, BarChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.chartArea = chartArea;
        this.colors = colors;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxes = hAxes;
        this.hAxis = hAxis;
        this.height = height;
        this.isStacked = isStacked;
        this.legend = legend;
        this.reverseCategories = reverseCategories;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(BarChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.BarChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxes: Any,
                    hAxis: ChartAxis,
                    height: "number",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    reverseCategories: "boolean",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return BarChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.BarChartOptions", BarChartOptions);
var HistogramHistogram = function () {
    function HistogramHistogram(bucketSize, hideBucketItems, lastBucketPercentile) {
        _classCallCheck(this, HistogramHistogram);

        this.bucketSize = bucketSize;
        this.hideBucketItems = hideBucketItems;
        this.lastBucketPercentile = lastBucketPercentile;
    }

    _createClass(HistogramHistogram, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.HistogramHistogram",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    bucketSize: "number",
                    hideBucketItems: "boolean",
                    lastBucketPercentile: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return HistogramHistogram;
}();
setType("TheGamma.GoogleCharts.Options.HistogramHistogram", HistogramHistogram);
var HistogramOptions = function () {
    function HistogramOptions(animation, axisTitlesPosition, backgroundColor, bar, chartArea, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, hAxis, histogram, height, interpolateNulls, isStacked, legend, orientation, reverseCategories, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, HistogramOptions);

        this.animation = animation;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.chartArea = chartArea;
        this.colors = colors;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.histogram = histogram;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.isStacked = isStacked;
        this.legend = legend;
        this.orientation = orientation;
        this.reverseCategories = reverseCategories;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(HistogramOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.HistogramOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    animation: TransitionAnimation,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    histogram: HistogramHistogram,
                    height: "number",
                    interpolateNulls: "boolean",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    orientation: "string",
                    reverseCategories: "boolean",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return HistogramOptions;
}();
setType("TheGamma.GoogleCharts.Options.HistogramOptions", HistogramOptions);
var AreaChartOptions = function () {
    function AreaChartOptions(aggregationTarget, animation, areaOpacity, axisTitlesPosition, backgroundColor, chartArea, colors, crosshair, dataOpacity, enableInteractivity, explorer, focusTarget, fontSize, fontName, hAxis, height, interpolateNulls, isStacked, legend, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, AreaChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.areaOpacity = areaOpacity;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.crosshair = crosshair;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.isStacked = isStacked;
        this.legend = legend;
        this.lineWidth = lineWidth;
        this.orientation = orientation;
        this.pointSize = pointSize;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(AreaChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.AreaChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    areaOpacity: "number",
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    crosshair: ChartCrosshair,
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    interpolateNulls: "boolean",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    lineWidth: "number",
                    orientation: "string",
                    pointSize: "number",
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return AreaChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.AreaChartOptions", AreaChartOptions);
var AnnotationChartOptions = function () {
    function AnnotationChartOptions(allowHtml, allValuesSuffix, annotationsWidth, colors, dateFormat, displayAnnotations, displayAnnotationsFilter, displayDateTimeBarSeparator, displayExactValues, displayLegendDots, displayLegendValues, displayRangeSelector, displayZoomButtons, fill, legendPosition, max, min, numberFormats, scaleColumns, scaleFormat, scaleType, thickness, zoomEndTime, zoomStartTime) {
        _classCallCheck(this, AnnotationChartOptions);

        this.allowHtml = allowHtml;
        this.allValuesSuffix = allValuesSuffix;
        this.annotationsWidth = annotationsWidth;
        this.colors = colors;
        this.dateFormat = dateFormat;
        this.displayAnnotations = displayAnnotations;
        this.displayAnnotationsFilter = displayAnnotationsFilter;
        this.displayDateTimeBarSeparator = displayDateTimeBarSeparator;
        this.displayExactValues = displayExactValues;
        this.displayLegendDots = displayLegendDots;
        this.displayLegendValues = displayLegendValues;
        this.displayRangeSelector = displayRangeSelector;
        this.displayZoomButtons = displayZoomButtons;
        this.fill = fill;
        this.legendPosition = legendPosition;
        this.max = max;
        this.min = min;
        this.numberFormats = numberFormats;
        this.scaleColumns = scaleColumns;
        this.scaleFormat = scaleFormat;
        this.scaleType = scaleType;
        this.thickness = thickness;
        this.zoomEndTime = zoomEndTime;
        this.zoomStartTime = zoomStartTime;
    }

    _createClass(AnnotationChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.AnnotationChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    allowHtml: "boolean",
                    allValuesSuffix: "string",
                    annotationsWidth: "number",
                    colors: FableArray("string"),
                    dateFormat: "string",
                    displayAnnotations: "boolean",
                    displayAnnotationsFilter: "boolean",
                    displayDateTimeBarSeparator: "boolean",
                    displayExactValues: "boolean",
                    displayLegendDots: "boolean",
                    displayLegendValues: "boolean",
                    displayRangeSelector: "boolean",
                    displayZoomButtons: "boolean",
                    fill: "number",
                    legendPosition: "string",
                    max: "number",
                    min: "number",
                    numberFormats: Any,
                    scaleColumns: FableArray(Float64Array, true),
                    scaleFormat: "string",
                    scaleType: "string",
                    thickness: "number",
                    zoomEndTime: Date,
                    zoomStartTime: Date
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return AnnotationChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.AnnotationChartOptions", AnnotationChartOptions);
var SteppedAreaChartOptions = function () {
    function SteppedAreaChartOptions(aggregationTarget, animation, areaOpacity, axisTitlesPosition, backgroundColor, chartArea, colors, connectSteps, enableInteractivity, focusTarget, fontSize, fontName, hAxis, height, interpolateNulls, isStacked, legend, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, SteppedAreaChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.areaOpacity = areaOpacity;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.connectSteps = connectSteps;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.isStacked = isStacked;
        this.legend = legend;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(SteppedAreaChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.SteppedAreaChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    areaOpacity: "number",
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    connectSteps: "boolean",
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    interpolateNulls: "boolean",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return SteppedAreaChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.SteppedAreaChartOptions", SteppedAreaChartOptions);
var PieChartOptions = function () {
    function PieChartOptions(backgroundColor, chartArea, colors, enableInteractivity, fontSize, fontName, height, is3D, legend, pieHole, pieSliceBorderColor, pieSliceText, pieSliceTextStyle, pieStartAngle, reverseCategories, pieResidueSliceColor, pieResidueSliceLabel, slices, sliceVisibilityThreshold, title, titleTextStyle, tooltip, width) {
        _classCallCheck(this, PieChartOptions);

        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.height = height;
        this.is3D = is3D;
        this.legend = legend;
        this.pieHole = pieHole;
        this.pieSliceBorderColor = pieSliceBorderColor;
        this.pieSliceText = pieSliceText;
        this.pieSliceTextStyle = pieSliceTextStyle;
        this.pieStartAngle = pieStartAngle;
        this.reverseCategories = reverseCategories;
        this.pieResidueSliceColor = pieResidueSliceColor;
        this.pieResidueSliceLabel = pieResidueSliceLabel;
        this.slices = slices;
        this.sliceVisibilityThreshold = sliceVisibilityThreshold;
        this.title = title;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.width = width;
    }

    _createClass(PieChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.PieChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    fontSize: "number",
                    fontName: "string",
                    height: "number",
                    is3D: "boolean",
                    legend: ChartLegend,
                    pieHole: "number",
                    pieSliceBorderColor: "string",
                    pieSliceText: "string",
                    pieSliceTextStyle: ChartTextStyle,
                    pieStartAngle: "number",
                    reverseCategories: "boolean",
                    pieResidueSliceColor: "string",
                    pieResidueSliceLabel: "string",
                    slices: Any,
                    sliceVisibilityThreshold: "number",
                    title: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return PieChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.PieChartOptions", PieChartOptions);
var ChartBubble = function () {
    function ChartBubble(opacity, stroke, textStyle) {
        _classCallCheck(this, ChartBubble);

        this.opacity = opacity;
        this.stroke = stroke;
        this.textStyle = textStyle;
    }

    _createClass(ChartBubble, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBubble",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    opacity: "number",
                    stroke: "string",
                    textStyle: ChartTextStyle
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBubble;
}();
setType("TheGamma.GoogleCharts.Options.ChartBubble", ChartBubble);
var BubbleChartOptions = function () {
    function BubbleChartOptions(animation, axisTitlesPosition, backgroundColor, bubble, chartArea, colors, colorAxis, enableInteractivity, explorer, fontSize, fontName, forceIFrame, hAxis, height, legend, selectionMode, series, sizeAxis, sortBubblesBySize, theme, title, titlePosition, titleTextStyle, tooltip, vAxis, width) {
        _classCallCheck(this, BubbleChartOptions);

        this.animation = animation;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bubble = bubble;
        this.chartArea = chartArea;
        this.colors = colors;
        this.colorAxis = colorAxis;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.forceIFrame = forceIFrame;
        this.hAxis = hAxis;
        this.height = height;
        this.legend = legend;
        this.selectionMode = selectionMode;
        this.series = series;
        this.sizeAxis = sizeAxis;
        this.sortBubblesBySize = sortBubblesBySize;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(BubbleChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.BubbleChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    animation: TransitionAnimation,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bubble: ChartBubble,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    colorAxis: ChartColorAxis,
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    fontSize: "number",
                    fontName: "string",
                    forceIFrame: "boolean",
                    hAxis: ChartAxis,
                    height: "number",
                    legend: ChartLegend,
                    selectionMode: "string",
                    series: Any,
                    sizeAxis: ChartSizeAxis,
                    sortBubblesBySize: "boolean",
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return BubbleChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.BubbleChartOptions", BubbleChartOptions);
var TreeMapOptions = function () {
    function TreeMapOptions(fontColor, fontFamily, fontSize, forceIFrame, headerColor, headerHeight, headerHighlightColor, hintOpacity, maxColor, maxDepth, maxHighlightColor, maxPostDepth, maxColorValue, midColor, midHighlightColor, minColor, minHighlightColor, minColorValue, showScale, showTooltips, textStyle, title, titleTextStyle, useWeightedAverageForAggregation) {
        _classCallCheck(this, TreeMapOptions);

        this.fontColor = fontColor;
        this.fontFamily = fontFamily;
        this.fontSize = fontSize;
        this.forceIFrame = forceIFrame;
        this.headerColor = headerColor;
        this.headerHeight = headerHeight;
        this.headerHighlightColor = headerHighlightColor;
        this.hintOpacity = hintOpacity;
        this.maxColor = maxColor;
        this.maxDepth = maxDepth;
        this.maxHighlightColor = maxHighlightColor;
        this.maxPostDepth = maxPostDepth;
        this.maxColorValue = maxColorValue;
        this.midColor = midColor;
        this.midHighlightColor = midHighlightColor;
        this.minColor = minColor;
        this.minHighlightColor = minHighlightColor;
        this.minColorValue = minColorValue;
        this.showScale = showScale;
        this.showTooltips = showTooltips;
        this.textStyle = textStyle;
        this.title = title;
        this.titleTextStyle = titleTextStyle;
        this.useWeightedAverageForAggregation = useWeightedAverageForAggregation;
    }

    _createClass(TreeMapOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TreeMapOptions",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    fontColor: "string",
                    fontFamily: "string",
                    fontSize: "number",
                    forceIFrame: "boolean",
                    headerColor: "string",
                    headerHeight: "number",
                    headerHighlightColor: "string",
                    hintOpacity: "number",
                    maxColor: "string",
                    maxDepth: "number",
                    maxHighlightColor: "string",
                    maxPostDepth: "number",
                    maxColorValue: "number",
                    midColor: "string",
                    midHighlightColor: "string",
                    minColor: "string",
                    minHighlightColor: "string",
                    minColorValue: "number",
                    showScale: "boolean",
                    showTooltips: "boolean",
                    textStyle: ChartTextStyle,
                    title: "string",
                    titleTextStyle: ChartTextStyle,
                    useWeightedAverageForAggregation: "boolean"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TreeMapOptions;
}();
setType("TheGamma.GoogleCharts.Options.TreeMapOptions", TreeMapOptions);
var CssClassNames = function () {
    function CssClassNames(headerRow, tableRow, oddTableRow, selectedTableRow, hoverTableRow, headerCell, tableCell, rowNumberCell) {
        _classCallCheck(this, CssClassNames);

        this.headerRow = headerRow;
        this.tableRow = tableRow;
        this.oddTableRow = oddTableRow;
        this.selectedTableRow = selectedTableRow;
        this.hoverTableRow = hoverTableRow;
        this.headerCell = headerCell;
        this.tableCell = tableCell;
        this.rowNumberCell = rowNumberCell;
    }

    _createClass(CssClassNames, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.CssClassNames",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    headerRow: "string",
                    tableRow: "string",
                    oddTableRow: "string",
                    selectedTableRow: "string",
                    hoverTableRow: "string",
                    headerCell: "string",
                    tableCell: "string",
                    rowNumberCell: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return CssClassNames;
}();
setType("TheGamma.GoogleCharts.Options.CssClassNames", CssClassNames);
var TableOptions = function () {
    function TableOptions(allowHtml, alternatingRowStyle, cssClassName, firstRowNumber, height, page, pageSize, rtlTable, scrollLeftStartPosition, showRowNumber, sort, sortAscending, sortColumn, startPage, width) {
        _classCallCheck(this, TableOptions);

        this.allowHtml = allowHtml;
        this.alternatingRowStyle = alternatingRowStyle;
        this.cssClassName = cssClassName;
        this.firstRowNumber = firstRowNumber;
        this.height = height;
        this.page = page;
        this.pageSize = pageSize;
        this.rtlTable = rtlTable;
        this.scrollLeftStartPosition = scrollLeftStartPosition;
        this.showRowNumber = showRowNumber;
        this.sort = sort;
        this.sortAscending = sortAscending;
        this.sortColumn = sortColumn;
        this.startPage = startPage;
        this.width = width;
    }

    _createClass(TableOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TableOptions",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    allowHtml: "boolean",
                    alternatingRowStyle: "boolean",
                    cssClassName: CssClassNames,
                    firstRowNumber: "number",
                    height: "string",
                    page: "string",
                    pageSize: "number",
                    rtlTable: "boolean",
                    scrollLeftStartPosition: "number",
                    showRowNumber: "boolean",
                    sort: "string",
                    sortAscending: "boolean",
                    sortColumn: "number",
                    startPage: "number",
                    width: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TableOptions;
}();
setType("TheGamma.GoogleCharts.Options.TableOptions", TableOptions);
var LabelStyle = function () {
    function LabelStyle(color, fontName, fontSize) {
        _classCallCheck(this, LabelStyle);

        this.color = color;
        this.fontName = fontName;
        this.fontSize = fontSize;
    }

    _createClass(LabelStyle, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.LabelStyle",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    fontName: "string",
                    fontSize: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return LabelStyle;
}();
setType("TheGamma.GoogleCharts.Options.LabelStyle", LabelStyle);
var TimelineTimeline = function () {
    function TimelineTimeline(barLabelStyle, colorByRowLabel, groupByRowLabel, rowLabelStyle, showRowLabels, singleColor) {
        _classCallCheck(this, TimelineTimeline);

        this.barLabelStyle = barLabelStyle;
        this.colorByRowLabel = colorByRowLabel;
        this.groupByRowLabel = groupByRowLabel;
        this.rowLabelStyle = rowLabelStyle;
        this.showRowLabels = showRowLabels;
        this.singleColor = singleColor;
    }

    _createClass(TimelineTimeline, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TimelineTimeline",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    barLabelStyle: LabelStyle,
                    colorByRowLabel: "boolean",
                    groupByRowLabel: "boolean",
                    rowLabelStyle: LabelStyle,
                    showRowLabels: "boolean",
                    singleColor: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TimelineTimeline;
}();
setType("TheGamma.GoogleCharts.Options.TimelineTimeline", TimelineTimeline);
var TimelineOptions = function () {
    function TimelineOptions(avoidOverlappingGridLines, backgroundColor, colors, enableInteractivity, forceIFrame, height, timeline, width) {
        _classCallCheck(this, TimelineOptions);

        this.avoidOverlappingGridLines = avoidOverlappingGridLines;
        this.backgroundColor = backgroundColor;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.forceIFrame = forceIFrame;
        this.height = height;
        this.timeline = timeline;
        this.width = width;
    }

    _createClass(TimelineOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TimelineOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    avoidOverlappingGridLines: "boolean",
                    backgroundColor: Any,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    forceIFrame: "boolean",
                    height: "number",
                    timeline: TimelineTimeline,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return TimelineOptions;
}();
setType("TheGamma.GoogleCharts.Options.TimelineOptions", TimelineOptions);
var CandlestickCandlestick = function () {
    function CandlestickCandlestick(hollowIsRising, fallingColor, risingColor) {
        _classCallCheck(this, CandlestickCandlestick);

        this.hollowIsRising = hollowIsRising;
        this.fallingColor = fallingColor;
        this.risingColor = risingColor;
    }

    _createClass(CandlestickCandlestick, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.CandlestickCandlestick",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    hollowIsRising: "boolean",
                    fallingColor: ChartStroke,
                    risingColor: ChartStroke
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return CandlestickCandlestick;
}();
setType("TheGamma.GoogleCharts.Options.CandlestickCandlestick", CandlestickCandlestick);
var CandlestickChartOptions = function () {
    function CandlestickChartOptions(aggregationTarget, animation, axisTitlesPosition, backgroundColor, bar, candlestick, chartArea, colors, enableInteractivity, focusTarget, fontSize, fontName, hAxis, height, legend, orientation, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, CandlestickChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.candlestick = candlestick;
        this.chartArea = chartArea;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.legend = legend;
        this.orientation = orientation;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(CandlestickChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.CandlestickChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    candlestick: CandlestickCandlestick,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    legend: ChartLegend,
                    orientation: "string",
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return CandlestickChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.CandlestickChartOptions", CandlestickChartOptions);

var Geo = function () {
  function Geo(data, typeName, options) {
    _classCallCheck(this, Geo);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Geo, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Geo",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: GeoChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (backgroundColor, datalessRegionColor, displayMode, enableRegionInteractivity, height, keepAspectRatio, region, markerOpacity, resolution, width) {
      var newOptions = void 0;
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var datalessRegionColor_1 = Helpers.right(this.options, "datalessRegionColor", datalessRegionColor);
      var displayMode_1 = Helpers.right(this.options, "displayMode", displayMode);
      var enableRegionInteractivity_1 = Helpers.right(this.options, "enableRegionInteractivity", enableRegionInteractivity);
      var height_1 = Helpers.right(this.options, "height", height);
      var keepAspectRatio_1 = Helpers.right(this.options, "keepAspectRatio", keepAspectRatio);
      var region_1 = Helpers.right(this.options, "region", region);
      var markerOpacity_1 = Helpers.right(this.options, "markerOpacity", markerOpacity);
      var resolution_1 = Helpers.right(this.options, "resolution", resolution);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new GeoChartOptions(backgroundColor_1, this.options.colorAxis, datalessRegionColor_1, displayMode_1, enableRegionInteractivity_1, height_1, keepAspectRatio_1, this.options.legend, region_1, this.options.magnifyingGlass, markerOpacity_1, resolution_1, this.options.sizeAxis, this.options.tooltip, width_1);
      return new Geo(this.data, this.typeName, newOptions);
    }
  }, {
    key: "colorAxis",
    value: function (minValue, maxValue, values, colors) {
      var o = this.options.colorAxis;
      var newNested = new ChartColorAxis(Helpers.right(o, "minValue", minValue), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "values", defaultArg(values, null, function (source) {
        return Float64Array.from(source);
      })), Helpers.right(o, "colors", defaultArg(colors, null, function (source_1) {
        return _Array$from(source_1);
      })), Helpers.copy(o, "legend"));
      var options = new GeoChartOptions(this.options.backgroundColor, newNested, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, newNested, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "magnifyingGlass",
    value: function (enable, zoomFactor) {
      var o = this.options.magnifyingGlass;
      var newNested = new GeoChartMagnifyingGlass(Helpers.right(o, "enable", enable), Helpers.right(o, "zoomFactor", zoomFactor));
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, newNested, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "sizeAxis",
    value: function (maxSize, maxValue, minSize, minValue) {
      var o = this.options.sizeAxis;
      var newNested = new ChartSizeAxis(Helpers.right(o, "maxSize", maxSize), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "minSize", minSize), Helpers.right(o, "minValue", minValue));
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, newNested, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, newNested, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }]);

  return Geo;
}();
setType("TheGamma.GoogleCharts.Extensions.Geo", Geo);

var Scatter = function () {
  function Scatter(data, typeName, options) {
    _classCallCheck(this, Scatter);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Scatter, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Scatter",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: ScatterChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, curveType, dataOpacity, enableInteractivity, fontSize, fontName, forceIFrame, height, lineWidth, pointSize, selectionMode, series, theme, title, titlePosition, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var curveType_1 = Helpers.right(this.options, "curveType", curveType);
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var height_1 = Helpers.right(this.options, "height", height);
      var lineWidth_1 = Helpers.right(this.options, "lineWidth", lineWidth);
      var pointSize_1 = Helpers.right(this.options, "pointSize", pointSize);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new ScatterChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, this.options.crosshair, curveType_1, dataOpacity_1, enableInteractivity_1, this.options.explorer, fontSize_1, fontName_1, forceIFrame_1, this.options.hAxis, height_1, this.options.legend, lineWidth_1, pointSize_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, width_1);
      return new Scatter(this.data, this.typeName, newOptions);
    }
  }, {
    key: "trendlines",
    value: function (_trendlines) {
      var options = void 0;
      var trendlines_1 = Helpers.right(this.options, "trendlines", defaultArg(_trendlines, null, function (source) {
        return _Array$from(source);
      }));
      options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, trendlines_1, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new ScatterChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "crosshair",
    value: function (color, opacity, orientation, trigger) {
      var o = this.options.crosshair;
      var newNested = void 0;
      var color_1 = Helpers.right(o, "color", color);
      var opacity_1 = Helpers.right(o, "opacity", opacity);
      var orientation_1 = Helpers.right(o, "orientation", orientation);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartCrosshair(color_1, Helpers.copy(o, "focused"), opacity_1, orientation_1, Helpers.copy(o, "selected"), trigger_1);
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, newNested, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, newNested, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, newNested, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, newNested, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, newNested, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }]);

  return Scatter;
}();

setType("TheGamma.GoogleCharts.Extensions.Scatter", Scatter);
var Column = function () {
  function Column(data, typeName, options) {
    _classCallCheck(this, Column);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Column, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Column",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: ColumnChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, enableInteractivity, focusTarget, fontSize, fontName, height, isStacked, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new ColumnChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.chartArea, colors_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, isStacked_1, this.options.legend, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Column(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new ColumnChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, newNested, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }]);

  return Column;
}();
setType("TheGamma.GoogleCharts.Extensions.Column", Column);
var Line = function () {
  function Line(data, typeName, options) {
    _classCallCheck(this, Line);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Line, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Line",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: LineChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, curveType, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var curveType_1 = Helpers.right(this.options, "curveType", curveType);
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var lineWidth_1 = Helpers.right(this.options, "lineWidth", lineWidth);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var pointSize_1 = Helpers.right(this.options, "pointSize", pointSize);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new LineChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, this.options.crosshair, curveType_1, dataOpacity_1, enableInteractivity_1, this.options.explorer, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, interpolateNulls_1, this.options.legend, lineWidth_1, orientation_1, pointSize_1, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Line(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new LineChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "crosshair",
    value: function (color, opacity, orientation, trigger) {
      var o = this.options.crosshair;
      var newNested = void 0;
      var color_1 = Helpers.right(o, "color", color);
      var opacity_1 = Helpers.right(o, "opacity", opacity);
      var orientation_1 = Helpers.right(o, "orientation", orientation);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartCrosshair(color_1, Helpers.copy(o, "focused"), opacity_1, orientation_1, Helpers.copy(o, "selected"), trigger_1);
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, newNested, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, newNested, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, newNested, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }]);

  return Line;
}();
setType("TheGamma.GoogleCharts.Extensions.Line", Line);
var Bar = function () {
  function Bar(data, typeName, options) {
    _classCallCheck(this, Bar);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Bar, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Bar",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: BarChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, hAxes, height, isStacked, reverseCategories, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var hAxes_1 = Helpers.right(this.options, "hAxes", hAxes);
      var height_1 = Helpers.right(this.options, "height", height);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new BarChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.chartArea, colors_1, dataOpacity_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, hAxes_1, this.options.hAxis, height_1, isStacked_1, this.options.legend, reverseCategories_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Bar(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new BarChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, newNested, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, newNested, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }]);

  return Bar;
}();
setType("TheGamma.GoogleCharts.Extensions.Bar", Bar);
var Histogram = function () {
  function Histogram(data, typeName, options) {
    _classCallCheck(this, Histogram);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Histogram, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Histogram",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: HistogramOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (axisTitlesPosition, backgroundColor, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, isStacked, orientation, reverseCategories, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new HistogramOptions(this.options.animation, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.chartArea, colors_1, dataOpacity_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, this.options.histogram, height_1, interpolateNulls_1, isStacked_1, this.options.legend, orientation_1, reverseCategories_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Histogram(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new HistogramOptions(newNested, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "histogram",
    value: function (bucketSize, hideBucketItems, lastBucketPercentile) {
      var o = this.options.histogram;
      var newNested = new HistogramHistogram(Helpers.right(o, "bucketSize", bucketSize), Helpers.right(o, "hideBucketItems", hideBucketItems), Helpers.right(o, "lastBucketPercentile", lastBucketPercentile));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, newNested, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, newNested, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }]);

  return Histogram;
}();
setType("TheGamma.GoogleCharts.Extensions.Histogram", Histogram);
var Area = function () {
  function Area(data, typeName, options) {
    _classCallCheck(this, Area);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Area, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Area",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: AreaChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, areaOpacity, axisTitlesPosition, backgroundColor, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, isStacked, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var areaOpacity_1 = Helpers.right(this.options, "areaOpacity", areaOpacity);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var lineWidth_1 = Helpers.right(this.options, "lineWidth", lineWidth);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var pointSize_1 = Helpers.right(this.options, "pointSize", pointSize);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new AreaChartOptions(aggregationTarget_1, this.options.animation, areaOpacity_1, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, this.options.crosshair, dataOpacity_1, enableInteractivity_1, this.options.explorer, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, interpolateNulls_1, isStacked_1, this.options.legend, lineWidth_1, orientation_1, pointSize_1, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Area(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new AreaChartOptions(this.options.aggregationTarget, newNested, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "crosshair",
    value: function (color, opacity, orientation, trigger) {
      var o = this.options.crosshair;
      var newNested = void 0;
      var color_1 = Helpers.right(o, "color", color);
      var opacity_1 = Helpers.right(o, "opacity", opacity);
      var orientation_1 = Helpers.right(o, "orientation", orientation);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartCrosshair(color_1, Helpers.copy(o, "focused"), opacity_1, orientation_1, Helpers.copy(o, "selected"), trigger_1);
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, newNested, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, newNested, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, newNested, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }]);

  return Area;
}();
setType("TheGamma.GoogleCharts.Extensions.Area", Area);
var Annotation = function () {
  function Annotation(data, typeName, options) {
    _classCallCheck(this, Annotation);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Annotation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Annotation",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: AnnotationChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (allowHtml, allValuesSuffix, annotationsWidth, colors, dateFormat, displayAnnotations, displayAnnotationsFilter, displayDateTimeBarSeparator, displayExactValues, displayLegendDots, displayLegendValues, displayRangeSelector, displayZoomButtons, fill, legendPosition, max, min, numberFormats, scaleColumns, scaleFormat, scaleType, thickness, zoomEndTime, zoomStartTime) {
      var newOptions = new AnnotationChartOptions(Helpers.right(this.options, "allowHtml", allowHtml), Helpers.right(this.options, "allValuesSuffix", allValuesSuffix), Helpers.right(this.options, "annotationsWidth", annotationsWidth), Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(this.options, "dateFormat", dateFormat), Helpers.right(this.options, "displayAnnotations", displayAnnotations), Helpers.right(this.options, "displayAnnotationsFilter", displayAnnotationsFilter), Helpers.right(this.options, "displayDateTimeBarSeparator", displayDateTimeBarSeparator), Helpers.right(this.options, "displayExactValues", displayExactValues), Helpers.right(this.options, "displayLegendDots", displayLegendDots), Helpers.right(this.options, "displayLegendValues", displayLegendValues), Helpers.right(this.options, "displayRangeSelector", displayRangeSelector), Helpers.right(this.options, "displayZoomButtons", displayZoomButtons), Helpers.right(this.options, "fill", fill), Helpers.right(this.options, "legendPosition", legendPosition), Helpers.right(this.options, "max", max), Helpers.right(this.options, "min", min), Helpers.right(this.options, "numberFormats", numberFormats), Helpers.right(this.options, "scaleColumns", defaultArg(scaleColumns, null, function (source_1) {
        return Float64Array.from(source_1);
      })), Helpers.right(this.options, "scaleFormat", scaleFormat), Helpers.right(this.options, "scaleType", scaleType), Helpers.right(this.options, "thickness", thickness), Helpers.right(this.options, "zoomEndTime", zoomEndTime), Helpers.right(this.options, "zoomStartTime", zoomStartTime));
      return new Annotation(this.data, this.typeName, newOptions);
    }
  }]);

  return Annotation;
}();
setType("TheGamma.GoogleCharts.Extensions.Annotation", Annotation);
var SteppedArea = function () {
  function SteppedArea(data, typeName, options) {
    _classCallCheck(this, SteppedArea);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(SteppedArea, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.SteppedArea",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: SteppedAreaChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, areaOpacity, axisTitlesPosition, backgroundColor, colors, connectSteps, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, isStacked, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var areaOpacity_1 = Helpers.right(this.options, "areaOpacity", areaOpacity);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var connectSteps_1 = Helpers.right(this.options, "connectSteps", connectSteps);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new SteppedAreaChartOptions(aggregationTarget_1, this.options.animation, areaOpacity_1, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, connectSteps_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, interpolateNulls_1, isStacked_1, this.options.legend, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new SteppedArea(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, newNested, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, newNested, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }]);

  return SteppedArea;
}();
setType("TheGamma.GoogleCharts.Extensions.SteppedArea", SteppedArea);
var Pie = function () {
  function Pie(data, typeName, options) {
    _classCallCheck(this, Pie);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Pie, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Pie",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: PieChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (backgroundColor, colors, enableInteractivity, fontSize, fontName, height, is3D, pieHole, pieSliceBorderColor, pieSliceText, pieStartAngle, reverseCategories, pieResidueSliceColor, pieResidueSliceLabel, slices, sliceVisibilityThreshold, title, width) {
      var newOptions = void 0;
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var is3D_1 = Helpers.right(this.options, "is3D", is3D);
      var pieHole_1 = Helpers.right(this.options, "pieHole", pieHole);
      var pieSliceBorderColor_1 = Helpers.right(this.options, "pieSliceBorderColor", pieSliceBorderColor);
      var pieSliceText_1 = Helpers.right(this.options, "pieSliceText", pieSliceText);
      var pieStartAngle_1 = Helpers.right(this.options, "pieStartAngle", pieStartAngle);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var pieResidueSliceColor_1 = Helpers.right(this.options, "pieResidueSliceColor", pieResidueSliceColor);
      var pieResidueSliceLabel_1 = Helpers.right(this.options, "pieResidueSliceLabel", pieResidueSliceLabel);
      var slices_1 = Helpers.right(this.options, "slices", slices);
      var sliceVisibilityThreshold_1 = Helpers.right(this.options, "sliceVisibilityThreshold", sliceVisibilityThreshold);
      var title_1 = Helpers.right(this.options, "title", title);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new PieChartOptions(backgroundColor_1, this.options.chartArea, colors_1, enableInteractivity_1, fontSize_1, fontName_1, height_1, is3D_1, this.options.legend, pieHole_1, pieSliceBorderColor_1, pieSliceText_1, this.options.pieSliceTextStyle, pieStartAngle_1, reverseCategories_1, pieResidueSliceColor_1, pieResidueSliceLabel_1, slices_1, sliceVisibilityThreshold_1, title_1, this.options.titleTextStyle, this.options.tooltip, width_1);
      return new Pie(this.data, this.typeName, newOptions);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new PieChartOptions(this.options.backgroundColor, newNested, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, newNested, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "pieSliceTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.pieSliceTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, newNested, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, newNested, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, newNested, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }]);

  return Pie;
}();
setType("TheGamma.GoogleCharts.Extensions.Pie", Pie);
var Bubble = function () {
  function Bubble(data, typeName, options) {
    _classCallCheck(this, Bubble);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Bubble, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Bubble",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: BubbleChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (axisTitlesPosition, backgroundColor, colors, enableInteractivity, fontSize, fontName, forceIFrame, height, selectionMode, series, sortBubblesBySize, theme, title, titlePosition, width) {
      var newOptions = void 0;
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var height_1 = Helpers.right(this.options, "height", height);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var sortBubblesBySize_1 = Helpers.right(this.options, "sortBubblesBySize", sortBubblesBySize);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new BubbleChartOptions(this.options.animation, axisTitlesPosition_1, backgroundColor_1, this.options.bubble, this.options.chartArea, colors_1, this.options.colorAxis, enableInteractivity_1, this.options.explorer, fontSize_1, fontName_1, forceIFrame_1, this.options.hAxis, height_1, this.options.legend, selectionMode_1, series_1, this.options.sizeAxis, sortBubblesBySize_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, width_1);
      return new Bubble(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new BubbleChartOptions(newNested, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "bubble",
    value: function (opacity, stroke) {
      var o = this.options.bubble;
      var newNested = new ChartBubble(Helpers.right(o, "opacity", opacity), Helpers.right(o, "stroke", stroke), Helpers.copy(o, "textStyle"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, newNested, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "colorAxis",
    value: function (minValue, maxValue, values, colors) {
      var o = this.options.colorAxis;
      var newNested = new ChartColorAxis(Helpers.right(o, "minValue", minValue), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "values", defaultArg(values, null, function (source) {
        return Float64Array.from(source);
      })), Helpers.right(o, "colors", defaultArg(colors, null, function (source_1) {
        return _Array$from(source_1);
      })), Helpers.copy(o, "legend"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, newNested, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, newNested, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, newNested, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, newNested, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "sizeAxis",
    value: function (maxSize, maxValue, minSize, minValue) {
      var o = this.options.sizeAxis;
      var newNested = new ChartSizeAxis(Helpers.right(o, "maxSize", maxSize), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "minSize", minSize), Helpers.right(o, "minValue", minValue));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, newNested, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, newNested, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }]);

  return Bubble;
}();
setType("TheGamma.GoogleCharts.Extensions.Bubble", Bubble);
var TreeMap = function () {
  function TreeMap(data, typeName, options) {
    _classCallCheck(this, TreeMap);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(TreeMap, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.TreeMap",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: TreeMapOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (fontColor, fontFamily, fontSize, forceIFrame, headerColor, headerHeight, headerHighlightColor, hintOpacity, maxColor, maxDepth, maxHighlightColor, maxPostDepth, maxColorValue, midColor, midHighlightColor, minColor, minHighlightColor, minColorValue, showScale, showTooltips, title, useWeightedAverageForAggregation) {
      var newOptions = void 0;
      var fontColor_1 = Helpers.right(this.options, "fontColor", fontColor);
      var fontFamily_1 = Helpers.right(this.options, "fontFamily", fontFamily);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var headerColor_1 = Helpers.right(this.options, "headerColor", headerColor);
      var headerHeight_1 = Helpers.right(this.options, "headerHeight", headerHeight);
      var headerHighlightColor_1 = Helpers.right(this.options, "headerHighlightColor", headerHighlightColor);
      var hintOpacity_1 = Helpers.right(this.options, "hintOpacity", hintOpacity);
      var maxColor_1 = Helpers.right(this.options, "maxColor", maxColor);
      var maxDepth_1 = Helpers.right(this.options, "maxDepth", maxDepth);
      var maxHighlightColor_1 = Helpers.right(this.options, "maxHighlightColor", maxHighlightColor);
      var maxPostDepth_1 = Helpers.right(this.options, "maxPostDepth", maxPostDepth);
      var maxColorValue_1 = Helpers.right(this.options, "maxColorValue", maxColorValue);
      var midColor_1 = Helpers.right(this.options, "midColor", midColor);
      var midHighlightColor_1 = Helpers.right(this.options, "midHighlightColor", midHighlightColor);
      var minColor_1 = Helpers.right(this.options, "minColor", minColor);
      var minHighlightColor_1 = Helpers.right(this.options, "minHighlightColor", minHighlightColor);
      var minColorValue_1 = Helpers.right(this.options, "minColorValue", minColorValue);
      var showScale_1 = Helpers.right(this.options, "showScale", showScale);
      var showTooltips_1 = Helpers.right(this.options, "showTooltips", showTooltips);
      var title_1 = Helpers.right(this.options, "title", title);
      var useWeightedAverageForAggregation_1 = Helpers.right(this.options, "useWeightedAverageForAggregation", useWeightedAverageForAggregation);
      newOptions = new TreeMapOptions(fontColor_1, fontFamily_1, fontSize_1, forceIFrame_1, headerColor_1, headerHeight_1, headerHighlightColor_1, hintOpacity_1, maxColor_1, maxDepth_1, maxHighlightColor_1, maxPostDepth_1, maxColorValue_1, midColor_1, midHighlightColor_1, minColor_1, minHighlightColor_1, minColorValue_1, showScale_1, showTooltips_1, this.options.textStyle, title_1, this.options.titleTextStyle, useWeightedAverageForAggregation_1);
      return new TreeMap(this.data, this.typeName, newOptions);
    }
  }, {
    key: "textStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.textStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new TreeMapOptions(this.options.fontColor, this.options.fontFamily, this.options.fontSize, this.options.forceIFrame, this.options.headerColor, this.options.headerHeight, this.options.headerHighlightColor, this.options.hintOpacity, this.options.maxColor, this.options.maxDepth, this.options.maxHighlightColor, this.options.maxPostDepth, this.options.maxColorValue, this.options.midColor, this.options.midHighlightColor, this.options.minColor, this.options.minHighlightColor, this.options.minColorValue, this.options.showScale, this.options.showTooltips, newNested, this.options.title, this.options.titleTextStyle, this.options.useWeightedAverageForAggregation);
      return new TreeMap(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new TreeMapOptions(this.options.fontColor, this.options.fontFamily, this.options.fontSize, this.options.forceIFrame, this.options.headerColor, this.options.headerHeight, this.options.headerHighlightColor, this.options.hintOpacity, this.options.maxColor, this.options.maxDepth, this.options.maxHighlightColor, this.options.maxPostDepth, this.options.maxColorValue, this.options.midColor, this.options.midHighlightColor, this.options.minColor, this.options.minHighlightColor, this.options.minColorValue, this.options.showScale, this.options.showTooltips, this.options.textStyle, this.options.title, newNested, this.options.useWeightedAverageForAggregation);
      return new TreeMap(this.data, this.typeName, options);
    }
  }]);

  return TreeMap;
}();
setType("TheGamma.GoogleCharts.Extensions.TreeMap", TreeMap);
var Table = function () {
  function Table(data, typeName, options) {
    _classCallCheck(this, Table);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Table, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Table",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: TableOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (allowHtml, alternatingRowStyle, firstRowNumber, height, page, pageSize, rtlTable, scrollLeftStartPosition, showRowNumber, sort, sortAscending, sortColumn, startPage, width) {
      var newOptions = void 0;
      var allowHtml_1 = Helpers.right(this.options, "allowHtml", allowHtml);
      var alternatingRowStyle_1 = Helpers.right(this.options, "alternatingRowStyle", alternatingRowStyle);
      var firstRowNumber_1 = Helpers.right(this.options, "firstRowNumber", firstRowNumber);
      var height_1 = Helpers.right(this.options, "height", height);
      var page_1 = Helpers.right(this.options, "page", page);
      var pageSize_1 = Helpers.right(this.options, "pageSize", pageSize);
      var rtlTable_1 = Helpers.right(this.options, "rtlTable", rtlTable);
      var scrollLeftStartPosition_1 = Helpers.right(this.options, "scrollLeftStartPosition", scrollLeftStartPosition);
      var showRowNumber_1 = Helpers.right(this.options, "showRowNumber", showRowNumber);
      var sort_1 = Helpers.right(this.options, "sort", sort);
      var sortAscending_1 = Helpers.right(this.options, "sortAscending", sortAscending);
      var sortColumn_1 = Helpers.right(this.options, "sortColumn", sortColumn);
      var startPage_1 = Helpers.right(this.options, "startPage", startPage);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new TableOptions(allowHtml_1, alternatingRowStyle_1, this.options.cssClassName, firstRowNumber_1, height_1, page_1, pageSize_1, rtlTable_1, scrollLeftStartPosition_1, showRowNumber_1, sort_1, sortAscending_1, sortColumn_1, startPage_1, width_1);
      return new Table(this.data, this.typeName, newOptions);
    }
  }, {
    key: "cssClassName",
    value: function (headerRow, tableRow, oddTableRow, selectedTableRow, hoverTableRow, headerCell, tableCell, rowNumberCell) {
      var o = this.options.cssClassName;
      var newNested = new CssClassNames(Helpers.right(o, "headerRow", headerRow), Helpers.right(o, "tableRow", tableRow), Helpers.right(o, "oddTableRow", oddTableRow), Helpers.right(o, "selectedTableRow", selectedTableRow), Helpers.right(o, "hoverTableRow", hoverTableRow), Helpers.right(o, "headerCell", headerCell), Helpers.right(o, "tableCell", tableCell), Helpers.right(o, "rowNumberCell", rowNumberCell));
      var options = new TableOptions(this.options.allowHtml, this.options.alternatingRowStyle, newNested, this.options.firstRowNumber, this.options.height, this.options.page, this.options.pageSize, this.options.rtlTable, this.options.scrollLeftStartPosition, this.options.showRowNumber, this.options.sort, this.options.sortAscending, this.options.sortColumn, this.options.startPage, this.options.width);
      return new Table(this.data, this.typeName, options);
    }
  }]);

  return Table;
}();
setType("TheGamma.GoogleCharts.Extensions.Table", Table);
var Timeline = function () {
  function Timeline(data, typeName, options) {
    _classCallCheck(this, Timeline);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Timeline, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Timeline",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: TimelineOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (avoidOverlappingGridLines, backgroundColor, colors, enableInteractivity, forceIFrame, height, width) {
      var newOptions = void 0;
      var avoidOverlappingGridLines_1 = Helpers.right(this.options, "avoidOverlappingGridLines", avoidOverlappingGridLines);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var height_1 = Helpers.right(this.options, "height", height);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new TimelineOptions(avoidOverlappingGridLines_1, backgroundColor_1, colors_1, enableInteractivity_1, forceIFrame_1, height_1, this.options.timeline, width_1);
      return new Timeline(this.data, this.typeName, newOptions);
    }
  }, {
    key: "timeline",
    value: function (colorByRowLabel, groupByRowLabel, showRowLabels, singleColor) {
      var o = this.options.timeline;
      var newNested = void 0;
      var colorByRowLabel_1 = Helpers.right(o, "colorByRowLabel", colorByRowLabel);
      var groupByRowLabel_1 = Helpers.right(o, "groupByRowLabel", groupByRowLabel);
      var showRowLabels_1 = Helpers.right(o, "showRowLabels", showRowLabels);
      var singleColor_1 = Helpers.right(o, "singleColor", singleColor);
      newNested = new TimelineTimeline(Helpers.copy(o, "barLabelStyle"), colorByRowLabel_1, groupByRowLabel_1, Helpers.copy(o, "rowLabelStyle"), showRowLabels_1, singleColor_1);
      var options = new TimelineOptions(this.options.avoidOverlappingGridLines, this.options.backgroundColor, this.options.colors, this.options.enableInteractivity, this.options.forceIFrame, this.options.height, newNested, this.options.width);
      return new Timeline(this.data, this.typeName, options);
    }
  }]);

  return Timeline;
}();
setType("TheGamma.GoogleCharts.Extensions.Timeline", Timeline);
var Candlestick = function () {
  function Candlestick(data, typeName, options) {
    _classCallCheck(this, Candlestick);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Candlestick, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Candlestick",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: CandlestickChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, enableInteractivity, focusTarget, fontSize, fontName, height, orientation, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new CandlestickChartOptions(aggregationTarget_1, this.options.animation, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.candlestick, this.options.chartArea, colors_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, this.options.legend, orientation_1, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Candlestick(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, newNested, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "candlestick",
    value: function (hollowIsRising) {
      var o = this.options.candlestick;
      var newNested = new CandlestickCandlestick(Helpers.right(o, "hollowIsRising", hollowIsRising), Helpers.copy(o, "fallingColor"), Helpers.copy(o, "risingColor"));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, newNested, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, newNested, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }]);

  return Candlestick;
}();
setType("TheGamma.GoogleCharts.Extensions.Candlestick", Candlestick);

function GeoChartOptions_get_empty_Static() {
  return new GeoChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function ScatterChartOptions_get_empty_Static() {
  return new ScatterChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function ColumnChartOptions_get_empty_Static() {
  return new ColumnChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function LineChartOptions_get_empty_Static() {
  return new LineChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function BarChartOptions_get_empty_Static() {
  return new BarChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function AreaChartOptions_get_empty_Static() {
  return new AreaChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function PieChartOptions_get_empty_Static() {
  return new PieChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

var options$1 = function () {
  function options() {
    _classCallCheck(this, options);
  }

  _createClass(options, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.options",
        properties: {}
      };
    }
  }], [{
    key: "chartSizeAxis",
    value: function (maxSize, maxValue, minSize, minValue) {
      return new ChartSizeAxis(Helpers.orDefault(maxSize), Helpers.orDefault(maxValue), Helpers.orDefault(minSize), Helpers.orDefault(minValue));
    }
  }, {
    key: "chartTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      return new ChartTextStyle(Helpers.orDefault(fontName), Helpers.orDefault(fontSize), Helpers.orDefault(bold), Helpers.orDefault(italic), Helpers.orDefault(color), Helpers.orDefault(auraColor), Helpers.orDefault(opacity));
    }
  }, {
    key: "chartTooltip",
    value: function (isHtml, showColorCode, textStyle, trigger) {
      return new ChartTooltip(Helpers.orDefault(isHtml), Helpers.orDefault(showColorCode), Helpers.orDefault(textStyle), Helpers.orDefault(trigger));
    }
  }, {
    key: "chartLegend",
    value: function (alignment, maxLines, position, textStyle, numberFormat) {
      return new ChartLegend(Helpers.orDefault(alignment), Helpers.orDefault(maxLines), Helpers.orDefault(position), Helpers.orDefault(textStyle), Helpers.orDefault(numberFormat));
    }
  }, {
    key: "chartColorAxis",
    value: function (minValue, maxValue, values, colors, legend) {
      return new ChartColorAxis(Helpers.orDefault(minValue), Helpers.orDefault(maxValue), Helpers.orDefault(defaultArg(values, null, function (source) {
        return Float64Array.from(source);
      })), Helpers.orDefault(defaultArg(colors, null, function (source_1) {
        return _Array$from(source_1);
      })), Helpers.orDefault(legend));
    }
  }, {
    key: "geoChartMagnifyingGlass",
    value: function (enable, zoomFactor) {
      return new GeoChartMagnifyingGlass(Helpers.orDefault(enable), Helpers.orDefault(zoomFactor));
    }
  }, {
    key: "chartBoxStyleGradient",
    value: function (color1, color2, x1, y1, x2, y2, useObjectBoundingBoxUnits) {
      return new ChartBoxStyleGradient(Helpers.orDefault(color1), Helpers.orDefault(color2), Helpers.orDefault(x1), Helpers.orDefault(y1), Helpers.orDefault(x2), Helpers.orDefault(y2), Helpers.orDefault(useObjectBoundingBoxUnits));
    }
  }, {
    key: "chartBoxStyle",
    value: function (stroke, strokeWidth, rx, ry, gradient) {
      return new ChartBoxStyle(Helpers.orDefault(stroke), Helpers.orDefault(strokeWidth), Helpers.orDefault(rx), Helpers.orDefault(ry), Helpers.orDefault(gradient));
    }
  }, {
    key: "chartAnnotations",
    value: function (boxStyle, textStyle) {
      return new ChartAnnotations(Helpers.orDefault(boxStyle), Helpers.orDefault(textStyle));
    }
  }, {
    key: "chartCrosshairFocused",
    value: function (color, opacity) {
      return new ChartCrosshairFocused(Helpers.orDefault(color), Helpers.orDefault(opacity));
    }
  }, {
    key: "chartCrosshairSelected",
    value: function (color, opacity) {
      return new ChartCrosshairSelected(Helpers.orDefault(color), Helpers.orDefault(opacity));
    }
  }, {
    key: "chartCrosshair",
    value: function (color, focused, opacity, orientation, selected, trigger) {
      return new ChartCrosshair(Helpers.orDefault(color), Helpers.orDefault(focused), Helpers.orDefault(opacity), Helpers.orDefault(orientation), Helpers.orDefault(selected), Helpers.orDefault(trigger));
    }
  }, {
    key: "chartExplorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      return new ChartExplorer(Helpers.orDefault(defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.orDefault(axis), Helpers.orDefault(keepInBounds), Helpers.orDefault(maxZoomIn), Helpers.orDefault(maxZoomOut), Helpers.orDefault(zoomDelta));
    }
  }, {
    key: "chartStroke",
    value: function (stroke, strokeWidth, fill) {
      return new ChartStroke(Helpers.orDefault(stroke), Helpers.orDefault(strokeWidth), Helpers.orDefault(fill));
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      return new ChartArea(Helpers.orDefault(top), Helpers.orDefault(left), Helpers.orDefault(width), Helpers.orDefault(height));
    }
  }, {
    key: "transitionAnimation",
    value: function (duration, easing) {
      return new TransitionAnimation(Helpers.orDefault(duration), Helpers.orDefault(easing));
    }
  }, {
    key: "chartGridlines",
    value: function (color, count) {
      return new ChartGridlines(Helpers.orDefault(color), Helpers.orDefault(count));
    }
  }, {
    key: "chartViewWindow",
    value: function (max, min) {
      return new ChartViewWindow(Helpers.orDefault(max), Helpers.orDefault(min));
    }
  }, {
    key: "chartAxis",
    value: function (baseline, baselineColor, direction, format, gridlines, minorGridlines, logScale, textPosition, textStyle, ticks, title, titleTextStyle, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode, viewWindow) {
      return new ChartAxis(Helpers.orDefault(baseline), Helpers.orDefault(baselineColor), Helpers.orDefault(direction), Helpers.orDefault(format), Helpers.orDefault(gridlines), Helpers.orDefault(minorGridlines), Helpers.orDefault(logScale), Helpers.orDefault(textPosition), Helpers.orDefault(textStyle), Helpers.orDefault(defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      })), Helpers.orDefault(title), Helpers.orDefault(titleTextStyle), Helpers.orDefault(allowContainerBoundaryTextCufoff), Helpers.orDefault(slantedText), Helpers.orDefault(slantedTextAngle), Helpers.orDefault(maxAlternation), Helpers.orDefault(maxTextLines), Helpers.orDefault(minTextSpacing), Helpers.orDefault(showTextEvery), Helpers.orDefault(maxValue), Helpers.orDefault(minValue), Helpers.orDefault(viewWindowMode), Helpers.orDefault(viewWindow));
    }
  }, {
    key: "chartBoundingBox",
    value: function (left, top, width, height) {
      return new ChartBoundingBox(Helpers.orDefault(left), Helpers.orDefault(top), Helpers.orDefault(width), Helpers.orDefault(height));
    }
  }, {
    key: "groupWidth",
    value: function (_groupWidth) {
      return new GroupWidth(Helpers.orDefault(_groupWidth));
    }
  }, {
    key: "trendline",
    value: function (color, lineWidth, labelInLegend, opacity, pointSize, pointsVisible, showR2, type, visibleInLegend) {
      return new Trendline(Helpers.orDefault(color), Helpers.orDefault(lineWidth), Helpers.orDefault(labelInLegend), Helpers.orDefault(opacity), Helpers.orDefault(pointSize), Helpers.orDefault(pointsVisible), Helpers.orDefault(showR2), Helpers.orDefault(type), Helpers.orDefault(visibleInLegend));
    }
  }, {
    key: "histogramHistogram",
    value: function (bucketSize, hideBucketItems, lastBucketPercentile) {
      return new HistogramHistogram(Helpers.orDefault(bucketSize), Helpers.orDefault(hideBucketItems), Helpers.orDefault(lastBucketPercentile));
    }
  }, {
    key: "chartBubble",
    value: function (opacity, stroke, textStyle) {
      return new ChartBubble(Helpers.orDefault(opacity), Helpers.orDefault(stroke), Helpers.orDefault(textStyle));
    }
  }, {
    key: "cssClassNames",
    value: function (headerRow, tableRow, oddTableRow, selectedTableRow, hoverTableRow, headerCell, tableCell, rowNumberCell) {
      return new CssClassNames(Helpers.orDefault(headerRow), Helpers.orDefault(tableRow), Helpers.orDefault(oddTableRow), Helpers.orDefault(selectedTableRow), Helpers.orDefault(hoverTableRow), Helpers.orDefault(headerCell), Helpers.orDefault(tableCell), Helpers.orDefault(rowNumberCell));
    }
  }, {
    key: "labelStyle",
    value: function (color, fontName, fontSize) {
      return new LabelStyle(Helpers.orDefault(color), Helpers.orDefault(fontName), Helpers.orDefault(fontSize));
    }
  }, {
    key: "timelineTimeline",
    value: function (barLabelStyle, colorByRowLabel, groupByRowLabel, rowLabelStyle, showRowLabels, singleColor) {
      return new TimelineTimeline(Helpers.orDefault(barLabelStyle), Helpers.orDefault(colorByRowLabel), Helpers.orDefault(groupByRowLabel), Helpers.orDefault(rowLabelStyle), Helpers.orDefault(showRowLabels), Helpers.orDefault(singleColor));
    }
  }, {
    key: "candlestickCandlestick",
    value: function (hollowIsRising, fallingColor, risingColor) {
      return new CandlestickCandlestick(Helpers.orDefault(hollowIsRising), Helpers.orDefault(fallingColor), Helpers.orDefault(risingColor));
    }
  }]);

  return options;
}();

setType("TheGamma.GoogleCharts.Extensions.options", options$1);

var chart = function () {
  function chart() {
    _classCallCheck(this, chart);
  }

  _createClass(chart, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.chart",
        properties: {}
      };
    }
  }], [{
    key: "scatter",
    value: function (xval, yval) {
      return new Scatter(ChartDataOperations.twoValues(xval, yval), "ScatterChart", ScatterChartOptions_get_empty_Static());
    }
  }, {
    key: "geo",
    value: function (data) {
      return new Geo(ChartDataOperations.oneKeyValue("string", data), "GeoChart", GeoChartOptions_get_empty_Static());
    }
  }, {
    key: "pie",
    value: function (data) {
      return new Pie(ChartDataOperations.oneKeyValue("string", data), "PieChart", PieChartOptions_get_empty_Static());
    }
  }, {
    key: "bar",
    value: function (data) {
      return new Bar(ChartDataOperations.oneKeyValue("string", data), "BarChart", BarChartOptions_get_empty_Static());
    }
  }, {
    key: "column",
    value: function (data) {
      return new Column(ChartDataOperations.oneKeyValue("string", data), "ColumnChart", ColumnChartOptions_get_empty_Static());
    }
  }, {
    key: "columns",
    value: function (data, colors) {
      return new Line(ChartDataOperations.oneKeyAppendValues("string", data, colors), "ColumnChart", LineChartOptions_get_empty_Static());
    }
  }, {
    key: "line",
    value: function (data) {
      return new Line(ChartDataOperations.oneKeyValue("number", data), "LineChart", LineChartOptions_get_empty_Static());
    }
  }, {
    key: "lines",
    value: function (data) {
      return new Line(ChartDataOperations.oneKeyNValues("number", data), "LineChart", LineChartOptions_get_empty_Static());
    }
  }, {
    key: "area",
    value: function (data) {
      return new Area(ChartDataOperations.oneKeyValue("number", data), "AreaChart", AreaChartOptions_get_empty_Static());
    }
  }, {
    key: "areas",
    value: function (data, names) {
      var i = {
        contents: 0
      };
      var data_1 = names == null ? data : data.map(function (s) {
        void i.contents++;
        return s.setProperties(null, null, names[i.contents - 1]);
      });
      return new Area(ChartDataOperations.oneKeyNValues("number", data_1), "AreaChart", AreaChartOptions_get_empty_Static());
    }
  }, {
    key: "show",
    value: function (chart_1) {
      return function (outputId) {
        Helpers.showChart(chart_1, outputId);
      };
    }
  }]);

  return chart;
}();
setType("TheGamma.GoogleCharts.chart", chart);

var nativeIsArray = Array.isArray;
var toString$3 = Object.prototype.toString;

var index$4 = nativeIsArray || isArray$4;

function isArray$4(obj) {
    return toString$3.call(obj) === "[object Array]"
}

var version$2 = "2";

var version$1 = version$2;

VirtualPatch.NONE = 0;
VirtualPatch.VTEXT = 1;
VirtualPatch.VNODE = 2;
VirtualPatch.WIDGET = 3;
VirtualPatch.PROPS = 4;
VirtualPatch.ORDER = 5;
VirtualPatch.INSERT = 6;
VirtualPatch.REMOVE = 7;
VirtualPatch.THUNK = 8;

var vpatch = VirtualPatch;

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type);
    this.vNode = vNode;
    this.patch = patch;
}

VirtualPatch.prototype.version = version$1;
VirtualPatch.prototype.type = "VirtualPatch";

var version$4 = version$2;

var isVnode = isVirtualNode;

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version$4
}

var version$5 = version$2;

var isVtext = isVirtualText;

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version$5
}

var isWidget_1 = isWidget$1;

function isWidget$1(w) {
    return w && w.type === "Widget"
}

var isThunk_1 = isThunk$1;

function isThunk$1(t) {
    return t && t.type === "Thunk"
}

var isVNode$1 = isVnode;
var isVText$1 = isVtext;
var isWidget$2 = isWidget_1;
var isThunk$2 = isThunk_1;

var handleThunk_1 = handleThunk$1;

function handleThunk$1(a, b) {
    var renderedA = a;
    var renderedB = b;

    if (isThunk$2(b)) {
        renderedB = renderThunk(b, a);
    }

    if (isThunk$2(a)) {
        renderedA = renderThunk(a, null);
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode;

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous);
    }

    if (!(isVNode$1(renderedThunk) ||
            isVText$1(renderedThunk) ||
            isWidget$2(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

var index$6 = function isObject(x) {
	return typeof x === "object" && x !== null;
};

var isVhook = isHook$1;

function isHook$1(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

var isObject$5 = index$6;
var isHook = isVhook;

var diffProps_1 = diffProps$1;

function diffProps$1(a, b) {
    var diff;

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {};
            diff[aKey] = undefined;
        }

        var aValue = a[aKey];
        var bValue = b[aKey];

        if (aValue === bValue) {
            continue
        } else if (isObject$5(aValue) && isObject$5(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {};
                diff[aKey] = bValue;
            } else if (isHook(bValue)) {
                 diff = diff || {};
                 diff[aKey] = bValue;
            } else {
                var objectDiff = diffProps$1(aValue, bValue);
                if (objectDiff) {
                    diff = diff || {};
                    diff[aKey] = objectDiff;
                }
            }
        } else {
            diff = diff || {};
            diff[aKey] = bValue;
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {};
            diff[bKey] = b[bKey];
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

var isArray$3 = index$4;

var VPatch = vpatch;
var isVNode = isVnode;
var isVText = isVtext;
var isWidget = isWidget_1;
var isThunk = isThunk_1;
var handleThunk = handleThunk_1;

var diffProps = diffProps_1;

var diff_1$2 = diff$2;

function diff$2(a, b) {
    var patch = { a: a };
    walk(a, b, patch, 0);
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index];
    var applyClear = false;

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index);
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index);
            apply = patch[index];
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties);
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch));
                }
                apply = diffChildren(a, b, patch, apply, index);
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                applyClear = true;
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
            applyClear = true;
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
            applyClear = true;
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true;
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));
    }

    if (apply) {
        patch[index] = apply;
    }

    if (applyClear) {
        clearState(a, patch, index);
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children;
    var orderedSet = reorder(aChildren, b.children);
    var bChildren = orderedSet.children;

    var aLen = aChildren.length;
    var bLen = bChildren.length;
    var len = aLen > bLen ? aLen : bLen;

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i];
        var rightNode = bChildren[i];
        index += 1;

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode));
            }
        } else {
            walk(leftNode, rightNode, patch, index);
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count;
        }
    }

    if (orderedSet.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(
            VPatch.ORDER,
            a,
            orderedSet.moves
        ));
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index);
    destroyWidgets(vNode, patch, index);
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            );
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children;
        var len = children.length;
        for (var i = 0; i < len; i++) {
            var child = children[i];
            index += 1;

            destroyWidgets(child, patch, index);

            if (isVNode(child) && child.count) {
                index += child.count;
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index);
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b);
    var thunkPatch = diff$2(nodes.a, nodes.b);
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true
        }
    }

    return false
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            );
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children;
            var len = children.length;
            for (var i = 0; i < len; i++) {
                var child = children[i];
                index += 1;

                unhook(child, patch, index);

                if (isVNode(child) && child.count) {
                    index += child.count;
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index);
    }
}

function undefinedKeys(obj) {
    var result = {};

    for (var key in obj) {
        result[key] = undefined;
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {
    // O(M) time, O(M) memory
    var bChildIndex = keyIndex(bChildren);
    var bKeys = bChildIndex.keys;
    var bFree = bChildIndex.free;

    if (bFree.length === bChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(N) time, O(N) memory
    var aChildIndex = keyIndex(aChildren);
    var aKeys = aChildIndex.keys;
    var aFree = aChildIndex.free;

    if (aFree.length === aChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(MAX(N, M)) memory
    var newChildren = [];

    var freeIndex = 0;
    var freeCount = bFree.length;
    var deletedItems = 0;

    // Iterate through a and match a node in b
    // O(N) time,
    for (var i = 0 ; i < aChildren.length; i++) {
        var aItem = aChildren[i];
        var itemIndex;

        if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
                // Match up the old keys
                itemIndex = bKeys[aItem.key];
                newChildren.push(bChildren[itemIndex]);

            } else {
                // Remove old keyed items
                itemIndex = i - deletedItems++;
                newChildren.push(null);
            }
        } else {
            // Match the item in a with the next free item in b
            if (freeIndex < freeCount) {
                itemIndex = bFree[freeIndex++];
                newChildren.push(bChildren[itemIndex]);
            } else {
                // There are no free items in b to match with
                // the free items in a, so the extra free nodes
                // are deleted.
                itemIndex = i - deletedItems++;
                newChildren.push(null);
            }
        }
    }

    var lastFreeIndex = freeIndex >= bFree.length ?
        bChildren.length :
        bFree[freeIndex];

    // Iterate through b and append any new keys
    // O(M) time
    for (var j = 0; j < bChildren.length; j++) {
        var newItem = bChildren[j];

        if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
                // Add any new keyed items
                // We are adding new items to the end and then sorting them
                // in place. In future we should insert new items in place.
                newChildren.push(newItem);
            }
        } else if (j >= lastFreeIndex) {
            // Add any leftover non-keyed items
            newChildren.push(newItem);
        }
    }

    var simulate = newChildren.slice();
    var simulateIndex = 0;
    var removes = [];
    var inserts = [];
    var simulateItem;

    for (var k = 0; k < bChildren.length;) {
        var wantedItem = bChildren[k];
        simulateItem = simulate[simulateIndex];

        // remove items
        while (simulateItem === null && simulate.length) {
            removes.push(remove$3(simulate, simulateIndex, null));
            simulateItem = simulate[simulateIndex];
        }

        if (!simulateItem || simulateItem.key !== wantedItem.key) {
            // if we need a key in this position...
            if (wantedItem.key) {
                if (simulateItem && simulateItem.key) {
                    // if an insert doesn't put this key in place, it needs to move
                    if (bKeys[simulateItem.key] !== k + 1) {
                        removes.push(remove$3(simulate, simulateIndex, simulateItem.key));
                        simulateItem = simulate[simulateIndex];
                        // if the remove didn't put the wanted item in place, we need to insert it
                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
                            inserts.push({key: wantedItem.key, to: k});
                        }
                        // items are matching, so skip ahead
                        else {
                            simulateIndex++;
                        }
                    }
                    else {
                        inserts.push({key: wantedItem.key, to: k});
                    }
                }
                else {
                    inserts.push({key: wantedItem.key, to: k});
                }
                k++;
            }
            // a key in simulate has no matching wanted key, remove it
            else if (simulateItem && simulateItem.key) {
                removes.push(remove$3(simulate, simulateIndex, simulateItem.key));
            }
        }
        else {
            simulateIndex++;
            k++;
        }
    }

    // remove all the remaining nodes from simulate
    while(simulateIndex < simulate.length) {
        simulateItem = simulate[simulateIndex];
        removes.push(remove$3(simulate, simulateIndex, simulateItem && simulateItem.key));
    }

    // If the only moves we have are deletes then we can just
    // let the delete patch remove these items.
    if (removes.length === deletedItems && !inserts.length) {
        return {
            children: newChildren,
            moves: null
        }
    }

    return {
        children: newChildren,
        moves: {
            removes: removes,
            inserts: inserts
        }
    }
}

function remove$3(arr, index, key) {
    arr.splice(index, 1);

    return {
        from: index,
        key: key
    }
}

function keyIndex(children) {
    var keys = {};
    var free = [];
    var length = children.length;

    for (var i = 0; i < length; i++) {
        var child = children[i];

        if (child.key) {
            keys[child.key] = i;
        } else {
            free.push(i);
        }
    }

    return {
        keys: keys,     // A hash of key name to index
        free: free      // An array of unkeyed item indices
    }
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray$3(apply)) {
            apply.push(patch);
        } else {
            apply = [apply, patch];
        }

        return apply
    } else {
        return patch
    }
}

var diff$1 = diff_1$2;

var diff_1 = diff$1;

var slice$1 = Array.prototype.slice;

var index$10 = iterativelyWalk;

function iterativelyWalk(nodes, cb) {
    if (!('length' in nodes)) {
        nodes = [nodes];
    }
    
    nodes = slice$1.call(nodes);

    while(nodes.length) {
        var node = nodes.shift(),
            ret = cb(node);

        if (ret) {
            return ret
        }

        if (node.childNodes && node.childNodes.length) {
            nodes = slice$1.call(node.childNodes).concat(nodes);
        }
    }
}

var domComment = Comment$1;

function Comment$1(data, owner) {
    if (!(this instanceof Comment$1)) {
        return new Comment$1(data, owner)
    }

    this.data = data;
    this.nodeValue = data;
    this.length = data.length;
    this.ownerDocument = owner || null;
}

Comment$1.prototype.nodeType = 8;
Comment$1.prototype.nodeName = "#comment";

Comment$1.prototype.toString = function _Comment_toString() {
    return "[object Comment]"
};

var domText = DOMText$1;

function DOMText$1(value, owner) {
    if (!(this instanceof DOMText$1)) {
        return new DOMText$1(value)
    }

    this.data = value || "";
    this.length = this.data.length;
    this.ownerDocument = owner || null;
}

DOMText$1.prototype.type = "DOMTextNode";
DOMText$1.prototype.nodeType = 3;
DOMText$1.prototype.nodeName = "#text";

DOMText$1.prototype.toString = function _Text_toString() {
    return this.data
};

DOMText$1.prototype.replaceData = function replaceData(index, length, value) {
    var current = this.data;
    var left = current.substring(0, index);
    var right = current.substring(index + length, current.length);
    this.data = left + value + right;
    this.length = this.data.length;
};

var dispatchEvent_1 = dispatchEvent$2;

function dispatchEvent$2(ev) {
    var elem = this;
    var type = ev.type;

    if (!ev.target) {
        ev.target = elem;
    }

    if (!elem.listeners) {
        elem.listeners = {};
    }

    var listeners = elem.listeners[type];

    if (listeners) {
        return listeners.forEach(function (listener) {
            ev.currentTarget = elem;
            if (typeof listener === 'function') {
                listener(ev);
            } else {
                listener.handleEvent(ev);
            }
        })
    }

    if (elem.parentNode) {
        elem.parentNode.dispatchEvent(ev);
    }
}

var addEventListener_1 = addEventListener$2;

function addEventListener$2(type, listener) {
    var elem = this;

    if (!elem.listeners) {
        elem.listeners = {};
    }

    if (!elem.listeners[type]) {
        elem.listeners[type] = [];
    }

    if (elem.listeners[type].indexOf(listener) === -1) {
        elem.listeners[type].push(listener);
    }
}

var removeEventListener_1 = removeEventListener$2;

function removeEventListener$2(type, listener) {
    var elem = this;

    if (!elem.listeners) {
        return
    }

    if (!elem.listeners[type]) {
        return
    }

    var list = elem.listeners[type];
    var index = list.indexOf(listener);
    if (index !== -1) {
        list.splice(index, 1);
    }
}

var serialize = serializeNode$1;

var voidElements = ["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"];

function serializeNode$1(node) {
    switch (node.nodeType) {
        case 3:
            return escapeText(node.data)
        case 8:
            return "<!--" + node.data + "-->"
        default:
            return serializeElement(node)
    }
}

function serializeElement(elem) {
    var strings = [];

    var tagname = elem.tagName;

    if (elem.namespaceURI === "http://www.w3.org/1999/xhtml") {
        tagname = tagname.toLowerCase();
    }

    strings.push("<" + tagname + properties(elem) + datasetify(elem));

    if (voidElements.indexOf(tagname) > -1) {
        strings.push(" />");
    } else {
        strings.push(">");

        if (elem.childNodes.length) {
            strings.push.apply(strings, elem.childNodes.map(serializeNode$1));
        } else if (elem.textContent || elem.innerText) {
            strings.push(escapeText(elem.textContent || elem.innerText));
        } else if (elem.innerHTML) {
            strings.push(elem.innerHTML);
        }

        strings.push("</" + tagname + ">");
    }

    return strings.join("")
}

function isProperty(elem, key) {
    var type = typeof elem[key];

    if (key === "style" && Object.keys(elem.style).length > 0) {
      return true
    }

    return elem.hasOwnProperty(key) &&
        (type === "string" || type === "boolean" || type === "number") &&
        key !== "nodeName" && key !== "className" && key !== "tagName" &&
        key !== "textContent" && key !== "innerText" && key !== "namespaceURI" &&  key !== "innerHTML"
}

function stylify(styles) {
    if (typeof styles === 'string') return styles
    var attr = "";
    Object.keys(styles).forEach(function (key) {
        var value = styles[key];
        key = key.replace(/[A-Z]/g, function(c) {
            return "-" + c.toLowerCase();
        });
        attr += key + ":" + value + ";";
    });
    return attr
}

function datasetify(elem) {
    var ds = elem.dataset;
    var props = [];

    for (var key in ds) {
        props.push({ name: "data-" + key, value: ds[key] });
    }

    return props.length ? stringify(props) : ""
}

function stringify(list) {
    var attributes = [];
    list.forEach(function (tuple) {
        var name = tuple.name;
        var value = tuple.value;

        if (name === "style") {
            value = stylify(value);
        }

        attributes.push(name + "=" + "\"" + escapeAttributeValue(value) + "\"");
    });

    return attributes.length ? " " + attributes.join(" ") : ""
}

function properties(elem) {
    var props = [];
    for (var key in elem) {
        if (isProperty(elem, key)) {
            props.push({ name: key, value: elem[key] });
        }
    }

    for (var ns in elem._attributes) {
      for (var attribute in elem._attributes[ns]) {
        var prop = elem._attributes[ns][attribute];
        var name = (prop.prefix ? prop.prefix + ":" : "") + attribute;
        props.push({ name: name, value: prop.value });
      }
    }

    if (elem.className) {
        props.push({ name: "class", value: elem.className });
    }

    return props.length ? stringify(props) : ""
}

function escapeText(s) {
    var str = '';

    if (typeof(s) === 'string') { 
        str = s; 
    } else if (s) {
        str = s.toString();
    }

    return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
}

function escapeAttributeValue(str) {
    return escapeText(str).replace(/"/g, "&quot;")
}

var domWalk$1 = index$10;
var dispatchEvent$1 = dispatchEvent_1;
var addEventListener$1 = addEventListener_1;
var removeEventListener$1 = removeEventListener_1;
var serializeNode = serialize;

var htmlns = "http://www.w3.org/1999/xhtml";

var domElement = DOMElement$1;

function DOMElement$1(tagName, owner, namespace) {
    if (!(this instanceof DOMElement$1)) {
        return new DOMElement$1(tagName)
    }

    var ns = namespace === undefined ? htmlns : (namespace || null);

    this.tagName = ns === htmlns ? String(tagName).toUpperCase() : tagName;
    this.nodeName = this.tagName;
    this.className = "";
    this.dataset = {};
    this.childNodes = [];
    this.parentNode = null;
    this.style = {};
    this.ownerDocument = owner || null;
    this.namespaceURI = ns;
    this._attributes = {};

    if (this.tagName === 'INPUT') {
      this.type = 'text';
    }
}

DOMElement$1.prototype.type = "DOMElement";
DOMElement$1.prototype.nodeType = 1;

DOMElement$1.prototype.appendChild = function _Element_appendChild(child) {
    if (child.parentNode) {
        child.parentNode.removeChild(child);
    }

    this.childNodes.push(child);
    child.parentNode = this;

    return child
};

DOMElement$1.prototype.replaceChild =
    function _Element_replaceChild(elem, needle) {
        // TODO: Throw NotFoundError if needle.parentNode !== this

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }

        var index = this.childNodes.indexOf(needle);

        needle.parentNode = null;
        this.childNodes[index] = elem;
        elem.parentNode = this;

        return needle
    };

DOMElement$1.prototype.removeChild = function _Element_removeChild(elem) {
    // TODO: Throw NotFoundError if elem.parentNode !== this

    var index = this.childNodes.indexOf(elem);
    this.childNodes.splice(index, 1);

    elem.parentNode = null;
    return elem
};

DOMElement$1.prototype.insertBefore =
    function _Element_insertBefore(elem, needle) {
        // TODO: Throw NotFoundError if referenceElement is a dom node
        // and parentNode !== this

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }

        var index = needle === null || needle === undefined ?
            -1 :
            this.childNodes.indexOf(needle);

        if (index > -1) {
            this.childNodes.splice(index, 0, elem);
        } else {
            this.childNodes.push(elem);
        }

        elem.parentNode = this;
        return elem
    };

DOMElement$1.prototype.setAttributeNS =
    function _Element_setAttributeNS(namespace, name, value) {
        var prefix = null;
        var localName = name;
        var colonPosition = name.indexOf(":");
        if (colonPosition > -1) {
            prefix = name.substr(0, colonPosition);
            localName = name.substr(colonPosition + 1);
        }
        if (this.tagName === 'INPUT' && name === 'type') {
          this.type = value;
        }
        else {
          var attributes = this._attributes[namespace] || (this._attributes[namespace] = {});
          attributes[localName] = {value: value, prefix: prefix};
        }
    };

DOMElement$1.prototype.getAttributeNS =
    function _Element_getAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        var value = attributes && attributes[name] && attributes[name].value;
        if (this.tagName === 'INPUT' && name === 'type') {
          return this.type;
        }
        if (typeof value !== "string") {
            return null
        }
        return value
    };

DOMElement$1.prototype.removeAttributeNS =
    function _Element_removeAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        if (attributes) {
            delete attributes[name];
        }
    };

DOMElement$1.prototype.hasAttributeNS =
    function _Element_hasAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        return !!attributes && name in attributes;
    };

DOMElement$1.prototype.setAttribute = function _Element_setAttribute(name, value) {
    return this.setAttributeNS(null, name, value)
};

DOMElement$1.prototype.getAttribute = function _Element_getAttribute(name) {
    return this.getAttributeNS(null, name)
};

DOMElement$1.prototype.removeAttribute = function _Element_removeAttribute(name) {
    return this.removeAttributeNS(null, name)
};

DOMElement$1.prototype.hasAttribute = function _Element_hasAttribute(name) {
    return this.hasAttributeNS(null, name)
};

DOMElement$1.prototype.removeEventListener = removeEventListener$1;
DOMElement$1.prototype.addEventListener = addEventListener$1;
DOMElement$1.prototype.dispatchEvent = dispatchEvent$1;

// Un-implemented
DOMElement$1.prototype.focus = function _Element_focus() {
    return void 0
};

DOMElement$1.prototype.toString = function _Element_toString() {
    return serializeNode(this)
};

DOMElement$1.prototype.getElementsByClassName = function _Element_getElementsByClassName(classNames) {
    var classes = classNames.split(" ");
    var elems = [];

    domWalk$1(this, function (node) {
        if (node.nodeType === 1) {
            var nodeClassName = node.className || "";
            var nodeClasses = nodeClassName.split(" ");

            if (classes.every(function (item) {
                return nodeClasses.indexOf(item) !== -1
            })) {
                elems.push(node);
            }
        }
    });

    return elems
};

DOMElement$1.prototype.getElementsByTagName = function _Element_getElementsByTagName(tagName) {
    tagName = tagName.toLowerCase();
    var elems = [];

    domWalk$1(this.childNodes, function (node) {
        if (node.nodeType === 1 && (tagName === '*' || node.tagName.toLowerCase() === tagName)) {
            elems.push(node);
        }
    });

    return elems
};

DOMElement$1.prototype.contains = function _Element_contains(element) {
    return domWalk$1(this, function (node) {
        return element === node
    }) || false
};

var DOMElement$2 = domElement;

var domFragment = DocumentFragment$1;

function DocumentFragment$1(owner) {
    if (!(this instanceof DocumentFragment$1)) {
        return new DocumentFragment$1()
    }

    this.childNodes = [];
    this.parentNode = null;
    this.ownerDocument = owner || null;
}

DocumentFragment$1.prototype.type = "DocumentFragment";
DocumentFragment$1.prototype.nodeType = 11;
DocumentFragment$1.prototype.nodeName = "#document-fragment";

DocumentFragment$1.prototype.appendChild  = DOMElement$2.prototype.appendChild;
DocumentFragment$1.prototype.replaceChild = DOMElement$2.prototype.replaceChild;
DocumentFragment$1.prototype.removeChild  = DOMElement$2.prototype.removeChild;

DocumentFragment$1.prototype.toString =
    function _DocumentFragment_toString() {
        return this.childNodes.map(function (node) {
            return String(node)
        }).join("")
    };

var event$1 = Event$1;

function Event$1(family) {}

Event$1.prototype.initEvent = function _Event_initEvent(type, bubbles, cancelable) {
    this.type = type;
    this.bubbles = bubbles;
    this.cancelable = cancelable;
};

Event$1.prototype.preventDefault = function _Event_preventDefault() {
    
};

var domWalk = index$10;

var Comment = domComment;
var DOMText = domText;
var DOMElement = domElement;
var DocumentFragment = domFragment;
var Event = event$1;
var dispatchEvent = dispatchEvent_1;
var addEventListener = addEventListener_1;
var removeEventListener = removeEventListener_1;

var document$3 = Document$1;

function Document$1() {
    if (!(this instanceof Document$1)) {
        return new Document$1();
    }

    this.head = this.createElement("head");
    this.body = this.createElement("body");
    this.documentElement = this.createElement("html");
    this.documentElement.appendChild(this.head);
    this.documentElement.appendChild(this.body);
    this.childNodes = [this.documentElement];
    this.nodeType = 9;
}

var proto$1 = Document$1.prototype;
proto$1.createTextNode = function createTextNode(value) {
    return new DOMText(value, this)
};

proto$1.createElementNS = function createElementNS(namespace, tagName) {
    var ns = namespace === null ? null : String(namespace);
    return new DOMElement(tagName, this, ns)
};

proto$1.createElement = function createElement(tagName) {
    return new DOMElement(tagName, this)
};

proto$1.createDocumentFragment = function createDocumentFragment() {
    return new DocumentFragment(this)
};

proto$1.createEvent = function createEvent(family) {
    return new Event(family)
};

proto$1.createComment = function createComment(data) {
    return new Comment(data, this)
};

proto$1.getElementById = function getElementById(id) {
    id = String(id);

    var result = domWalk(this.childNodes, function (node) {
        if (String(node.id) === id) {
            return node
        }
    });

    return result || null
};

proto$1.getElementsByClassName = DOMElement.prototype.getElementsByClassName;
proto$1.getElementsByTagName = DOMElement.prototype.getElementsByTagName;
proto$1.contains = DOMElement.prototype.contains;

proto$1.removeEventListener = removeEventListener;
proto$1.addEventListener = addEventListener;
proto$1.dispatchEvent = dispatchEvent;

var Document = document$3;

var index$8 = new Document();

var document_1 = createCommonjsModule(function (module) {
var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
    typeof window !== 'undefined' ? window : {};
var minDoc = index$8;

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}
});

var isObject$6 = index$6;
var isHook$2 = isVhook;

var applyProperties_1 = applyProperties$1;

function applyProperties$1(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName];

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook$2(propValue)) {
            removeProperty(node, propName, propValue, previous);
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined);
            }
        } else {
            if (isObject$6(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue;
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName];

        if (!isHook$2(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName);
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = "";
                }
            } else if (typeof previousValue === "string") {
                node[propName] = "";
            } else {
                node[propName] = null;
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue);
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined;

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName];

            if (attrValue === undefined) {
                node.removeAttribute(attrName);
            } else {
                node.setAttribute(attrName, attrValue);
            }
        }

        return
    }

    if(previousValue && isObject$6(previousValue) &&
        getPrototype$1(previousValue) !== getPrototype$1(propValue)) {
        node[propName] = propValue;
        return
    }

    if (!isObject$6(node[propName])) {
        node[propName] = {};
    }

    var replacer = propName === "style" ? "" : undefined;

    for (var k in propValue) {
        var value = propValue[k];
        node[propName][k] = (value === undefined) ? replacer : value;
    }
}

function getPrototype$1(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

var document$5 = document_1;

var applyProperties = applyProperties_1;

var isVNode$2 = isVnode;
var isVText$2 = isVtext;
var isWidget$3 = isWidget_1;
var handleThunk$2 = handleThunk_1;

var createElement_1 = createElement;

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document$5 : document$5;
    var warn = opts ? opts.warn : null;

    vnode = handleThunk$2(vnode).a;

    if (isWidget$3(vnode)) {
        return vnode.init()
    } else if (isVText$2(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode$2(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode);
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName);

    var props = vnode.properties;
    applyProperties(node, props);

    var children = vnode.children;

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts);
        if (childNode) {
            node.appendChild(childNode);
        }
    }

    return node
}

// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {};

var domIndex_1 = domIndex$1;

function domIndex$1(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending);
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {};


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode;
        }

        var vChildren = tree.children;

        if (vChildren) {

            var childNodes = rootNode.childNodes;

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1;

                var vChild = vChildren[i] || noChild;
                var nextIndex = rootIndex + (vChild.count || 0);

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex);
                }

                rootIndex = nextIndex;
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0;
    var maxIndex = indices.length - 1;
    var currentIndex;
    var currentItem;

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0;
        currentItem = indices[currentIndex];

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1;
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1;
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

var isWidget$5 = isWidget_1;

var updateWidget_1 = updateWidget$1;

function updateWidget$1(a, b) {
    if (isWidget$5(a) && isWidget$5(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

var applyProperties$2 = applyProperties_1;

var isWidget$4 = isWidget_1;
var VPatch$1 = vpatch;

var updateWidget = updateWidget_1;

var patchOp$1 = applyPatch$1;

function applyPatch$1(vpatch$$1, domNode, renderOptions) {
    var type = vpatch$$1.type;
    var vNode = vpatch$$1.vNode;
    var patch = vpatch$$1.patch;

    switch (type) {
        case VPatch$1.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch$1.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch$1.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch$1.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch$1.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch$1.ORDER:
            reorderChildren(domNode, patch);
            return domNode
        case VPatch$1.PROPS:
            applyProperties$2(domNode, patch, vNode.properties);
            return domNode
        case VPatch$1.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode;

    if (parentNode) {
        parentNode.removeChild(domNode);
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = renderOptions.render(vNode, renderOptions);

    if (parentNode) {
        parentNode.appendChild(newNode);
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode;

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text);
        newNode = domNode;
    } else {
        var parentNode = domNode.parentNode;
        newNode = renderOptions.render(vText, renderOptions);

        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode);
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget);
    var newNode;

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode;
    } else {
        newNode = renderOptions.render(widget, renderOptions);
    }

    var parentNode = domNode.parentNode;

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode);
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode);
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode;
    var newNode = renderOptions.render(vNode, renderOptions);

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode);
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget$4(w)) {
        w.destroy(domNode);
    }
}

function reorderChildren(domNode, moves) {
    var childNodes = domNode.childNodes;
    var keyMap = {};
    var node;
    var remove;
    var insert;

    for (var i = 0; i < moves.removes.length; i++) {
        remove = moves.removes[i];
        node = childNodes[remove.from];
        if (remove.key) {
            keyMap[remove.key] = node;
        }
        domNode.removeChild(node);
    }

    var length = childNodes.length;
    for (var j = 0; j < moves.inserts.length; j++) {
        insert = moves.inserts[j];
        node = keyMap[insert.key];
        // this is the weirdest bug i've ever seen in webkit
        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to]);
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        oldRoot.parentNode.replaceChild(newRoot, oldRoot);
    }

    return newRoot;
}

var document$2 = document_1;
var isArray$5 = index$4;

var render$1 = createElement_1;
var domIndex = domIndex_1;
var patchOp = patchOp$1;
var patch_1$2 = patch$2;

function patch$2(rootNode, patches, renderOptions) {
    renderOptions = renderOptions || {};
    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch$2
        ? renderOptions.patch
        : patchRecursive;
    renderOptions.render = renderOptions.render || render$1;

    return renderOptions.patch(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches);

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices);
    var ownerDocument = rootNode.ownerDocument;

    if (!renderOptions.document && ownerDocument !== document$2) {
        renderOptions.document = ownerDocument;
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i];
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions);
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode;

    if (isArray$5(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions);

            if (domNode === rootNode) {
                rootNode = newNode;
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions);

        if (domNode === rootNode) {
            rootNode = newNode;
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = [];

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key));
        }
    }

    return indices
}

var patch$1 = patch_1$2;

var patch_1 = patch$1;

var version$6 = version$2;
var isVNode$4 = isVnode;
var isWidget$7 = isWidget_1;
var isThunk$3 = isThunk_1;
var isVHook = isVhook;

var vnode = VirtualNode;

var noProperties = {};
var noChildren = [];

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName;
    this.properties = properties || noProperties;
    this.children = children || noChildren;
    this.key = key != null ? String(key) : undefined;
    this.namespace = (typeof namespace === "string") ? namespace : null;

    var count = (children && children.length) || 0;
    var descendants = 0;
    var hasWidgets = false;
    var hasThunks = false;
    var descendantHooks = false;
    var hooks;

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName];
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {};
                }

                hooks[propName] = property;
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i];
        if (isVNode$4(child)) {
            descendants += child.count || 0;

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true;
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true;
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true;
            }
        } else if (!hasWidgets && isWidget$7(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true;
            }
        } else if (!hasThunks && isThunk$3(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants;
    this.hasWidgets = hasWidgets;
    this.hasThunks = hasThunks;
    this.hooks = hooks;
    this.descendantHooks = descendantHooks;
}

VirtualNode.prototype.version = version$6;
VirtualNode.prototype.type = "VirtualNode";

var version$7 = version$2;

var vtext = VirtualText;

function VirtualText(text) {
    this.text = String(text);
}

VirtualText.prototype.version = version$7;
VirtualText.prototype.type = "VirtualText";

/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
var index$14 = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

var split$2 = index$14;

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

var parseTag_1 = parseTag$1;

function parseTag$1(tag, props) {
    if (!tag) {
        return 'DIV';
    }

    var noId = !(props.hasOwnProperty('id'));

    var tagParts = split$2(tag, classIdSplit);
    var tagName = null;

    if (notClassId.test(tagParts[1])) {
        tagName = 'DIV';
    }

    var classes, part, type, i;

    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i];

        if (!part) {
            continue;
        }

        type = part.charAt(0);

        if (!tagName) {
            tagName = part;
        } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
        } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className);
        }

        props.className = classes.join(' ');
    }

    return props.namespace ? tagName : tagName.toUpperCase();
}

var softSetHook$1 = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

/*global window, global*/

var root = typeof window !== 'undefined' ?
    window : typeof commonjsGlobal !== 'undefined' ?
    commonjsGlobal : {};

var index$18 = Individual$1;

function Individual$1(key, value) {
    if (key in root) {
        return root[key];
    }

    root[key] = value;

    return value;
}

var Individual = index$18;

var oneVersion = OneVersion;

function OneVersion(moduleName, version, defaultValue) {
    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
    var enforceKey = key + '_ENFORCE_SINGLETON';

    var versionValue = Individual(enforceKey, version);

    if (versionValue !== version) {
        throw new Error('Can only have one copy of ' +
            moduleName + '.\n' +
            'You already have version ' + versionValue +
            ' installed.\n' +
            'This means you cannot install version ' + version);
    }

    return Individual(key, defaultValue);
}

var OneVersionConstraint = oneVersion;

var MY_VERSION = '7';
OneVersionConstraint('ev-store', MY_VERSION);

var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

var index$16 = EvStore$1;

function EvStore$1(elem) {
    var hash = elem[hashKey];

    if (!hash) {
        hash = elem[hashKey] = {};
    }

    return hash;
}

var EvStore = index$16;

var evHook$1 = EvHook;

function EvHook(value) {
    if (!(this instanceof EvHook)) {
        return new EvHook(value);
    }

    this.value = value;
}

EvHook.prototype.hook = function (node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = this.value;
};

EvHook.prototype.unhook = function(node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = undefined;
};

var isArray$6 = index$4;

var VNode$1 = vnode;
var VText$1 = vtext;
var isVNode$3 = isVnode;
var isVText$3 = isVtext;
var isWidget$6 = isWidget_1;
var isHook$3 = isVhook;
var isVThunk = isThunk_1;

var parseTag = parseTag_1;
var softSetHook = softSetHook$1;
var evHook = evHook$1;

var index$12 = h$3;

function h$3(tagName, properties, children) {
    var childNodes = [];
    var tag, props, key, namespace;

    if (!children && isChildren(properties)) {
        children = properties;
        props = {};
    }

    props = props || properties || {};
    tag = parseTag(tagName, props);

    // support keys
    if (props.hasOwnProperty('key')) {
        key = props.key;
        props.key = undefined;
    }

    // support namespace
    if (props.hasOwnProperty('namespace')) {
        namespace = props.namespace;
        props.namespace = undefined;
    }

    // fix cursor bug
    if (tag === 'INPUT' &&
        !namespace &&
        props.hasOwnProperty('value') &&
        props.value !== undefined &&
        !isHook$3(props.value)
    ) {
        props.value = softSetHook(props.value);
    }

    transformProperties(props);

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props);
    }


    return new VNode$1(tag, props, childNodes, key, namespace);
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === 'string') {
        childNodes.push(new VText$1(c));
    } else if (typeof c === 'number') {
        childNodes.push(new VText$1(String(c)));
    } else if (isChild(c)) {
        childNodes.push(c);
    } else if (isArray$6(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
        }
    } else if (c === null || c === undefined) {
        return;
    } else {
        throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
                tagName: tag,
                properties: props
            }
        });
    }
}

function transformProperties(props) {
    for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
            var value = props[propName];

            if (isHook$3(value)) {
                continue;
            }

            if (propName.substr(0, 3) === 'ev-') {
                // add ev-foo support
                props[propName] = evHook(value);
            }
        }
    }
}

function isChild(x) {
    return isVNode$3(x) || isVText$3(x) || isWidget$6(x) || isVThunk(x);
}

function isChildren(x) {
    return typeof x === 'string' || isArray$6(x) || isChild(x);
}

function UnexpectedVirtualElement(data) {
    var err = new Error();

    err.type = 'virtual-hyperscript.unexpected.virtual-element';
    err.message = 'Unexpected virtual child passed to h().\n' +
        'Expected a VNode / Vthunk / VWidget / string but:\n' +
        'got:\n' +
        errorString(data.foreignObject) +
        '.\n' +
        'The parent vnode is:\n' +
        errorString(data.parentVnode);
        '\n' +
        'Suggested fix: change your `h(..., [ ... ])` callsite.';
    err.foreignObject = data.foreignObject;
    err.parentVnode = data.parentVnode;

    return err;
}

function errorString(obj) {
    try {
        return JSON.stringify(obj, null, '    ');
    } catch (e) {
        return String(obj);
    }
}

var h$2 = index$12;

var h_1 = h$2;

var createElement$1 = createElement_1;

var createElement_1$2 = createElement$1;

var diff = diff_1;
var patch = patch_1;
var h$1 = h_1;
var create$7 = createElement_1$2;
var VNode = vnode;
var VText = vtext;

var index$2 = {
    diff: diff,
    patch: patch,
    h: h$1,
    create: create$7,
    VNode: VNode,
    VText: VText
};

var h$1 = index$2.h;
var create$7 = index$2.create;
var diff = index$2.diff;
var patch = index$2.patch;

var Observer = (function () {
    function Observer(onNext, onError, onCompleted) {
        this.OnNext = onNext;
        this.OnError = onError || (function (e) { });
        this.OnCompleted = onCompleted || function () { };
    }
    Observer.prototype[_Symbol.reflection] = function () {
        return { interfaces: ["System.IObserver"] };
    };
    return Observer;
}());

function add$5(callback, source) {
    source.Subscribe(new Observer(callback));
}

var Event$2 = (function () {
    function Event(_subscriber, delegates) {
        this._subscriber = _subscriber;
        this.delegates = delegates || new Array();
    }
    Event.prototype.Add = function (f) {
        this._addHandler(f);
    };
    Object.defineProperty(Event.prototype, "Publish", {
        get: function () {
            return this;
        },
        enumerable: true,
        configurable: true
    });
    Event.prototype.Trigger = function (value) {
        iterate$1(function (f) { return f(value); }, this.delegates);
    };
    Event.prototype._addHandler = function (f) {
        this.delegates.push(f);
    };
    Event.prototype._removeHandler = function (f) {
        var index = this.delegates.indexOf(f);
        if (index > -1)
            this.delegates.splice(index, 1);
    };
    Event.prototype.AddHandler = function (handler) {
        if (this._dotnetDelegates == null) {
            this._dotnetDelegates = new Map();
        }
        var f = function (x) { handler(null, x); };
        this._dotnetDelegates.set(handler, f);
        this._addHandler(f);
    };
    Event.prototype.RemoveHandler = function (handler) {
        if (this._dotnetDelegates != null) {
            var f = this._dotnetDelegates.get(handler);
            if (f != null) {
                this._dotnetDelegates.delete(handler);
                this._removeHandler(f);
            }
        }
    };
    Event.prototype._subscribeFromObserver = function (observer) {
        var _this = this;
        if (this._subscriber)
            return this._subscriber(observer);
        var callback = observer.OnNext;
        this._addHandler(callback);
        return createDisposable(function () { return _this._removeHandler(callback); });
    };
    Event.prototype._subscribeFromCallback = function (callback) {
        var _this = this;
        this._addHandler(callback);
        return createDisposable(function () { return _this._removeHandler(callback); });
    };
    Event.prototype.Subscribe = function (arg) {
        return typeof arg == "function"
            ? this._subscribeFromCallback(arg)
            : this._subscribeFromObserver(arg);
    };
    return Event;
}());

var DomAttribute = function () {
  function DomAttribute(caseName, fields) {
    _classCallCheck(this, DomAttribute);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(DomAttribute, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Html.DomAttribute",
        interfaces: ["FSharpUnion"],
        cases: {
          Attribute: ["string"],
          Event: ["function"],
          Property: [Any]
        }
      };
    }
  }]);

  return DomAttribute;
}();
setType("TheGamma.Html.DomAttribute", DomAttribute);
var DomNode = function () {
  function DomNode(caseName, fields) {
    _classCallCheck(this, DomNode);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(DomNode, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Html.DomNode",
        interfaces: ["FSharpUnion"],
        cases: {
          Delayed: ["string", DomNode, "function"],
          Element: ["string", "string", FableArray(Tuple(["string", DomAttribute])), FableArray(DomNode), Option("function")],
          Part: ["function"],
          Text: ["string"]
        }
      };
    }
  }]);

  return DomNode;
}();
setType("TheGamma.Html.DomNode", DomNode);
function createTree(ns, tag, args, children) {
  var attrs = [];
  var props = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(args), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var forLoopVar = _step.value;
      var matchValue = [forLoopVar[0], forLoopVar[1]];

      if (matchValue[1].Case === "Property") {
        var o = matchValue[1].Fields[0];
        props.push([matchValue[0], o]);
      } else if (matchValue[1].Case === "Event") {
        (function () {
          var f = matchValue[1].Fields[0];
          props.push(["on" + matchValue[0], function (o_1) {
            f(o_1["target"])(event);
          }]);
        })();
      } else {
        var v = matchValue[1].Fields[0];
        attrs.push([matchValue[0], v]);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var attrs_1 = createObj(attrs);
  var ns_1 = (ns == null ? true : ns === "") ? new List$2() : ofArray([["namespace", ns]]);
  var props_1 = createObj(append$1(append$$1(ns_1, ofArray([["attributes", attrs_1]])), props));
  var elem = h$1(tag, props_1, children);
  return elem;
}
var counter = 0;
function renderVirtual(node) {
  if (node.Case === "Element") {
    if (node.Fields[4] == null) {
      return createTree(node.Fields[0], node.Fields[1], node.Fields[2], node.Fields[3].map(function (node_1) {
        return renderVirtual(node_1);
      }));
    } else {
      throw new Error("renderVirtual: Does not support elements with after-render handlers");
    }
  } else if (node.Case === "Delayed") {
    var _ret2 = function () {
      counter = counter + 1;
      var id = fsFormat("delayed_%d")(function (x) {
        return x;
      })(counter);

      var waitForAdded = function waitForAdded(n) {
        return function (el) {
          if (el.parentElement != null) {
            el.dataset.renderedSymbol = node.Fields[0];
            el.id = id;
            node.Fields[2](id);
          } else if (n > 0) {
            window.setTimeout(function () {
              waitForAdded(n - 1)(el);
            }, 1);
          } else {
            Log.error("html", "Delayed element was not created in time");
          }
        };
      };

      var Hook = function Hook() {};

      Hook.prototype.hook = function (node_2, propertyName, previousValue) {
        if (node_2.dataset.renderedSymbol !== node.Fields[0]) {
          waitForAdded(10)(node_2);
        }
      };

      var h$$1 = new Hook();
      return {
        v: createTree(null, "div", ofArray([["renderhk", new DomAttribute("Property", [h$$1])]]), [renderVirtual(node.Fields[1])])
      };
    }();

    if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
  } else if (node.Case === "Part") {
    throw new Error("renderVirtual: Does not support parts");
  } else {
    return node.Fields[0];
  }
}
function render(node) {
  if (node.Case === "Delayed") {
    var _ret3 = function () {
      counter = counter + 1;
      var el = document.createElement("div");
      el.id = fsFormat("delayed_%d")(function (x) {
        return x;
      })(counter);
      return {
        v: [el, function () {
          node.Fields[2](el.id);
        }]
      };
    }();

    if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
  } else if (node.Case === "Part") {
    var _ret4 = function () {
      var el_1 = document.createElement("div");
      return {
        v: [el_1, function () {
          node.Fields[0](el_1);
        }]
      };
    }();

    if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
  } else if (node.Case === "Element") {
    var _ret5 = function () {
      var el_2 = (node.Fields[0] == null ? true : node.Fields[0] === "") ? document.createElement(node.Fields[1]) : document.createElementNS(node.Fields[0], node.Fields[1]);
      var rc = node.Fields[3].map(function (node_1) {
        return render(node_1);
      });

      for (var idx = 0; idx <= rc.length - 1; idx++) {
        var forLoopVar = rc[idx];
        el_2.appendChild(forLoopVar[0]);
      }

      var _loop = function _loop(idx_1) {
        var forLoopVar_1 = node.Fields[2][idx_1];

        if (forLoopVar_1[1].Case === "Attribute") {
          el_2.setAttribute(forLoopVar_1[0], forLoopVar_1[1].Fields[0]);
        } else if (forLoopVar_1[1].Case === "Event") {
          el_2.addEventListener(forLoopVar_1[0], function (delegateArg0) {
            forLoopVar_1[1].Fields[0](el_2)(delegateArg0);
          });
        } else {
          el_2[forLoopVar_1[0]] = forLoopVar_1[1].Fields[0];
        }
      };

      for (var idx_1 = 0; idx_1 <= node.Fields[2].length - 1; idx_1++) {
        _loop(idx_1);
      }

      var onRender = function onRender() {
        for (var idx_2 = 0; idx_2 <= rc.length - 1; idx_2++) {
          var forLoopVar_2 = rc[idx_2];
          forLoopVar_2[1](null);
        }

        iterate$1(function (f) {
          f(el_2);
        }, defaultArg(node.Fields[4], [], function (x) {
          return [x];
        }));
      };

      return {
        v: [el_2, onRender]
      };
    }();

    if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
  } else {
    return [document.createTextNode(node.Fields[0]), function () {}];
  }
}
function renderTo(node, dom) {
  while (node.lastChild != null) {
    node.removeChild(node.lastChild);
  }

  var patternInput = render(dom);
  node.appendChild(patternInput[0]);
  patternInput[1](null);
}
function text(s) {
  return new DomNode("Text", [s]);
}
function op_EqualsGreater(k, v) {
  return [k, new DomAttribute("Attribute", [v])];
}
function op_EqualsBangGreater(k, f) {
  return [k, new DomAttribute("Event", [f])];
}
var El = function () {
  _createClass(El, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Html.El",
        properties: {
          Namespace: "string"
        }
      };
    }
  }]);

  function El(ns) {
    _classCallCheck(this, El);

    this.ns = ns;
  }

  _createClass(El, [{
    key: "delayed",
    value: function (sym, body, f) {
      return new DomNode("Delayed", [sym, body, f]);
    }
  }, {
    key: "part",
    value: function (initial, fold$$1) {
      var evt = new Event$2();
      var state = initial;
      var container = null;
      var renderer = null;

      var render_1 = function render_1() {
        var matchValue = [container, renderer];
        var $var4 = matchValue[0] != null ? matchValue[1] != null ? [0, matchValue[0], matchValue[1]] : [1] : [1];

        switch ($var4[0]) {
          case 0:
            (function (dom) {
              renderTo($var4[1], dom);
            })($var4[2](state));

            break;

          case 1:
            break;
        }
      };

      add$5(function (e) {
        state = fold$$1(state)(e);
        render_1(null);
      }, evt.Publish);
      return [function (arg00) {
        evt.Trigger(arg00);
      }, function (r) {
        renderer = r;
        return new DomNode("Part", [function (el) {
          container = el;
          render_1(null);
        }]);
      }];
    }
  }, {
    key: "Namespace",
    get: function () {
      return this.ns;
    }
  }], [{
    key: "op_Dynamic",
    value: function (el, n) {
      return function (a) {
        return function (b) {
          var patternInput = n !== "chosen" ? [n, null] : ["select", function (el_1) {
            jQuery(el_1).chosen();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _getIterator(a), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var forLoopVar = _step2.value;

                if (forLoopVar[1].Case === "Event") {
                  jQuery(el_1).on(forLoopVar[0], function () {
                    forLoopVar[1].Fields[0](el_1)(event);
                  });
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }];
          return new DomNode("Element", [el.Namespace, patternInput[0], _Array$from(a), _Array$from(b), patternInput[1]]);
        };
      };
    }
  }]);

  return El;
}();
setType("TheGamma.Html.El", El);
var h$$1 = new El(null);
var s = new El("http://www.w3.org/2000/svg");

var html = function () {
  function html() {
    _classCallCheck(this, html);
  }

  _createClass(html, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.html",
        properties: {}
      };
    }
  }], [{
    key: "img",
    value: function (url) {
      return function (arg0) {
        return function (arg1) {
          return El.op_Dynamic(arg0, arg1);
        };
      }(h$$1)("img")(ofArray([op_EqualsGreater("src", url)]))(new List$2());
    }
  }]);

  return html;
}();
setType("TheGamma.html", html);
var table = function () {
  function table(data, showKey, hiddenColumns, addedColumns) {
    _classCallCheck(this, table);

    this.data = data;
    this.showKey = showKey;
    this.hiddenColumns = hiddenColumns;
    this.addedColumns = addedColumns;
  }

  _createClass(table, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.table",
        interfaces: ["FSharpRecord"],
        properties: {
          data: makeGeneric(series, {
            k: GenericParam("k"),
            v: GenericParam("v")
          }),
          showKey: Option("boolean"),
          hiddenColumns: makeGeneric(FableSet, {
            T: "string"
          }),
          addedColumns: makeGeneric(List$2, {
            T: Tuple(["string", "function"])
          })
        }
      };
    }
  }, {
    key: "set",
    value: function (title, showKey) {
      var data = this.data.set(this.data.data, null, null, title != null ? title : this.data.seriesName);
      return new table(data, showKey == null ? this.showKey : showKey, this.hiddenColumns, this.addedColumns);
    }
  }, {
    key: "hideColumns",
    value: function (names) {
      var hiddenColumns = create$2(names, new GenericComparer(compare));

      return new table(this.data, this.showKey, hiddenColumns, this.addedColumns);
    }
  }, {
    key: "addColumn",
    value: function (name, f) {
      var addedColumns = new List$2([name, f], this.addedColumns);
      return new table(this.data, this.showKey, this.hiddenColumns, addedColumns);
    }
  }, {
    key: "render",
    value: function () {
      var _this = this;

      var row = function row(showKey) {
        return function (el) {
          return function (k) {
            return function (things) {
              return function (arg0) {
                return function (arg1) {
                  return El.op_Dynamic(arg0, arg1);
                };
              }(h$$1)("tr")(new List$2())(toList(delay(function () {
                return append$1(showKey ? singleton$1(function (arg0_1) {
                  return function (arg1_1) {
                    return El.op_Dynamic(arg0_1, arg1_1);
                  };
                }(h$$1)(el)(new List$2())(ofArray([text(k)]))) : empty(), delay(function () {
                  return map$5(function (t) {
                    return function (arg0_2) {
                      return function (arg1_2) {
                        return El.op_Dynamic(arg0_2, arg1_2);
                      };
                    }(h$$1)(el)(new List$2())(ofArray([t]));
                  }, things);
                }));
              })));
            };
          };
        };
      };

      var makeTable = function makeTable(showKey_1) {
        return function (k_1) {
          return function (header) {
            return function (body) {
              return function (arg0_3) {
                return function (arg1_3) {
                  return El.op_Dynamic(arg0_3, arg1_3);
                };
              }(h$$1)("table")(ofArray([op_EqualsGreater("class", "thegamma-table")]))(toList(delay(function () {
                return append$1(!isNullOrWhiteSpace(_this.data.seriesName) ? singleton$1(function (arg0_4) {
                  return function (arg1_4) {
                    return El.op_Dynamic(arg0_4, arg1_4);
                  };
                }(h$$1)("caption")(new List$2())(ofArray([text(_this.data.seriesName)]))) : empty(), delay(function () {
                  return append$1(singleton$1(function (arg0_5) {
                    return function (arg1_5) {
                      return El.op_Dynamic(arg0_5, arg1_5);
                    };
                  }(h$$1)("thead")(new List$2())(ofArray([row(showKey_1)("th")(k_1)(header)]))), delay(function () {
                    return singleton$1(function (arg0_6) {
                      return function (arg1_6) {
                        return El.op_Dynamic(arg0_6, arg1_6);
                      };
                    }(h$$1)("tbody")(new List$2())(body));
                  }));
                }));
              })));
            };
          };
        };
      };

      var formatAdded = function formatAdded(o) {
        var isSeries = toList(delay(function () {
          return map$5(function (kv) {
            return kv.key;
          }, function (o) {
            return _Object$keys(o).map(function (k) {
              return {
                "key": k,
                "value": o[k]
              };
            });
          }(o));
        })).Equals(ofArray(["data", "keyName", "valueName", "seriesName"]));

        if (isSeries) {
          var result = null;
          o.data.Then(function (r) {
            result = r;
          });
          return function (arg0_7) {
            return function (arg1_7) {
              return El.op_Dynamic(arg0_7, arg1_7);
            };
          }(h$$1)("span")(new List$2())(ofArray(result.map(function (tuple) {
            return tuple[1];
          })));
        } else {
          return text(toString$2(o));
        }
      };

      return function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            return builder_.Bind(Async_AwaitFuture_Static(_this.data.data), function (_arg25) {
              var filteredProperties = function filteredProperties(o_1) {
                return function (o) {
                  return _Object$keys(o).map(function (k) {
                    return {
                      "key": k,
                      "value": o[k]
                    };
                  });
                }(o_1).filter(function (kv_1) {
                  return !_this.hiddenColumns.has(kv_1.key);
                });
              };

              var patternInput = head(_arg25);
              var headers = toList(delay(function () {
                return append$1(_typeof(patternInput[1]) == 'object' ? map$5(function (kv_2) {
                  return text(kv_2.key);
                }, filteredProperties(patternInput[1])) : singleton$1(text(_this.data.valueName)), delay(function () {
                  return collect$1(function (matchValue) {
                    return singleton$1(text(matchValue[0]));
                  }, _this.addedColumns);
                }));
              }));
              var showKey_2 = _this.showKey != null ? _this.showKey : !(_typeof(patternInput[1]) == 'object');
              return builder_.Return(function (arg00) {
                var clo1 = makeTable(arg00);
                return function (arg10) {
                  var clo2 = clo1(arg10);
                  return function (arg20) {
                    var clo3 = clo2(arg20);
                    return function (arg30) {
                      return clo3(arg30);
                    };
                  };
                };
              }(showKey_2)(_this.data.keyName)(headers)(toList(delay(function () {
                return collect$1(function (matchValue_1) {
                  return singleton$1(function () {
                    var formattedVals = toList(delay(function () {
                      return append$1(_typeof(matchValue_1[1]) == 'object' ? map$5(function (kv_3) {
                        return text(kv_3.value);
                      }, filteredProperties(matchValue_1[1])) : !(typeof matchValue_1[1] == 'number') ? singleton$1(text(toString$2(matchValue_1[1]))) : isNaN(matchValue_1[1]) ? singleton$1(text("")) : singleton$1(text(matchValue_1[1])), delay(function () {
                        return collect$1(function (matchValue_2) {
                          return singleton$1(formatAdded(matchValue_2[1](matchValue_1[1])));
                        }, _this.addedColumns);
                      }));
                    }));
                    return function (arg00_1) {
                      var clo1_1 = row(arg00_1);
                      return function (arg10_1) {
                        var clo2_1 = clo1_1(arg10_1);
                        return function (arg20_1) {
                          var clo3_1 = clo2_1(arg20_1);
                          return function (arg30_1) {
                            return clo3_1(arg30_1);
                          };
                        };
                      };
                    }(showKey_2)("td")(matchValue_1[0])(formattedVals);
                  }());
                }, _arg25);
              }))));
            });
          }), function (_arg26) {
            Log.exn("live", "Getting data for table failed: %O", _arg26);
            return builder_.Return(function () {
              throw _arg26;
            }());
          });
        });
      }(singleton$2);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this2 = this;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(_this2.render(), function (_arg27) {
            renderTo(document.getElementById(outputId), _arg27);
            return builder_.Zero();
          });
        });
      }(singleton$2));
    }
  }], [{
    key: "create",
    value: function (data) {
      var hiddenColumns = create$2(null, new GenericComparer(compare));

      var addedColumns = new List$2();
      return new table(data, null, hiddenColumns, addedColumns);
    }
  }]);

  return table;
}();
setType("TheGamma.table", table);
var placeholder = function () {
  _createClass(placeholder, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.placeholder",
        properties: {}
      };
    }
  }]);

  function placeholder(message) {
    _classCallCheck(this, placeholder);

    this.message = message;
  }

  _createClass(placeholder, [{
    key: "show",
    value: function (outputId) {
      renderTo(document.getElementById(outputId), function (arg0) {
        return function (arg1) {
          return El.op_Dynamic(arg0, arg1);
        };
      }(h$$1)("div")(ofArray([op_EqualsGreater("class", "placeholder")]))(ofArray([function (arg0_1) {
        return function (arg1_1) {
          return El.op_Dynamic(arg0_1, arg1_1);
        };
      }(h$$1)("p")(new List$2())(ofArray([text(this.message)]))])));
    }
  }], [{
    key: "create",
    value: function (message) {
      return new placeholder(message);
    }
  }]);

  return placeholder;
}();
setType("TheGamma.placeholder", placeholder);

var core$4  = _core;
var $JSON$1 = core$4.JSON || (core$4.JSON = {stringify: JSON.stringify});
var stringify$2 = function stringify(it){ // eslint-disable-line no-unused-vars
  return $JSON$1.stringify.apply($JSON$1, arguments);
};

var stringify$1 = createCommonjsModule(function (module) {
module.exports = { "default": stringify$2, __esModule: true };
});

var _JSON$stringify = unwrapExports(stringify$1);

var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var $export$9 = _export;
var defined$4 = _defined;
var fails$2   = _fails;
var spaces  = _stringWs;
var space   = '[' + spaces + ']';
var non     = '\u200b\u0085';
var ltrim   = RegExp('^' + space + space + '*');
var rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails$2(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim$1) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export$9($export$9.P + $export$9.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim$1 = exporter.trim = function(string, TYPE){
  string = String(defined$4(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

var _stringTrim = exporter;

var $parseInt$1 = _global.parseInt;
var $trim     = _stringTrim.trim;
var ws        = _stringWs;
var hex       = /^[\-+]?0[xX]/;

var _parseInt$3 = $parseInt$1(ws + '08') !== 8 || $parseInt$1(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt$1(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt$1;

var $export$8   = _export;
var $parseInt = _parseInt$3;
// 20.1.2.13 Number.parseInt(string, radix)
$export$8($export$8.S + $export$8.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

var _parseInt$1 = parseInt;

var _parseInt = createCommonjsModule(function (module) {
module.exports = { "default": _parseInt$1, __esModule: true };
});

var _Number$parseInt = unwrapExports(_parseInt);

var GeographyConfig = function () {
  function GeographyConfig(popupOnHover, highlightOnHover) {
    _classCallCheck(this, GeographyConfig);

    this.popupOnHover = popupOnHover;
    this.highlightOnHover = highlightOnHover;
  }

  _createClass(GeographyConfig, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Maps.GeographyConfig",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          popupOnHover: "boolean",
          highlightOnHover: "boolean"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return GeographyConfig;
}();
setType("TheGamma.Maps.GeographyConfig", GeographyConfig);
var DatamapConfig = function () {
  function DatamapConfig(element, scope, geographyConfig, fills, data) {
    _classCallCheck(this, DatamapConfig);

    this.element = element;
    this.scope = scope;
    this.geographyConfig = geographyConfig;
    this.fills = fills;
    this.data = data;
  }

  _createClass(DatamapConfig, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Maps.DatamapConfig",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          element: Interface("Fable.Import.Browser.HTMLElement"),
          scope: "string",
          geographyConfig: GeographyConfig,
          fills: Any,
          data: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return DatamapConfig;
}();
setType("TheGamma.Maps.DatamapConfig", DatamapConfig);
var BubblesConfig = function () {
  function BubblesConfig(popupTemplate, key) {
    _classCallCheck(this, BubblesConfig);

    this.popupTemplate = popupTemplate;
    this.key = key;
  }

  _createClass(BubblesConfig, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Maps.BubblesConfig",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          popupTemplate: "function",
          key: "function"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return BubblesConfig;
}();
setType("TheGamma.Maps.BubblesConfig", BubblesConfig);
var GeoGlobals = function (__exports) {
  var Locations = __exports.Locations = function () {
    function Locations(country, coordinates) {
      _classCallCheck(this, Locations);

      this.country = country;
      this.coordinates = coordinates;
    }

    _createClass(Locations, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Maps.GeoGlobals.Locations",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            country: "string",
            coordinates: FableArray(Float64Array, true)
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return Locations;
  }();

  setType("TheGamma.Maps.GeoGlobals.Locations", Locations);

  var locations = __exports.locations = function (arg00) {
    return function (arg10) {
      return Async_CreateNamedFuture_Static(arg00, arg10);
    };
  }("locations")(function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(Http.Request("GET", "/data/locations.json"), function (_arg1) {
        var lookup = create$3(JSON.parse(_arg1).map(function (l) {
          return [l.country, l.coordinates];
        }), new GenericComparer(compare));
        return builder_.Return(lookup);
      });
    });
  }(singleton$2));

  return __exports;
}({});
var geo = function () {
  function geo() {
    _classCallCheck(this, geo);
  }

  _createClass(geo, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Maps.geo",
        properties: {}
      };
    }
  }], [{
    key: "lookup",
    value: function (country) {
      return function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(GeoGlobals.locations), function (_arg1) {
            return builder_.Return(defaultArg(tryFind$1(country, _arg1), new Float64Array([0, 0])));
          });
        });
      }(singleton$2);
    }
  }]);

  return geo;
}();
setType("TheGamma.Maps.geo", geo);
var math = function () {
  function math() {
    _classCallCheck(this, math);
  }

  _createClass(math, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Maps.math",
        properties: {}
      };
    }
  }], [{
    key: "sqrt",
    value: function (f) {
      return Math.sqrt(f);
    }
  }, {
    key: "pow",
    value: function (f, k) {
      return Math.pow(f, k);
    }
  }, {
    key: "log",
    value: function (f, b) {
      if (b != null) {
        return Math.log(f, b);
      } else {
        return Math.log(f);
      }
    }
  }, {
    key: "min",
    value: function (f1, f2) {
      if (f1 < f2) {
        return f1;
      } else {
        return f2;
      }
    }
  }, {
    key: "max",
    value: function (f1, f2) {
      if (f1 > f2) {
        return f1;
      } else {
        return f2;
      }
    }
  }, {
    key: "add",
    value: function (f1, f2) {
      return f1 + f2;
    }
  }, {
    key: "times",
    value: function (f1, f2) {
      return f1 * f2;
    }
  }, {
    key: "sub",
    value: function (f1, f2) {
      return f1 - f2;
    }
  }, {
    key: "div",
    value: function (f1, f2) {
      return f1 / f2;
    }
  }]);

  return math;
}();
setType("TheGamma.Maps.math", math);
var timeline = function () {
  function timeline(data, colors, titleTemplate, defaultFill, delay$$1, overflowDelay, infoSelector, locSelector, sizeSelector, detailsSelector, timeSelector) {
    _classCallCheck(this, timeline);

    this.data = data;
    this.colors = colors;
    this.titleTemplate = titleTemplate;
    this.defaultFill = defaultFill;
    this.delay = delay$$1;
    this.overflowDelay = overflowDelay;
    this.infoSelector = infoSelector;
    this.locSelector = locSelector;
    this.sizeSelector = sizeSelector;
    this.detailsSelector = detailsSelector;
    this.timeSelector = timeSelector;
  }

  _createClass(timeline, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Maps.timeline",
        interfaces: ["FSharpRecord"],
        properties: {
          data: makeGeneric(series, {
            k: GenericParam("k"),
            v: GenericParam("v")
          }),
          colors: FableArray("string"),
          titleTemplate: "string",
          defaultFill: "string",
          delay: "number",
          overflowDelay: "number",
          infoSelector: "function",
          locSelector: "function",
          sizeSelector: "function",
          detailsSelector: Option("function"),
          timeSelector: "function"
        }
      };
    }
  }, {
    key: "set",
    value: function (fill, colors, title, delay$$1, overflowDelay, details) {
      var colors_1 = colors != null ? colors : this.colors;
      var defaultFill = fill != null ? fill : this.defaultFill;
      var titleTemplate = title != null ? title : this.titleTemplate;
      var delay_1 = delay$$1 != null ? delay$$1 : this.delay;
      var detailsSelector = details != null ? details : this.detailsSelector;
      var overflowDelay_1 = overflowDelay != null ? overflowDelay : this.overflowDelay;
      return new timeline(this.data, colors_1, titleTemplate, defaultFill, delay_1, overflowDelay_1, this.infoSelector, this.locSelector, this.sizeSelector, detailsSelector, this.timeSelector);
    }
  }, {
    key: "using",
    value: function (coordinates, time, size, info) {
      return new timeline(this.data, this.colors, this.titleTemplate, this.defaultFill, this.delay, this.overflowDelay, info, coordinates, size, this.detailsSelector, time);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this = this;

      var id = "map" + function () {
        var copyOfStruct_1 = void 0;
        var copyOfStruct = now();
        copyOfStruct_1 = ticks$$1(copyOfStruct);
        return toString$2(copyOfStruct_1);
      }();

      renderTo(document.getElementById(outputId), function (arg0) {
        return function (arg1) {
          return El.op_Dynamic(arg0, arg1);
        };
      }(h$$1)("div")(ofArray([op_EqualsGreater("class", "map")]))(ofArray([function (arg0_1) {
        return function (arg1_1) {
          return El.op_Dynamic(arg0_1, arg1_1);
        };
      }(h$$1)("div")(ofArray([op_EqualsGreater("id", id + "_title")]))(ofArray([text("")])), function (arg0_2) {
        return function (arg1_2) {
          return El.op_Dynamic(arg0_2, arg1_2);
        };
      }(h$$1)("div")(ofArray([op_EqualsGreater("id", id), op_EqualsGreater("class", "mapcontainer")]))(new List$2()), function (arg0_3) {
        return function (arg1_3) {
          return El.op_Dynamic(arg0_3, arg1_3);
        };
      }(h$$1)("div")(new List$2())(ofArray([function (arg0_4) {
        return function (arg1_4) {
          return El.op_Dynamic(arg0_4, arg1_4);
        };
      }(h$$1)("div")(ofArray([op_EqualsGreater("class", "buttons")]))(ofArray([function (arg0_5) {
        return function (arg1_5) {
          return El.op_Dynamic(arg0_5, arg1_5);
        };
      }(h$$1)("a")(ofArray([op_EqualsGreater("id", id + "_btn")]))(ofArray([function (arg0_6) {
        return function (arg1_6) {
          return El.op_Dynamic(arg0_6, arg1_6);
        };
      }(h$$1)("i")(ofArray([op_EqualsGreater("class", "fa fa-pause")]))(new List$2())]))])), function (arg0_7) {
        return function (arg1_7) {
          return El.op_Dynamic(arg0_7, arg1_7);
        };
      }(h$$1)("input")(ofArray([op_EqualsGreater("id", id + "_player"), op_EqualsGreater("type", "range")]))(new List$2())]))])));

      var fills = _Array$from(mapIndexed$1(function (i, c) {
        return [fsFormat("item%d")(function (x) {
          return x;
        })(i), c];
      }, this.colors));

      var map$$1 = new Datamap(new DatamapConfig(document.getElementById(id), "world", new GeographyConfig(false, false), createObj(new List$2(["defaultFill", this.defaultFill], ofArray(fills))), {}));

      var objects = function objects(data) {
        return function (infos) {
          return function (time) {
            var res = [];

            for (var i_1 = 0; i_1 <= data.length - 1; i_1++) {
              var patternInput = data[i_1];

              if (equals(patternInput[3], time)) {
                (function (arg00) {
                  res.push(arg00);
                })(createObj(append$$1(_this.detailsSelector != null ? ofArray([["details", join("", map$5(function (value) {
                  return toString$2(value);
                }, _this.detailsSelector(patternInput[2])))]]) : new List$2(), ofArray([["radius", _this.sizeSelector(patternInput[2])], ["borderWidth", "1px"], ["fillKey", fsFormat("item%d")(function (x) {
                  return x;
                })(patternInput[0] % fills.length)], ["info", defaultArg(tryFind$1(fsFormat("%O, %O")(function (x) {
                  return x;
                })(patternInput[1][0])(patternInput[1][1]), infos), "")], ["latitude", patternInput[1][0]], ["longitude", patternInput[1][1]]]))));
              }
            }

            return _Array$from(res);
          };
        };
      };

      (function (arg00_1) {
        startImmediate(arg00_1);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(_this.data.data), function (_arg25) {
            var locs = new Array(_arg25.length).fill(null);
            return builder_.Combine(builder_.For(range(0, _arg25.length - 1), function (_arg26) {
              return builder_.Bind(_this.locSelector(_arg25[_arg26][1]), function (_arg27) {
                locs[_arg26] = _arg27;
                return builder_.Zero();
              });
            }), builder_.Delay(function () {
              var colorLookup = create$3(mapIndexed$1(function (i_2, l) {
                return [ofArray(l), i_2];
              }, distinct(locs)), new GenericComparer(function (x, y) {
                return x.CompareTo(y);
              }));

              var data_1 = _Array$from(map2(function (tupledArg, locs_1) {
                return [colorLookup.get(ofArray(locs_1)), locs_1, tupledArg[1], _this.timeSelector(tupledArg[1])];
              }, _arg25, locs));

              var infosLookup = create$3(map$5(function (tupledArg_1) {
                return [tupledArg_1[0], join("<br />", distinct(map$5(function (tupledArg_2) {
                  return _this.infoSelector(tupledArg_2[2]);
                }, tupledArg_1[1])))];
              }, groupBy$1(function (tupledArg_3) {
                return fsFormat("%O, %O")(function (x) {
                  return x;
                })(tupledArg_3[1][0])(tupledArg_3[1][1]);
              }, data_1)), new GenericComparer(compare));
              var times = Int32Array.from(sortWith(function (x, y) {
                return compare(x, y);
              }, distinct(Int32Array.from(map$5(function (tupledArg_4) {
                return tupledArg_4[3];
              }, data_1)))));
              var patternInput_1 = [reduce(function (x, y) {
                return Math.min(x, y);
              }, times), reduce(function (x, y) {
                return Math.max(x, y);
              }, times)];
              var player = document.getElementById(id + "_player");
              var btn = document.getElementById(id + "_btn");
              return builder_.Combine(times.length === 1 ? function () {
                player.style.display = "none";
                btn.style.display = "none";
                return builder_.Zero();
              }() : builder_.Zero(), builder_.Delay(function () {
                player.min = String(0);
                player.value = String(0);
                player.max = String(times.length - 1);

                var render$$1 = function render$$1() {
                  var y = times[_Number$parseInt(player.value)];

                  var o = objects(data_1)(infosLookup)(y);
                  renderTo(document.getElementById(id + "_title"), function (arg0_8) {
                    return function (arg1_8) {
                      return El.op_Dynamic(arg0_8, arg1_8);
                    };
                  }(h$$1)("h2")(new List$2())(ofArray([text(replace$$1(_this.titleTemplate, "%title", String(y)))])));
                  var config = void 0;

                  var key = function key(data_2) {
                    return _JSON$stringify([data_2["latitude"], data_2["longitude"]]);
                  };

                  config = new BubblesConfig(function (geo_1, data_3) {
                    return _this.detailsSelector != null ? fsFormat("<div style='pointer-events:none' class='hoverinfo'><strong>%s</strong><br /> %s </div>")(function (x) {
                      return x;
                    })(data_3["info"])(data_3["details"]) : fsFormat("<div style='pointer-events:none' class='hoverinfo'>%s</div>")(function (x) {
                      return x;
                    })(data_3["info"]);
                  }, key);
                  map$$1.bubbles(o, config);
                };

                var autoPlay = true;

                var startPlay = function startPlay() {
                  (function (arg00_2) {
                    startImmediate(arg00_2);
                  })(function (builder__1) {
                    return builder__1.Delay(function () {
                      return builder__1.While(function () {
                        return autoPlay;
                      }, builder__1.Delay(function () {
                        var value_1 = _Number$parseInt(player.value);

                        render$$1(null);
                        player.value = String(value_1 + 1 === times.length ? 0 : value_1 + 1);
                        return builder__1.Bind(sleep(value_1 + 1 === times.length ? _this.overflowDelay : _this.delay), function () {
                          return builder__1.Return(null);
                        });
                      }));
                    });
                  }(singleton$2));
                };

                player.onchange = function (e) {
                  autoPlay = false;

                  (function (dom) {
                    renderTo(btn, dom);
                  })(function (arg0_9) {
                    return function (arg1_9) {
                      return El.op_Dynamic(arg0_9, arg1_9);
                    };
                  }(h$$1)("i")(ofArray([op_EqualsGreater("class", "fa fa-play")]))(new List$2()));

                  return render$$1(null);
                };

                player.oninput = player.onchange;

                btn.onclick = function (e_1) {
                  autoPlay = !autoPlay;

                  (function (dom_1) {
                    renderTo(btn, dom_1);
                  })(function (arg0_10) {
                    return function (arg1_10) {
                      return El.op_Dynamic(arg0_10, arg1_10);
                    };
                  }(h$$1)("i")(ofArray([op_EqualsGreater("class", autoPlay ? "fa fa-pause" : "fa fa-play")]))(new List$2()));

                  if (autoPlay) {
                    startPlay(null);
                  }

                  return null;
                };

                startPlay(null);
                return builder_.Zero();
              }));
            }));
          });
        });
      }(singleton$2));
    }
  }], [{
    key: "create",
    value: function (data) {
      var colors = ["red"];
      var defaultFill = "blue";
      var delay$$1 = 750;
      var detailsSelector = null;
      var overflowDelay = 2000;
      var titleTemplate = "%title";

      var infoSelector = function infoSelector(_arg1) {
        return "";
      };

      var timeSelector = function timeSelector(_arg2) {
        return 0;
      };

      var sizeSelector = function sizeSelector(_arg3) {
        return 10;
      };

      return new timeline(data, colors, titleTemplate, defaultFill, delay$$1, overflowDelay, infoSelector, function (_arg4) {
        throw new Error("!");
      }, sizeSelector, detailsSelector, timeSelector);
    }
  }]);

  return timeline;
}();
setType("TheGamma.Maps.timeline", timeline);

// 20.2.2.21 Math.log10(x)
var $export$10 = _export;

$export$10($export$10.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});

var log10$1 = _core.Math.log10;

var log10 = createCommonjsModule(function (module) {
module.exports = { "default": log10$1, __esModule: true };
});

var _Math$log = unwrapExports(log10);

var Color = function () {
  function Color(caseName, fields) {
    _classCallCheck(this, Color);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Color, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Color",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          HTML: ["string"],
          RGB: ["number", "number", "number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Color;
}();
setType("TheGamma.Interactive.Compost.Color", Color);
var Width = function () {
  function Width(caseName, fields) {
    _classCallCheck(this, Width);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Width, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Width",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Pixels: ["number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Width;
}();
setType("TheGamma.Interactive.Compost.Width", Width);
var FillStyle = function () {
  function FillStyle(caseName, fields) {
    _classCallCheck(this, FillStyle);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(FillStyle, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.FillStyle",
        interfaces: ["FSharpUnion", "System.IEquatable"],
        cases: {
          LinearGradient: [Interface("System.Collections.Generic.IEnumerable")],
          Solid: [Tuple(["number", Color])]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }]);

  return FillStyle;
}();
setType("TheGamma.Interactive.Compost.FillStyle", FillStyle);

var _Number = function () {
  function _Number(caseName, fields) {
    _classCallCheck(this, _Number);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(_Number, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Number",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Integer: ["number"],
          Percentage: ["number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return _Number;
}();

setType("TheGamma.Interactive.Compost.Number", _Number);
var Style = function () {
  function Style(strokeColor, strokeWidth, strokeDashArray, fill, animation, font, cursor) {
    _classCallCheck(this, Style);

    this.StrokeColor = strokeColor;
    this.StrokeWidth = strokeWidth;
    this.StrokeDashArray = strokeDashArray;
    this.Fill = fill;
    this.Animation = animation;
    this.Font = font;
    this.Cursor = cursor;
  }

  _createClass(Style, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Style",
        interfaces: ["FSharpRecord"],
        properties: {
          StrokeColor: Tuple(["number", Color]),
          StrokeWidth: Width,
          StrokeDashArray: Interface("System.Collections.Generic.IEnumerable"),
          Fill: FillStyle,
          Animation: Option(Tuple(["number", "string", "function"])),
          Font: "string",
          Cursor: "string"
        }
      };
    }
  }]);

  return Style;
}();
setType("TheGamma.Interactive.Compost.Style", Style);
var HorizontalAlign = function () {
  function HorizontalAlign(caseName, fields) {
    _classCallCheck(this, HorizontalAlign);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(HorizontalAlign, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.HorizontalAlign",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Center: [],
          End: [],
          Start: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return HorizontalAlign;
}();
setType("TheGamma.Interactive.Compost.HorizontalAlign", HorizontalAlign);
var VerticalAlign = function () {
  function VerticalAlign(caseName, fields) {
    _classCallCheck(this, VerticalAlign);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(VerticalAlign, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.VerticalAlign",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Baseline: [],
          Hanging: [],
          Middle: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return VerticalAlign;
}();
setType("TheGamma.Interactive.Compost.VerticalAlign", VerticalAlign);
var continuous = function () {
  function continuous(caseName, fields) {
    _classCallCheck(this, continuous);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(continuous, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.continuous",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          CO: ["number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return continuous;
}();
setType("TheGamma.Interactive.Compost.continuous", continuous);
var categorical = function () {
  function categorical(caseName, fields) {
    _classCallCheck(this, categorical);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(categorical, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.categorical",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          CA: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return categorical;
}();
setType("TheGamma.Interactive.Compost.categorical", categorical);
var Value = function () {
  function Value(caseName, fields) {
    _classCallCheck(this, Value);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Value, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Value",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          CAR: [makeGeneric(categorical, {
            u: GenericParam("u")
          }), "number"],
          COV: [makeGeneric(continuous, {
            u: GenericParam("u")
          })]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Value;
}();
setType("TheGamma.Interactive.Compost.Value", Value);
var EventHandler = function () {
  function EventHandler(caseName, fields) {
    _classCallCheck(this, EventHandler);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(EventHandler, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.EventHandler",
        interfaces: ["FSharpUnion"],
        cases: {
          Click: ["function"],
          MouseDown: ["function"],
          MouseLeave: ["function"],
          MouseMove: ["function"],
          MouseUp: ["function"],
          TouchEnd: ["function"],
          TouchMove: ["function"],
          TouchStart: ["function"]
        }
      };
    }
  }]);

  return EventHandler;
}();
setType("TheGamma.Interactive.Compost.EventHandler", EventHandler);
var Orientation = function () {
  function Orientation(caseName, fields) {
    _classCallCheck(this, Orientation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Orientation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Orientation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Horizontal: [],
          Vertical: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Orientation;
}();
setType("TheGamma.Interactive.Compost.Orientation", Orientation);
var Shape = function () {
  function Shape(caseName, fields) {
    _classCallCheck(this, Shape);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Shape, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Shape",
        interfaces: ["FSharpUnion"],
        cases: {
          Area: [Interface("System.Collections.Generic.IEnumerable")],
          Axes: [makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Bar: [makeGeneric(continuous, {
            u: GenericParam("vx")
          }), makeGeneric(categorical, {
            u: GenericParam("vy")
          })],
          Column: [makeGeneric(categorical, {
            u: GenericParam("vx")
          }), makeGeneric(continuous, {
            u: GenericParam("vy")
          })],
          Interactive: [Interface("System.Collections.Generic.IEnumerable"), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Layered: [Interface("System.Collections.Generic.IEnumerable")],
          Line: [Interface("System.Collections.Generic.IEnumerable")],
          Padding: [Tuple(["number", "number", "number", "number"]), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Scale: [Option(Tuple([makeGeneric(continuous, {
            u: GenericParam("vx")
          }), makeGeneric(continuous, {
            u: GenericParam("vx")
          })])), Option(Tuple([makeGeneric(continuous, {
            u: GenericParam("vy")
          }), makeGeneric(continuous, {
            u: GenericParam("vy")
          })])), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Stack: [Orientation, Interface("System.Collections.Generic.IEnumerable")],
          Style: ["function", makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Text: [makeGeneric(Value, {
            u: GenericParam("vx")
          }), makeGeneric(Value, {
            u: GenericParam("vy")
          }), VerticalAlign, HorizontalAlign, "string"]
        }
      };
    }
  }]);

  return Shape;
}();
setType("TheGamma.Interactive.Compost.Shape", Shape);
var Svg = function (__exports) {
  var StringBuilder = __exports.StringBuilder = function () {
    _createClass(StringBuilder, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Svg.StringBuilder",
          properties: {}
        };
      }
    }]);

    function StringBuilder() {
      _classCallCheck(this, StringBuilder);

      this.strs = new List$2();
    }

    _createClass(StringBuilder, [{
      key: "Append",
      value: function (s$$1) {
        this.strs = new List$2(s$$1, this.strs);
      }
    }, {
      key: "ToString",
      value: function () {
        return join("", reverse$$1(this.strs));
      }
    }]);

    return StringBuilder;
  }();

  setType("TheGamma.Interactive.Compost.Svg.StringBuilder", StringBuilder);

  var PathSegment = __exports.PathSegment = function () {
    function PathSegment(caseName, fields) {
      _classCallCheck(this, PathSegment);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(PathSegment, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Svg.PathSegment",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            LineTo: [Tuple(["number", "number"])],
            MoveTo: [Tuple(["number", "number"])]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return PathSegment;
  }();

  setType("TheGamma.Interactive.Compost.Svg.PathSegment", PathSegment);

  var Svg = __exports.Svg = function () {
    function Svg(caseName, fields) {
      _classCallCheck(this, Svg);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(Svg, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Svg.Svg",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Combine: [FableArray(Svg)],
            Empty: [],
            Path: [FableArray(PathSegment), "string"],
            Text: [Tuple(["number", "number"]), "string", "string"]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return Svg;
  }();

  setType("TheGamma.Interactive.Compost.Svg.Svg", Svg);

  var formatPath = __exports.formatPath = function (path) {
    var sb = new StringBuilder();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(path), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var ps = _step.value;

        if (ps.Case === "LineTo") {
          var y = ps.Fields[0][1];
          var x = ps.Fields[0][0];
          sb.Append("L" + String(x) + " " + String(y) + " ");
        } else {
          var y_1 = ps.Fields[0][1];
          var x_1 = ps.Fields[0][0];
          sb.Append("M" + String(x_1) + " " + String(y_1) + " ");
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return toString$2(sb);
  };

  var renderSvg = __exports.renderSvg = function (svg) {
    return delay(function () {
      if (svg.Case === "Text") {
        var y = svg.Fields[0][1];
        var x = svg.Fields[0][0];
        return singleton$1(function (arg0) {
          return function (arg1) {
            return El.op_Dynamic(arg0, arg1);
          };
        }(s)("text")(ofArray([op_EqualsGreater("x", String(x)), op_EqualsGreater("y", String(y)), op_EqualsGreater("style", svg.Fields[2])]))(ofArray([text(svg.Fields[1])])));
      } else if (svg.Case === "Combine") {
        return collect$1(function (s$$1) {
          return renderSvg(s$$1);
        }, svg.Fields[0]);
      } else if (svg.Case === "Path") {
        return singleton$1(function (arg0_1) {
          return function (arg1_1) {
            return El.op_Dynamic(arg0_1, arg1_1);
          };
        }(s)("path")(ofArray([op_EqualsGreater("d", formatPath(svg.Fields[0])), op_EqualsGreater("style", svg.Fields[1])]))(new List$2()));
      } else {
        return empty();
      }
    });
  };

  var formatColor = __exports.formatColor = function (_arg1) {
    if (_arg1.Case === "HTML") {
      return _arg1.Fields[0];
    } else {
      return fsFormat("rgb(%d, %d, %d)")(function (x) {
        return x;
      })(_arg1.Fields[0])(_arg1.Fields[1])(_arg1.Fields[2]);
    }
  };

  var formatNumber = __exports.formatNumber = function (_arg1) {
    if (_arg1.Case === "Percentage") {
      return String(_arg1.Fields[0]) + "%";
    } else {
      return String(_arg1.Fields[0]);
    }
  };

  var formatStyle = __exports.formatStyle = function (defs, style) {
    var patternInput = void 0;

    if (style.Animation == null) {
      patternInput = [style, ""];
    } else {
      (function () {
        var ms = style.Animation[0];
        var ease = style.Animation[1];
        var anim = style.Animation[2];
        var id = "anim_" + replace$$1(function () {
          var copyOfStruct = newGuid();
          return copyOfStruct;
        }(), "-", "");
        var fromstyle = formatStyle(defs, function () {
          var Animation = null;
          return new Style(style.StrokeColor, style.StrokeWidth, style.StrokeDashArray, style.Fill, Animation, style.Font, style.Cursor);
        }());
        var tostyle = formatStyle(defs, function () {
          var inputRecord = anim(style);
          var Animation_1 = null;
          return new Style(inputRecord.StrokeColor, inputRecord.StrokeWidth, inputRecord.StrokeDashArray, inputRecord.Fill, Animation_1, inputRecord.Font, inputRecord.Cursor);
        }());

        (function (arg00) {
          defs.push(arg00);
        })(function (arg0) {
          return function (arg1) {
            return El.op_Dynamic(arg0, arg1);
          };
        }(h$$1)("style")(new List$2())(ofArray([text(fsFormat("@keyframes %s { from { %s } to { %s } }")(function (x) {
          return x;
        })(id)(fromstyle)(tostyle))])));

        patternInput = [anim(style), fsFormat("animation: %s %dms %s; ")(function (x) {
          return x;
        })(id)(ms)(ease)];
      })();
    }

    return patternInput[1] + ("cursor:" + patternInput[0].Cursor + ";") + ("font:" + patternInput[0].Font + ";") + fsFormat("stroke-opacity:%f; stroke-width:%dpx; stroke:%s; ")(function (x) {
      return x;
    })(patternInput[0].StrokeColor[0])(patternInput[0].StrokeWidth.Fields[0])(formatColor(patternInput[0].StrokeColor[1])) + (isEmpty$1(patternInput[0].StrokeDashArray) ? "" : "stroke-dasharray:" + join(",", map$5(function (_arg1) {
      return formatNumber(_arg1);
    }, patternInput[0].StrokeDashArray)) + ";") + (patternInput[0].Fill.Case === "Solid" ? function () {
      var fo = patternInput[0].Fill.Fields[0][0];
      var clr = patternInput[0].Fill.Fields[0][1];
      return fsFormat("fill-opacity:%f; fill:%s; ")(function (x) {
        return x;
      })(fo)(formatColor(clr));
    }() : function () {
      var id_1 = "gradient_" + replace$$1(function () {
        var copyOfStruct_1 = newGuid();
        return copyOfStruct_1;
      }(), "-", "");

      (function (arg00_1) {
        defs.push(arg00_1);
      })(function (arg0_1) {
        return function (arg1_1) {
          return El.op_Dynamic(arg0_1, arg1_1);
        };
      }(s)("linearGradient")(ofArray([op_EqualsGreater("id", id_1)]))(toList(delay(function () {
        return collect$1(function (matchValue) {
          var o = matchValue[1][0];
          var clr_1 = matchValue[1][1];
          return singleton$1(function (arg0_2) {
            return function (arg1_2) {
              return El.op_Dynamic(arg0_2, arg1_2);
            };
          }(s)("stop")(ofArray([op_EqualsGreater("offset", String(matchValue[0]) + "%"), op_EqualsGreater("stop-color", formatColor(clr_1)), op_EqualsGreater("stop-opacity", String(o))]))(new List$2()));
        }, patternInput[0].Fill.Fields[0]);
      }))));

      return fsFormat("fill:url(#%s)")(function (x) {
        return x;
      })(id_1);
    }());
  };

  return __exports;
}({});
var Scales = function (__exports) {
  var Scale = __exports.Scale = function () {
    function Scale(caseName, fields) {
      _classCallCheck(this, Scale);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(Scale, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Scales.Scale",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Categorical: [FableArray(makeGeneric(categorical, {
              u: GenericParam("v")
            }))],
            Continuous: [makeGeneric(continuous, {
              u: GenericParam("v")
            }), makeGeneric(continuous, {
              u: GenericParam("v")
            })]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return Scale;
  }();

  setType("TheGamma.Interactive.Compost.Scales.Scale", Scale);

  var ScaledShapeInner = __exports.ScaledShapeInner = function () {
    function ScaledShapeInner(caseName, fields) {
      _classCallCheck(this, ScaledShapeInner);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ScaledShapeInner, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Scales.ScaledShapeInner",
          interfaces: ["FSharpUnion"],
          cases: {
            ScaledArea: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ScaledAxes: [Tuple([FableArray(makeGeneric(Value, {
              u: GenericParam("vx")
            })), FableArray(makeGeneric(Value, {
              u: GenericParam("vy")
            }))]), Tuple([FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), "string"])), FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vy")
            }), "string"]))]), makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledBar: [makeGeneric(continuous, {
              u: GenericParam("vx")
            }), makeGeneric(categorical, {
              u: GenericParam("vy")
            })],
            ScaledColumn: [makeGeneric(categorical, {
              u: GenericParam("vx")
            }), makeGeneric(continuous, {
              u: GenericParam("vy")
            })],
            ScaledInteractive: [Interface("System.Collections.Generic.IEnumerable"), makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledLayered: [FableArray(makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ScaledLine: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ScaledPadding: [Tuple(["number", "number", "number", "number"]), makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledStack: [Orientation, FableArray(makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ScaledStyle: ["function", makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledText: [makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), VerticalAlign, HorizontalAlign, "string"]
          }
        };
      }
    }]);

    return ScaledShapeInner;
  }();

  setType("TheGamma.Interactive.Compost.Scales.ScaledShapeInner", ScaledShapeInner);

  var ScaledShape = __exports.ScaledShape = function () {
    function ScaledShape(caseName, fields) {
      _classCallCheck(this, ScaledShape);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ScaledShape, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Scales.ScaledShape",
          interfaces: ["FSharpUnion"],
          cases: {
            Scaled: [Tuple([makeGeneric(Scale, {
              v: GenericParam("vx")
            }), makeGeneric(Scale, {
              v: GenericParam("vy")
            })]), Tuple([makeGeneric(Scale, {
              v: GenericParam("vx")
            }), makeGeneric(Scale, {
              v: GenericParam("vy")
            })]), makeGeneric(ScaledShapeInner, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })]
          }
        };
      }
    }]);

    return ScaledShape;
  }();

  setType("TheGamma.Interactive.Compost.Scales.ScaledShape", ScaledShape);

  var generateContinuousRange = __exports.generateContinuousRange = function (_arg2, _arg1) {
    var patternInput = [_arg2.Fields[0], _arg1.Fields[0]];
    var mag = Math.pow(10, round(_Math$log(patternInput[1] - patternInput[0])));
    var decimals = 0 > -_Math$log(mag) ? 0 : -_Math$log(mag);
    var patternInput_1 = [Math.floor(patternInput[0] / mag) * mag, Math.ceil(patternInput[1] / mag) * mag];
    var range$$1 = (patternInput_1[1] - patternInput_1[0]) / mag;
    var patternInput_2 = range$$1 >= 10 ? [mag, range$$1] : [mag / 10, range$$1 * 10];
    var tmag = patternInput_2[0] * Math.floor(patternInput_2[1] / 5);
    var gmag = patternInput_2[0] * Math.floor(patternInput_2[1] / 10);
    return [new Scale("Continuous", [new continuous("CO", [patternInput_1[0]]), new continuous("CO", [patternInput_1[1]])]), _Array$from(delay(function () {
      return map$5(function (v) {
        return new Value("COV", [new continuous("CO", [v])]);
      }, rangeStep(patternInput_1[0], gmag, patternInput_1[1]));
    })), _Array$from(delay(function () {
      return map$5(function (v_1) {
        return [new Value("COV", [new continuous("CO", [v_1])]), v_1.toFixed(decimals)];
      }, rangeStep(patternInput_1[0], tmag, patternInput_1[1]));
    }))];
  };

  var unionScales = __exports.unionScales = function (s1, s2) {
    var matchValue = [s1, s2];
    var $var21 = matchValue[0].Case === "Categorical" ? matchValue[1].Case === "Categorical" ? [1, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [2] : matchValue[1].Case === "Continuous" ? [0, matchValue[0].Fields[1], matchValue[1].Fields[1], matchValue[0].Fields[0], matchValue[1].Fields[0]] : [2];

    switch ($var21[0]) {
      case 0:
        return new Scale("Continuous", [$var21[3].CompareTo($var21[4]) < 0 ? $var21[3] : $var21[4], $var21[1].CompareTo($var21[2]) > 0 ? $var21[1] : $var21[2]]);

      case 1:
        return new Scale("Categorical", [_Array$from(distinct($var21[1].concat($var21[2])))]);

      case 2:
        console.log(s1, s2);
        throw new Error("Cannot union continuous with categorical");
    }
  };

  var replaceScales = __exports.replaceScales = function (outer_0, outer_1, _arg1) {
    var outer = [outer_0, outer_1];
    var $var22 = _arg1.Fields[2].Case === "ScaledText" ? [0] : _arg1.Fields[2].Case === "ScaledColumn" ? [0] : _arg1.Fields[2].Case === "ScaledBar" ? [0] : _arg1.Fields[2].Case === "ScaledArea" ? [0] : _arg1.Fields[2].Case === "ScaledStyle" ? [1] : _arg1.Fields[2].Case === "ScaledPadding" ? [2] : _arg1.Fields[2].Case === "ScaledInteractive" ? [3] : _arg1.Fields[2].Case === "ScaledLayered" ? [4] : _arg1.Fields[2].Case === "ScaledStack" ? [5] : _arg1.Fields[2].Case === "ScaledAxes" ? [6] : [0];

    switch ($var22[0]) {
      case 0:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], _arg1.Fields[2]]);

      case 1:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledStyle", [_arg1.Fields[2].Fields[0], replaceScales(outer[0], outer[1], _arg1.Fields[2].Fields[1])])]);

      case 2:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledPadding", [_arg1.Fields[2].Fields[0], replaceScales(outer[0], outer[1], _arg1.Fields[2].Fields[1])])]);

      case 3:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledInteractive", [_arg1.Fields[2].Fields[0], replaceScales(outer[0], outer[1], _arg1.Fields[2].Fields[1])])]);

      case 4:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledLayered", [_arg1.Fields[2].Fields[0].map(function (arg10_) {
          return replaceScales(outer[0], outer[1], arg10_);
        })])]);

      case 5:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledStack", [_arg1.Fields[2].Fields[0], _arg1.Fields[2].Fields[1].map(function (arg10__1) {
          return replaceScales(outer[0], outer[1], arg10__1);
        })])]);

      case 6:
        return _arg1;
    }
  };

  var calculateLineOrAreaScale = __exports.calculateLineOrAreaScale = function (vals) {
    var scales = fold$1(function (state, value) {
      var matchValue = [state, value];
      var $var23 = matchValue[0].Case === "Choice2Of3" ? matchValue[1].Case === "COV" ? [1, matchValue[1].Fields[0].Fields[0], matchValue[0].Fields[0]] : [4] : matchValue[0].Case === "Choice3Of3" ? matchValue[1].Case === "CAR" ? [3, matchValue[1].Fields[0].Fields[0], matchValue[0].Fields[0]] : [4] : matchValue[1].Case === "CAR" ? [2, matchValue[1].Fields[0].Fields[0]] : [0, matchValue[1].Fields[0].Fields[0]];

      switch ($var23[0]) {
        case 0:
          return new Choice("Choice2Of3", [ofArray([$var23[1]])]);

        case 1:
          return new Choice("Choice2Of3", [new List$2($var23[1], $var23[2])]);

        case 2:
          return new Choice("Choice3Of3", [ofArray([$var23[1]])]);

        case 3:
          return new Choice("Choice3Of3", [new List$2($var23[1], $var23[2])]);

        case 4:
          throw new Error("Values with mismatching scales");
      }
    }, new Choice("Choice1Of3", [null]), vals);

    if (scales.Case === "Choice2Of3") {
      return new Scale("Continuous", [new continuous("CO", [reduce(function (x, y) {
        return Math.min(x, y);
      }, scales.Fields[0])]), new continuous("CO", [reduce(function (x, y) {
        return Math.max(x, y);
      }, scales.Fields[0])])]);
    } else if (scales.Case === "Choice3Of3") {
      return new Scale("Categorical", [_Array$from(delay(function () {
        return map$5(function (x) {
          return new categorical("CA", [x]);
        }, reverse$$1(scales.Fields[0]));
      }))]);
    } else {
      throw new Error("No values for calculating a scale");
    }
  };

  var calculateLineOrAreaScales = __exports.calculateLineOrAreaScales = function (line) {
    var xs = line.map(function (tuple) {
      return tuple[0];
    });
    var ys = line.map(function (tuple_1) {
      return tuple_1[1];
    });
    return [calculateLineOrAreaScale(xs), calculateLineOrAreaScale(ys)];
  };

  var calculateScales = __exports.calculateScales = function (shape) {
    if (shape.Case === "Style") {
      var patternInput = calculateScales(shape.Fields[1]);
      return new ScaledShape("Scaled", [patternInput.Fields[0], patternInput.Fields[0], new ScaledShapeInner("ScaledStyle", [shape.Fields[0], new ScaledShape("Scaled", [patternInput.Fields[0], patternInput.Fields[0], patternInput.Fields[2]])])]);
    } else if (shape.Case === "Padding") {
      var patternInput_1 = calculateScales(shape.Fields[1]);
      return new ScaledShape("Scaled", [patternInput_1.Fields[0], patternInput_1.Fields[0], new ScaledShapeInner("ScaledPadding", [shape.Fields[0], new ScaledShape("Scaled", [patternInput_1.Fields[0], patternInput_1.Fields[0], patternInput_1.Fields[2]])])]);
    } else if (shape.Case === "Column") {
      var scales = [new Scale("Categorical", [[shape.Fields[0]]]), new Scale("Continuous", [new continuous("CO", [0]), shape.Fields[1]])];
      return new ScaledShape("Scaled", [scales, scales, new ScaledShapeInner("ScaledColumn", [shape.Fields[0], shape.Fields[1]])]);
    } else if (shape.Case === "Bar") {
      var scales_1 = [new Scale("Continuous", [new continuous("CO", [0]), shape.Fields[0]]), new Scale("Categorical", [[shape.Fields[1]]])];
      return new ScaledShape("Scaled", [scales_1, scales_1, new ScaledShapeInner("ScaledBar", [shape.Fields[0], shape.Fields[1]])]);
    } else if (shape.Case === "Text") {
      var makeSingletonScale = function makeSingletonScale(_arg1) {
        if (_arg1.Case === "CAR") {
          return new Scale("Categorical", [[_arg1.Fields[0]]]);
        } else {
          return new Scale("Continuous", [_arg1.Fields[0], _arg1.Fields[0]]);
        }
      };

      var scales_2 = [makeSingletonScale(shape.Fields[0]), makeSingletonScale(shape.Fields[1])];
      return new ScaledShape("Scaled", [scales_2, scales_2, new ScaledShapeInner("ScaledText", [shape.Fields[0], shape.Fields[1], shape.Fields[2], shape.Fields[3], shape.Fields[4]])]);
    } else if (shape.Case === "Line") {
      var line = _Array$from(shape.Fields[0]);

      var scales_3 = calculateLineOrAreaScales(line);
      return new ScaledShape("Scaled", [scales_3, scales_3, new ScaledShapeInner("ScaledLine", [line])]);
    } else if (shape.Case === "Area") {
      var area = _Array$from(shape.Fields[0]);

      var scales_4 = calculateLineOrAreaScales(area);
      return new ScaledShape("Scaled", [scales_4, scales_4, new ScaledShapeInner("ScaledArea", [area])]);
    } else if (shape.Case === "Axes") {
      var _ret2 = function () {
        var generateRange = function generateRange(s$$1) {
          if (s$$1.Case === "Categorical") {
            var grid = _Array$from(delay(function () {
              return map$5(function (v) {
                return new Value("CAR", [v, 0.5]);
              }, s$$1.Fields[0]);
            }));

            var grid_1 = grid.concat([new Value("CAR", [last(s$$1.Fields[0]), 1])]);
            return [s$$1, grid_1, _Array$from(delay(function () {
              return collect$1(function (matchValue) {
                return singleton$1([new Value("CAR", [new categorical("CA", [matchValue.Fields[0]]), 0.5]), matchValue.Fields[0]]);
              }, s$$1.Fields[0]);
            }))];
          } else {
            return generateContinuousRange(s$$1.Fields[0], s$$1.Fields[1]);
          }
        };

        var scaled = calculateScales(shape.Fields[0]);
        var sy = scaled.Fields[0][1];
        var sx = scaled.Fields[0][0];
        var patternInput_2 = generateRange(sx);
        var patternInput_3 = generateRange(sy);
        return {
          v: new ScaledShape("Scaled", [[patternInput_2[0], patternInput_3[0]], [patternInput_2[0], patternInput_3[0]], new ScaledShapeInner("ScaledAxes", [[patternInput_2[1], patternInput_3[1]], [patternInput_2[2], patternInput_3[2]], function () {
            var tupledArg = [patternInput_2[0], patternInput_3[0]];
            return function (arg10_) {
              return replaceScales(tupledArg[0], tupledArg[1], arg10_);
            };
          }()(scaled)])])
        };
      }();

      if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    } else if (shape.Case === "Stack") {
      var shapes = _Array$from(shape.Fields[1]);

      var scaled_1 = shapes.map(function (shape_1) {
        return calculateScales(shape_1);
      });
      var sxs = scaled_1.map(function (_arg1_1) {
        var sx_1 = _arg1_1.Fields[0][0];
        return sx_1;
      });
      var sys = scaled_1.map(function (_arg2) {
        var sy_1 = _arg2.Fields[0][1];
        return sy_1;
      });
      var scales_5 = [sxs.reduce(function (s1, s2) {
        return unionScales(s1, s2);
      }), sys.reduce(function (s1_1, s2_1) {
        return unionScales(s1_1, s2_1);
      })];
      var matchValue_1 = [shape.Fields[0], scales_5];
      var $var24 = matchValue_1[0].Case === "Vertical" ? matchValue_1[1][1].Case === "Continuous" ? [1] : [2] : matchValue_1[1][0].Case === "Continuous" ? [0] : [2];

      switch ($var24[0]) {
        case 0:
          throw new Error("Horizontal stacking of continuous axes is not supported");
          break;

        case 1:
          throw new Error("Vertical stacking of continuous axes is not supported");
          break;

        case 2:
          break;
      }

      return replaceScales(scales_5[0], scales_5[1], new ScaledShape("Scaled", [scales_5, scales_5, new ScaledShapeInner("ScaledStack", [shape.Fields[0], scaled_1])]));
    } else if (shape.Case === "Layered") {
      var shapes_1 = _Array$from(shape.Fields[0]);

      var scaled_2 = shapes_1.map(function (shape_2) {
        return calculateScales(shape_2);
      });
      var sxs_1 = scaled_2.map(function (_arg3) {
        var sx_2 = _arg3.Fields[0][0];
        return sx_2;
      });
      var sys_1 = scaled_2.map(function (_arg4) {
        var sy_2 = _arg4.Fields[0][1];
        return sy_2;
      });
      var scales_6 = [sxs_1.reduce(function (s1_2, s2_2) {
        return unionScales(s1_2, s2_2);
      }), sys_1.reduce(function (s1_3, s2_3) {
        return unionScales(s1_3, s2_3);
      })];
      return replaceScales(scales_6[0], scales_6[1], new ScaledShape("Scaled", [scales_6, scales_6, new ScaledShapeInner("ScaledLayered", [scaled_2])]));
    } else if (shape.Case === "Interactive") {
      var patternInput_4 = calculateScales(shape.Fields[1]);
      return new ScaledShape("Scaled", [patternInput_4.Fields[0], patternInput_4.Fields[0], new ScaledShapeInner("ScaledInteractive", [shape.Fields[0], new ScaledShape("Scaled", [patternInput_4.Fields[0], patternInput_4.Fields[0], patternInput_4.Fields[2]])])]);
    } else {
      var patternInput_5 = calculateScales(shape.Fields[2]);
      var asy = patternInput_5.Fields[0][1];
      var asx = patternInput_5.Fields[0][0];
      var scales_7 = [shape.Fields[0] != null ? function (tupledArg_1) {
        return new Scale("Continuous", [tupledArg_1[0], tupledArg_1[1]]);
      }(shape.Fields[0]) : asx, shape.Fields[1] != null ? function (tupledArg_2) {
        return new Scale("Continuous", [tupledArg_2[0], tupledArg_2[1]]);
      }(shape.Fields[1]) : asy];
      return replaceScales(scales_7[0], scales_7[1], new ScaledShape("Scaled", [scales_7, scales_7, patternInput_5.Fields[2]]));
    }
  };

  return __exports;
}({});
var Projections = function (__exports) {
  var Projection = __exports.Projection = function () {
    function Projection(caseName, fields) {
      _classCallCheck(this, Projection);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(Projection, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Projections.Projection",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Padding: [Tuple(["number", "number", "number", "number"]), Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]), makeGeneric(Projection, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy"),
              ux: GenericParam("ux"),
              uy: GenericParam("uy")
            })],
            Scale: [Tuple(["number", "number"]), Tuple(["number", "number"])]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return Projection;
  }();

  setType("TheGamma.Interactive.Compost.Projections.Projection", Projection);

  var ProjectedShapeInner = __exports.ProjectedShapeInner = function () {
    function ProjectedShapeInner(caseName, fields) {
      _classCallCheck(this, ProjectedShapeInner);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ProjectedShapeInner, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Projections.ProjectedShapeInner",
          interfaces: ["FSharpUnion"],
          cases: {
            ProjectedArea: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ProjectedAxes: [Tuple([FableArray(makeGeneric(Value, {
              u: GenericParam("vx")
            })), FableArray(makeGeneric(Value, {
              u: GenericParam("vy")
            }))]), Tuple([FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), "string"])), FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vy")
            }), "string"]))]), makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ProjectedBar: [makeGeneric(continuous, {
              u: GenericParam("vx")
            }), makeGeneric(categorical, {
              u: GenericParam("vy")
            })],
            ProjectedColumn: [makeGeneric(categorical, {
              u: GenericParam("vx")
            }), makeGeneric(continuous, {
              u: GenericParam("vy")
            })],
            ProjectedInteractive: [Interface("System.Collections.Generic.IEnumerable"), makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ProjectedLayered: [FableArray(makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ProjectedLine: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ProjectedStack: [Orientation, FableArray(makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ProjectedStyle: ["function", makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ProjectedText: [makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), VerticalAlign, HorizontalAlign, "string"]
          }
        };
      }
    }]);

    return ProjectedShapeInner;
  }();

  setType("TheGamma.Interactive.Compost.Projections.ProjectedShapeInner", ProjectedShapeInner);

  var ProjectedShape = __exports.ProjectedShape = function () {
    function ProjectedShape(caseName, fields) {
      _classCallCheck(this, ProjectedShape);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ProjectedShape, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Projections.ProjectedShape",
          interfaces: ["FSharpUnion"],
          cases: {
            Projected: [makeGeneric(Projection, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy"),
              ux: Any,
              uy: Any
            }), Tuple([makeGeneric(Scales.Scale, {
              v: GenericParam("vx")
            }), makeGeneric(Scales.Scale, {
              v: GenericParam("vy")
            })]), makeGeneric(ProjectedShapeInner, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })]
          }
        };
      }
    }]);

    return ProjectedShape;
  }();

  setType("TheGamma.Interactive.Compost.Projections.ProjectedShape", ProjectedShape);

  var scaleOne = __exports.scaleOne = function (tlv, thv, scale, coord) {
    var matchValue = [scale, coord];

    if (matchValue[0].Case === "Continuous") {
      if (matchValue[1].Case === "CAR") {
        throw new Error("Cannot project categorical value on a continuous scale.");
      } else {
        return new continuous("CO", [(matchValue[1].Fields[0].Fields[0] - matchValue[0].Fields[0].Fields[0]) / (matchValue[0].Fields[1].Fields[0] - matchValue[0].Fields[0].Fields[0]) * (thv - tlv) + tlv]);
      }
    } else if (matchValue[1].Case === "COV") {
      throw new Error("Cannot project continuous value on a categorical scale.");
    } else {
      var size = (thv - tlv) / matchValue[0].Fields[0].length;
      var i = matchValue[0].Fields[0].findIndex(function (_arg1) {
        return matchValue[1].Fields[0].Fields[0] === _arg1.Fields[0];
      });
      var i_1 = i + matchValue[1].Fields[1];
      return new continuous("CO", [tlv + i_1 * size]);
    }
  };

  var getExtremes = __exports.getExtremes = function (_arg1) {
    if (_arg1.Case === "Categorical") {
      return [new Value("CAR", [_arg1.Fields[0][0], 0]), new Value("CAR", [_arg1.Fields[0][_arg1.Fields[0].length - 1], 1])];
    } else {
      return [new Value("COV", [_arg1.Fields[0]]), new Value("COV", [_arg1.Fields[1]])];
    }
  };

  var project = __exports.project = function (sx, sy, point_0, point_1, projection) {
    var point = [point_0, point_1];
    var matchValue = [projection, point];

    if (matchValue[0].Case === "Padding") {
      var t = matchValue[0].Fields[0][0];
      var r = matchValue[0].Fields[0][1];
      var projection_1 = matchValue[0].Fields[2];
      var ly = matchValue[0].Fields[1][2];
      var lx = matchValue[0].Fields[1][0];
      var l = matchValue[0].Fields[0][3];
      var hy = matchValue[0].Fields[1][3];
      var hx = matchValue[0].Fields[1][1];
      var b = matchValue[0].Fields[0][2];
      var patternInput = project(sx, sy, lx, ly, projection_1);
      var y1 = patternInput[1].Fields[0];
      var x1 = patternInput[0].Fields[0];
      var patternInput_1 = project(sx, sy, hx, hy, projection_1);
      var y2 = patternInput_1[1].Fields[0];
      var x2 = patternInput_1[0].Fields[0];
      var patternInput_2 = [x1 < x2 ? x1 : x2, x1 > x2 ? x1 : x2, y1 < y2 ? y1 : y2, y1 > y2 ? y1 : y2];
      var patternInput_3 = project(sx, sy, point[0], point[1], projection_1);
      var y = patternInput_3[1].Fields[0];
      var x = patternInput_3[0].Fields[0];
      var nx = patternInput_2[0] === patternInput_2[1] ? x : patternInput_2[0] + l + (patternInput_2[1] - patternInput_2[0] - l - r) / (patternInput_2[1] - patternInput_2[0]) * (x - patternInput_2[0]);
      var ny = patternInput_2[2] === patternInput_2[3] ? y : patternInput_2[2] + t + (patternInput_2[3] - patternInput_2[2] - t - b) / (patternInput_2[3] - patternInput_2[2]) * (y - patternInput_2[2]);
      return [new continuous("CO", [nx]), new continuous("CO", [ny])];
    } else {
      var y_1 = matchValue[1][1];
      var x_1 = matchValue[1][0];
      var ty = matchValue[0].Fields[1];
      var tx = matchValue[0].Fields[0];
      return [scaleOne(tx[0], tx[1], sx, x_1), scaleOne(ty[0], ty[1], sy, y_1)];
    }
  };

  var scaleOneInv = __exports.scaleOneInv = function (tlv, thv, scale, coord) {
    var matchValue = [scale, coord];

    if (matchValue[0].Case === "Categorical") {
      var v = matchValue[1].Fields[0];
      var cats = matchValue[0].Fields[0];
      var size = (thv - tlv) / cats.length;
      var i = Math.floor(v / size);
      var f = v / size - i;

      if (~~i < 0 ? true : ~~i >= cats.length) {
        return new Value("CAR", [new categorical("CA", ["<outside-of-range>"]), f]);
      } else {
        return new Value("CAR", [cats[~~i], f]);
      }
    } else {
      var v_1 = matchValue[1].Fields[0];
      var slv = matchValue[0].Fields[0].Fields[0];
      var shv = matchValue[0].Fields[1].Fields[0];
      return new Value("COV", [new continuous("CO", [(v_1 - tlv) / (thv - tlv) * (shv - slv) + slv])]);
    }
  };

  var projectInv = __exports.projectInv = function (_arg1_0, _arg1_1, point_0, point_1, projection) {
    projectInv: while (true) {
      var _arg1 = [_arg1_0, _arg1_1];
      var point = [point_0, point_1];
      var matchValue = [projection, point];

      if (matchValue[0].Case === "Scale") {
        var y = matchValue[1][1];
        var x = matchValue[1][0];
        var ty = matchValue[0].Fields[1];
        var tx = matchValue[0].Fields[0];
        return [scaleOneInv(tx[0], tx[1], _arg1[0], x), scaleOneInv(ty[0], ty[1], _arg1[1], y)];
      } else {
        var y_1 = matchValue[1][1].Fields[0];
        var x_1 = matchValue[1][0].Fields[0];
        var t = matchValue[0].Fields[0][0];
        var r = matchValue[0].Fields[0][1];
        var projection_1 = matchValue[0].Fields[2];
        var ly = matchValue[0].Fields[1][2];
        var lx = matchValue[0].Fields[1][0];
        var l = matchValue[0].Fields[0][3];
        var hy = matchValue[0].Fields[1][3];
        var hx = matchValue[0].Fields[1][1];
        var b = matchValue[0].Fields[0][2];
        var patternInput = project(_arg1[0], _arg1[1], lx, ly, projection_1);
        var y1 = patternInput[1].Fields[0];
        var x1 = patternInput[0].Fields[0];
        var patternInput_1 = project(_arg1[0], _arg1[1], hx, hy, projection_1);
        var y2 = patternInput_1[1].Fields[0];
        var x2 = patternInput_1[0].Fields[0];
        var patternInput_2 = [x1 < x2 ? x1 : x2, x1 > x2 ? x1 : x2, y1 < y2 ? y1 : y2, y1 > y2 ? y1 : y2];
        var oy = point[1].Fields[0];
        var ox = point[0].Fields[0];
        var nx = (ox - l) / (patternInput_2[1] - patternInput_2[0] - l - r) * (patternInput_2[1] - patternInput_2[0]);
        var ny = (oy - t) / (patternInput_2[3] - patternInput_2[2] - t - b) * (patternInput_2[3] - patternInput_2[2]);
        _arg1_0 = _arg1[0];
        _arg1_1 = _arg1[1];
        point_0 = new continuous("CO", [nx]);
        point_1 = new continuous("CO", [ny]);
        projection = projection_1;
        continue projectInv;
      }
    }
  };

  var calculateProjections = __exports.calculateProjections = function (shape, projection) {
    calculateProjections: while (true) {
      if (shape.Fields[2].Case === "ScaledLine") {
        var line = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedLine", [line])]);
      } else if (shape.Fields[2].Case === "ScaledBar") {
        var y = shape.Fields[2].Fields[1];
        var x = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedBar", [x, y])]);
      } else if (shape.Fields[2].Case === "ScaledColumn") {
        var y_1 = shape.Fields[2].Fields[1];
        var x_1 = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedColumn", [x_1, y_1])]);
      } else if (shape.Fields[2].Case === "ScaledText") {
        var y_2 = shape.Fields[2].Fields[1];
        var x_2 = shape.Fields[2].Fields[0];
        var va = shape.Fields[2].Fields[2];
        var t = shape.Fields[2].Fields[4];
        var ha = shape.Fields[2].Fields[3];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedText", [x_2, y_2, va, ha, t])]);
      } else if (shape.Fields[2].Case === "ScaledArea") {
        var area = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedArea", [area])]);
      } else if (shape.Fields[2].Case === "ScaledPadding") {
        var t_1 = shape.Fields[2].Fields[0][0];
        var sy = shape.Fields[0][1];
        var sx = shape.Fields[0][0];
        var shape_1 = shape.Fields[2].Fields[1];
        var r = shape.Fields[2].Fields[0][1];
        var l = shape.Fields[2].Fields[0][3];
        var b = shape.Fields[2].Fields[0][2];
        var patternInput = void 0;
        var syinner = shape_1.Fields[1][1];
        var sxinner = shape_1.Fields[1][0];
        patternInput = [getExtremes(sxinner), getExtremes(syinner)];
        var ly = patternInput[1][0];
        var lx = patternInput[0][0];
        var hy = patternInput[1][1];
        var hx = patternInput[0][1];
        var ppad = new Projection("Padding", [[t_1, r, b, l], [lx, hx, ly, hy], projection]);
        shape = shape_1;
        projection = ppad;
        continue calculateProjections;
      } else if (shape.Fields[2].Case === "ScaledAxes") {
        var sy_1 = shape.Fields[0][1];
        var sx_1 = shape.Fields[0][0];
        var shape_2 = shape.Fields[2].Fields[2];
        var lbls = shape.Fields[2].Fields[1];
        var grid = shape.Fields[2].Fields[0];
        var patternInput_1 = [getExtremes(sx_1), getExtremes(sy_1)];
        var ly_1 = patternInput_1[1][0];
        var lx_1 = patternInput_1[0][0];
        var hy_1 = patternInput_1[1][1];
        var hx_1 = patternInput_1[0][1];
        var ppad_1 = new Projection("Padding", [[20, 20, 40, 100], [lx_1, hx_1, ly_1, hy_1], projection]);
        return new ProjectedShape("Projected", [ppad_1, shape.Fields[0], new ProjectedShapeInner("ProjectedAxes", [grid, lbls, calculateProjections(shape_2, ppad_1)])]);
      } else if (shape.Fields[2].Case === "ScaledStack") {
        var shapes = shape.Fields[2].Fields[1];
        var orient = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedStack", [orient, shapes.map(function (s$$1) {
          return calculateProjections(s$$1, projection);
        })])]);
      } else if (shape.Fields[2].Case === "ScaledLayered") {
        var shapes_1 = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedLayered", [shapes_1.map(function (s_1) {
          return calculateProjections(s_1, projection);
        })])]);
      } else if (shape.Fields[2].Case === "ScaledInteractive") {
        var shape_3 = shape.Fields[2].Fields[1];
        var f = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedInteractive", [f, calculateProjections(shape_3, projection)])]);
      } else {
        var style = shape.Fields[2].Fields[0];
        var shape_4 = shape.Fields[2].Fields[1];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedStyle", [style, calculateProjections(shape_4, projection)])]);
      }
    }
  };

  return __exports;
}({});
var Drawing = function (__exports) {
  var hideFill = __exports.hideFill = function (style) {
    var Fill = new FillStyle("Solid", [[0, new Color("RGB", [0, 0, 0])]]);
    var Animation = void 0;

    if (style.Animation != null) {
      var n = style.Animation[0];
      var f = style.Animation[2];
      var e = style.Animation[1];
      Animation = [n, e, function ($var25) {
        return function (style_1) {
          return hideFill(style_1);
        }(f($var25));
      }];
    } else {
      Animation = null;
    }

    return new Style(style.StrokeColor, style.StrokeWidth, style.StrokeDashArray, Fill, Animation, style.Font, style.Cursor);
  };

  var hideStroke = __exports.hideStroke = function (style) {
    var StrokeColor = [0, style.StrokeColor[1]];
    var Animation = void 0;

    if (style.Animation != null) {
      var n = style.Animation[0];
      var f = style.Animation[2];
      var e = style.Animation[1];
      Animation = [n, e, function ($var26) {
        return function (style_1) {
          return hideStroke(style_1);
        }(f($var26));
      }];
    } else {
      Animation = null;
    }

    return new Style(StrokeColor, style.StrokeWidth, style.StrokeDashArray, style.Fill, Animation, style.Font, style.Cursor);
  };

  var drawShape = __exports.drawShape = function (defs, style, shape) {
    var _loop = function _loop() {
      var sy = shape.Fields[1][1];
      var sx = shape.Fields[1][0];

      var projectCont = function projectCont(tupledArg) {
        var matchValue = Projections.project(sx, sy, tupledArg[0], tupledArg[1], shape.Fields[0]);
        var y = matchValue[1].Fields[0];
        var x = matchValue[0].Fields[0];
        return [x, y];
      };

      var projectContCov = function projectContCov(tupledArg_1) {
        return projectCont([new Value("COV", [tupledArg_1[0]]), new Value("COV", [tupledArg_1[1]])]);
      };

      var matchValue_1 = [shape.Fields[2], [sx, sy]];
      var $var27 = matchValue_1[0].Case === "ProjectedText" ? [1, matchValue_1[0].Fields[3], matchValue_1[0].Fields[4], matchValue_1[0].Fields[2], matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedLine" ? [2, matchValue_1[0].Fields[0]] : matchValue_1[0].Case === "ProjectedColumn" ? matchValue_1[1][0].Case === "Categorical" ? matchValue_1[1][1].Case === "Continuous" ? [4, matchValue_1[1][1].Fields[1], matchValue_1[1][1].Fields[0], matchValue_1[1][0].Fields[0], matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [3, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [3, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedBar" ? matchValue_1[1][1].Case === "Categorical" ? matchValue_1[1][0].Case === "Continuous" ? [6, matchValue_1[1][0].Fields[1], matchValue_1[1][0].Fields[0], matchValue_1[1][1].Fields[0], matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [5, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [5, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedArea" ? matchValue_1[1][0].Case === "Continuous" ? matchValue_1[1][1].Case === "Continuous" ? [8, matchValue_1[1][0].Fields[1], matchValue_1[1][1].Fields[1], matchValue_1[0].Fields[0], matchValue_1[1][0].Fields[0], matchValue_1[1][1].Fields[0]] : [7, matchValue_1[0].Fields[0]] : [7, matchValue_1[0].Fields[0]] : matchValue_1[0].Case === "ProjectedAxes" ? [9, matchValue_1[0].Fields[0][0], matchValue_1[0].Fields[0][1], matchValue_1[0].Fields[1][0], matchValue_1[0].Fields[1][1], matchValue_1[0].Fields[2], matchValue_1[1][0], matchValue_1[1][1]] : matchValue_1[0].Case === "ProjectedLayered" ? [10, matchValue_1[0].Fields[0]] : matchValue_1[0].Case === "ProjectedStack" ? [11, matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedInteractive" ? [12, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [0, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]];

      var _ret4 = function () {
        switch ($var27[0]) {
          case 0:
            defs = defs;
            style = $var27[1](style);
            shape = $var27[2];
            return {
              v: "continue|drawShape"
            };

          case 1:
            var va = $var27[3].Case === "Hanging" ? "hanging" : $var27[3].Case === "Middle" ? "middle" : "baseline";
            var ha = $var27[1].Case === "Center" ? "middle" : $var27[1].Case === "End" ? "end" : "start";
            return {
              v: {
                v: new Svg.Svg("Text", [projectCont([$var27[4], $var27[5]]), $var27[2], fsFormat("alignment-baseline:%s; text-anchor:%s;")(function (x) {
                  return x;
                })(va)(ha) + Svg.formatStyle(defs, style)])
              }
            };

          case 2:
            var path = _Array$from(toList(delay(function () {
              return append$1(singleton$1(new Svg.PathSegment("MoveTo", [projectCont(head($var27[1]))])), delay(function () {
                return map$5(function (pt) {
                  return new Svg.PathSegment("LineTo", [projectCont(pt)]);
                }, skip(1, $var27[1]));
              }));
            })));

            return {
              v: {
                v: new Svg.Svg("Path", [path, Svg.formatStyle(defs, hideFill(style))])
              }
            };

          case 3:
            throw new Error("Column can be drawn only on matching scales");

          case 4:
            var path_1 = [new Svg.PathSegment("MoveTo", [projectCont([new Value("CAR", [$var27[4], 0]), new Value("COV", [$var27[5]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var27[4], 1]), new Value("COV", [$var27[5]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var27[4], 1]), new Value("COV", [$var27[2]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var27[4], 0]), new Value("COV", [$var27[2]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var27[4], 0]), new Value("COV", [$var27[5]])])])];
            return {
              v: {
                v: new Svg.Svg("Path", [path_1, Svg.formatStyle(defs, hideStroke(style))])
              }
            };

          case 5:
            throw new Error("Bar can be drawn only on matching scales");

          case 6:
            var path_2 = [new Svg.PathSegment("MoveTo", [projectCont([new Value("COV", [$var27[4]]), new Value("CAR", [$var27[5], 0])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var27[4]]), new Value("CAR", [$var27[5], 1])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var27[2]]), new Value("CAR", [$var27[5], 1])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var27[2]]), new Value("CAR", [$var27[5], 0])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var27[4]]), new Value("CAR", [$var27[5], 0])])])];
            return {
              v: {
                v: new Svg.Svg("Path", [path_2, Svg.formatStyle(defs, hideStroke(style))])
              }
            };

          case 7:
            throw new Error("Area can be drawn only on continuous scale");

          case 8:
            var patternInput = [head($var27[3])[0], last($var27[3])[0]];

            var path_3 = _Array$from(toList(delay(function () {
              return append$1(singleton$1(new Svg.PathSegment("MoveTo", [projectCont([patternInput[0], new Value("COV", [$var27[5]])])])), delay(function () {
                return append$1(map$5(function (pt_1) {
                  return new Svg.PathSegment("LineTo", [projectCont(pt_1)]);
                }, $var27[3]), delay(function () {
                  return append$1(singleton$1(new Svg.PathSegment("LineTo", [projectCont([patternInput[1], new Value("COV", [$var27[5]])])])), delay(function () {
                    return singleton$1(new Svg.PathSegment("LineTo", [projectCont([patternInput[0], new Value("COV", [$var27[5]])])]));
                  }));
                }));
              }));
            })));

            return {
              v: {
                v: new Svg.Svg("Path", [path_3, Svg.formatStyle(defs, hideStroke(style))])
              }
            };

          case 9:
            var offs = function offs(tupledArg_2) {
              return function (tupledArg_3) {
                return [tupledArg_3[0] + tupledArg_2[0], tupledArg_3[1] + tupledArg_2[1]];
              };
            };

            var patternInput_1 = [Projections.getExtremes($var27[6]), Projections.getExtremes($var27[7])];
            var ly = patternInput_1[1][0];
            var lx = patternInput_1[0][0];
            var hy = patternInput_1[1][1];
            var hx = patternInput_1[0][1];
            return {
              v: {
                v: new Svg.Svg("Combine", [_Array$from(delay(function () {
                  return append$1(singleton$1(new Svg.Svg("Path", [_Array$from(delay(function () {
                    return append$1(singleton$1(new Svg.PathSegment("MoveTo", [projectCont([lx, hy])])), delay(function () {
                      return append$1(singleton$1(new Svg.PathSegment("LineTo", [projectCont([lx, ly])])), delay(function () {
                        return singleton$1(new Svg.PathSegment("LineTo", [projectCont([hx, ly])]));
                      }));
                    }));
                  })), "fill:transparent; stroke:rgb(0,0,0); stroke-width:2"])), delay(function () {
                    return append$1(collect$1(function (matchValue_2) {
                      return singleton$1(new Svg.Svg("Text", [offs([0, 10])(projectCont([matchValue_2[0], ly])), matchValue_2[1], "alignment-baseline:hanging;text-anchor:middle;font:9pt sans-serif"]));
                    }, $var27[3]), delay(function () {
                      return append$1(collect$1(function (matchValue_3) {
                        return singleton$1(new Svg.Svg("Text", [offs([-10, 0])(projectCont([lx, matchValue_3[0]])), matchValue_3[1], "alignment-baseline:middle;text-anchor:end;font:9pt sans-serif"]));
                      }, $var27[4]), delay(function () {
                        return append$1(singleton$1(new Svg.Svg("Path", [_Array$from(delay(function () {
                          return append$1(collect$1(function (x_1) {
                            return append$1(singleton$1(new Svg.PathSegment("MoveTo", [projectCont([x_1, ly])])), delay(function () {
                              return singleton$1(new Svg.PathSegment("LineTo", [projectCont([x_1, hy])]));
                            }));
                          }, $var27[1]), delay(function () {
                            return collect$1(function (y_1) {
                              return append$1(singleton$1(new Svg.PathSegment("MoveTo", [projectCont([lx, y_1])])), delay(function () {
                                return singleton$1(new Svg.PathSegment("LineTo", [projectCont([hx, y_1])]));
                              }));
                            }, $var27[2]);
                          }));
                        })), "fill:transparent; stroke:rgb(228,228,228); stroke-width:1"])), delay(function () {
                          return singleton$1(drawShape(defs, style, $var27[5]));
                        }));
                      }));
                    }));
                  }));
                }))])
              }
            };

          case 10:
            return {
              v: {
                v: new Svg.Svg("Combine", [$var27[1].map(function (s$$1) {
                  return drawShape(defs, style, s$$1);
                })])
              }
            };

          case 11:
            return {
              v: {
                v: new Svg.Svg("Combine", [$var27[1].map(function (s_1) {
                  return drawShape(defs, style, s_1);
                })])
              }
            };

          case 12:
            defs = defs;
            style = style;
            shape = $var27[2];
            return {
              v: "continue|drawShape"
            };
        }
      }();

      if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
    };

    drawShape: while (true) {
      var _ret3 = _loop();

      switch (_ret3) {
        case "continue|drawShape":
          continue drawShape;

        default:
          if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
      }
    }
  };

  return __exports;
}({});
var Events = function (__exports) {
  var MouseEventKind = __exports.MouseEventKind = function () {
    function MouseEventKind(caseName, fields) {
      _classCallCheck(this, MouseEventKind);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(MouseEventKind, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Events.MouseEventKind",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Click: [],
            Down: [],
            Move: [],
            Up: []
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return MouseEventKind;
  }();

  setType("TheGamma.Interactive.Compost.Events.MouseEventKind", MouseEventKind);

  var TouchEventKind = __exports.TouchEventKind = function () {
    function TouchEventKind(caseName, fields) {
      _classCallCheck(this, TouchEventKind);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(TouchEventKind, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Events.TouchEventKind",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            End: [],
            Move: [],
            Start: []
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return TouchEventKind;
  }();

  setType("TheGamma.Interactive.Compost.Events.TouchEventKind", TouchEventKind);

  var InteractiveEvent = __exports.InteractiveEvent = function () {
    function InteractiveEvent(caseName, fields) {
      _classCallCheck(this, InteractiveEvent);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(InteractiveEvent, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Events.InteractiveEvent",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            MouseEvent: [MouseEventKind, Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })])],
            MouseLeave: [],
            TouchEvent: [TouchEventKind, Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })])]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return InteractiveEvent;
  }();

  setType("TheGamma.Interactive.Compost.Events.InteractiveEvent", InteractiveEvent);

  var projectEvent = __exports.projectEvent = function (scales_0, scales_1, projection, event) {
    var scales = [scales_0, scales_1];
    var $var28 = event.Case === "TouchEvent" ? event.Fields[1][0].Case === "COV" ? event.Fields[1][1].Case === "COV" ? [1, event.Fields[0], event.Fields[1][0].Fields[0], event.Fields[1][1].Fields[0]] : [2] : [2] : event.Case === "MouseLeave" ? [3] : event.Fields[1][0].Case === "COV" ? event.Fields[1][1].Case === "COV" ? [0, event.Fields[0], event.Fields[1][0].Fields[0], event.Fields[1][1].Fields[0]] : [2] : [2];

    switch ($var28[0]) {
      case 0:
        return new InteractiveEvent("MouseEvent", [$var28[1], function () {
          var tupledArg = [$var28[2], $var28[3]];
          return Projections.projectInv(scales[0], scales[1], tupledArg[0], tupledArg[1], projection);
        }()]);

      case 1:
        return new InteractiveEvent("TouchEvent", [$var28[1], function () {
          var tupledArg_1 = [$var28[2], $var28[3]];
          return Projections.projectInv(scales[0], scales[1], tupledArg_1[0], tupledArg_1[1], projection);
        }()]);

      case 2:
        throw new Error("TODO: projectEvent - not continuous");

      case 3:
        return new InteractiveEvent("MouseLeave", []);
    }
  };

  var inScale = __exports.inScale = function (s$$1, v) {
    var matchValue = [s$$1, v];

    if (matchValue[0].Case === "Categorical") {
      if (matchValue[1].Case === "COV") {
        throw new Error("inScale: Cannot test if continuous value is in categorical scale");
      } else {
        return exists$1(function (y) {
          return matchValue[1].Fields[0].Equals(y);
        }, matchValue[0].Fields[0]);
      }
    } else if (matchValue[1].Case === "CAR") {
      throw new Error("inScale: Cannot test if categorical value is in continuous scale");
    } else if (matchValue[1].Fields[0].Fields[0] >= (matchValue[0].Fields[0].Fields[0] < matchValue[0].Fields[1].Fields[0] ? matchValue[0].Fields[0].Fields[0] : matchValue[0].Fields[1].Fields[0])) {
      return matchValue[1].Fields[0].Fields[0] <= (matchValue[0].Fields[0].Fields[0] > matchValue[0].Fields[1].Fields[0] ? matchValue[0].Fields[0].Fields[0] : matchValue[0].Fields[1].Fields[0]);
    } else {
      return false;
    }
  };

  var inScales = __exports.inScales = function (sx, sy, event) {
    var $var29 = event.Case === "MouseEvent" ? [1, event.Fields[1][0], event.Fields[1][1]] : event.Case === "TouchEvent" ? [1, event.Fields[1][0], event.Fields[1][1]] : [0];

    switch ($var29[0]) {
      case 0:
        return true;

      case 1:
        if (inScale(sx, $var29[1])) {
          return inScale(sy, $var29[2]);
        } else {
          return false;
        }

    }
  };

  var triggerEvent = __exports.triggerEvent = function (shape, jse, event) {
    var $var30 = shape.Fields[2].Case === "ProjectedText" ? [0] : shape.Fields[2].Case === "ProjectedColumn" ? [0] : shape.Fields[2].Case === "ProjectedBar" ? [0] : shape.Fields[2].Case === "ProjectedArea" ? [0] : shape.Fields[2].Case === "ProjectedStyle" ? [1, shape.Fields[2].Fields[1]] : shape.Fields[2].Case === "ProjectedAxes" ? [1, shape.Fields[2].Fields[2]] : shape.Fields[2].Case === "ProjectedStack" ? [2, shape.Fields[2].Fields[1]] : shape.Fields[2].Case === "ProjectedLayered" ? [2, shape.Fields[2].Fields[0]] : shape.Fields[2].Case === "ProjectedInteractive" ? [3] : [0];

    switch ($var30[0]) {
      case 0:
        break;

      case 1:
        triggerEvent($var30[1], jse, event);
        break;

      case 2:
        for (var idx = 0; idx <= $var30[1].length - 1; idx++) {
          var shape_1 = $var30[1][idx];
          triggerEvent(shape_1, jse, event);
        }

        break;

      case 3:
        var localEvent = projectEvent(shape.Fields[1][0], shape.Fields[1][1], shape.Fields[0], event);

        if (inScales(shape.Fields[1][0], shape.Fields[1][1], localEvent)) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = _getIterator(shape.Fields[2].Fields[0]), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var handler = _step2.value;
              var matchValue = [localEvent, handler];
              var $var31 = matchValue[0].Case === "TouchEvent" ? matchValue[0].Fields[0].Case === "Start" ? matchValue[1].Case === "TouchStart" ? [1, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Fields[0].Case === "End" ? matchValue[1].Case === "TouchEnd" ? [1, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[1].Case === "TouchMove" ? [1, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Case === "MouseLeave" ? matchValue[1].Case === "MouseLeave" ? [2, matchValue[1].Fields[0]] : [3] : matchValue[0].Fields[0].Case === "Move" ? matchValue[1].Case === "MouseMove" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Fields[0].Case === "Up" ? matchValue[1].Case === "MouseUp" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Fields[0].Case === "Down" ? matchValue[1].Case === "MouseDown" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[1].Case === "Click" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3];

              switch ($var31[0]) {
                case 0:
                  jse.preventDefault();
                  $var31[1](jse)($var31[2]);
                  break;

                case 1:
                  jse.preventDefault();
                  $var31[1](jse)($var31[2]);
                  break;

                case 2:
                  $var31[1](jse);
                  break;

                case 3:
                  break;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        triggerEvent(shape.Fields[2].Fields[1], jse, event);
        break;
    }
  };

  return __exports;
}({});
var Compost = function (__exports) {
  var app = __exports.app = function (id, initial, r, u) {
    var event = new Event$2();

    var trigger = function trigger(e) {
      event.Trigger(e);
    };

    var container = document.createElement("div");
    document.getElementById(id).innerHTML = "";
    document.getElementById(id).appendChild(container);
    var tree = {};
    var state = initial;

    var handleEvent = function handleEvent(evt) {
      if (evt != null) {
        state = u(state)(evt);
      } else {
        state = state;
      }

      var newTree = renderVirtual(r(trigger)(state));
      var patches = diff(tree, newTree);
      container = patch(container, patches);
      tree = newTree;
    };

    handleEvent(null);
    add$5(function ($var32) {
      return handleEvent(function (arg0) {
        return arg0;
      }($var32));
    }, event.Publish);
  };

  var createSvg = __exports.createSvg = function (width, height, viz) {
    var scaled = Scales.calculateScales(viz);
    var master = new Projections.Projection("Scale", [[0, width], [height, 0]]);
    var projected = Projections.calculateProjections(scaled, master);
    var defstyle = void 0;
    var Fill = new FillStyle("Solid", [[1, new Color("RGB", [196, 196, 196])]]);
    var StrokeColor = [1, new Color("RGB", [256, 0, 0])];
    var StrokeDashArray = new List$2();
    var StrokeWidth = new Width("Pixels", [2]);
    var Animation = null;
    var Cursor = "default";
    defstyle = new Style(StrokeColor, StrokeWidth, StrokeDashArray, Fill, Animation, "10pt sans-serif", Cursor);
    var defs = [];
    var svg = Drawing.drawShape(defs, defstyle, projected);

    var getRelativeLocation = function getRelativeLocation(el) {
      return function (x) {
        return function (y) {
          var getOffset = function getOffset(parent) {
            return function (tupledArg) {
              getOffset: while (true) {
                if (parent == null) {
                  return [tupledArg[0], tupledArg[1]];
                } else {
                  var _var33 = parent.offsetParent;
                  tupledArg = [tupledArg[0] - parent.offsetLeft, tupledArg[1] - parent.offsetTop];
                  parent = _var33;
                  continue getOffset;
                }
              }
            };
          };

          var getParent = function getParent(parent_1) {
            getParent: while (true) {
              if (parent_1.offsetParent != null) {
                return parent_1;
              } else {
                parent_1 = parent_1.parentElement;
                continue getParent;
              }
            }
          };

          return getOffset(getParent(el))([x, y]);
        };
      };
    };

    var mouseHandler = function mouseHandler(kind) {
      return function (el_1) {
        return function (evt) {
          var evt_1 = evt;
          var patternInput = getRelativeLocation(el_1)(evt_1.pageX)(evt_1.pageY);
          Events.triggerEvent(projected, evt_1, new Events.InteractiveEvent("MouseEvent", [kind, [new Value("COV", [new continuous("CO", [patternInput[0]])]), new Value("COV", [new continuous("CO", [patternInput[1]])])]]));
        };
      };
    };

    var touchHandler = function touchHandler(kind_1) {
      return function (el_2) {
        return function (evt_2) {
          var evt_3 = evt_2;
          var touch = evt_3.touches[0];
          var patternInput_1 = getRelativeLocation(el_2)(touch.pageX)(touch.pageY);
          Events.triggerEvent(projected, evt_3, new Events.InteractiveEvent("TouchEvent", [kind_1, [new Value("COV", [new continuous("CO", [patternInput_1[0]])]), new Value("COV", [new continuous("CO", [patternInput_1[1]])])]]));
        };
      };
    };

    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray([op_EqualsGreater("style", fsFormat("width:%dpx;height:%dpx;margin:0px auto 0px auto")(function (x) {
      return x;
    })(~~width)(~~height))]))(ofArray([function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(s)("svg")(ofArray([op_EqualsGreater("width", String(~~width)), op_EqualsGreater("height", String(~~height)), op_EqualsBangGreater("click", mouseHandler(new Events.MouseEventKind("Click", []))), op_EqualsBangGreater("mousemove", mouseHandler(new Events.MouseEventKind("Move", []))), op_EqualsBangGreater("mousedown", mouseHandler(new Events.MouseEventKind("Down", []))), op_EqualsBangGreater("mouseup", mouseHandler(new Events.MouseEventKind("Up", []))), op_EqualsBangGreater("mouseleave", function (_arg1) {
      return function (evt_4) {
        Events.triggerEvent(projected, evt_4, new Events.InteractiveEvent("MouseLeave", []));
      };
    }), op_EqualsBangGreater("touchmove", touchHandler(new Events.TouchEventKind("Move", []))), op_EqualsBangGreater("touchdown", touchHandler(new Events.TouchEventKind("Start", []))), op_EqualsBangGreater("touchup", touchHandler(new Events.TouchEventKind("End", [])))]))(toList(delay(function () {
      return append$1(defs, delay(function () {
        return Svg.renderSvg(svg);
      }));
    })))]));
  };

  return __exports;
}({});

var YouDrawHelpers = function (__exports) {
  var YouDrawEvent = __exports.YouDrawEvent = function () {
    function YouDrawEvent(caseName, fields) {
      _classCallCheck(this, YouDrawEvent);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(YouDrawEvent, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouDrawHelpers.YouDrawEvent",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Draw: ["number", "number"],
            ShowResults: []
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return YouDrawEvent;
  }();

  setType("TheGamma.Interactive.YouDrawHelpers.YouDrawEvent", YouDrawEvent);

  var YouDrawState = __exports.YouDrawState = function () {
    function YouDrawState(completed, clip, data, guessed) {
      _classCallCheck(this, YouDrawState);

      this.Completed = completed;
      this.Clip = clip;
      this.Data = data;
      this.Guessed = guessed;
    }

    _createClass(YouDrawState, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouDrawHelpers.YouDrawState",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            Completed: "boolean",
            Clip: "number",
            Data: FableArray(Tuple(["number", "number"])),
            Guessed: FableArray(Tuple(["number", Option("number")]))
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return YouDrawState;
  }();

  setType("TheGamma.Interactive.YouDrawHelpers.YouDrawState", YouDrawState);

  var initState = __exports.initState = function (data, clipx) {
    var Completed = false;
    return new YouDrawState(Completed, clipx, data, _Array$from(delay(function () {
      return collect$1(function (matchValue) {
        return matchValue[0] > clipx ? singleton$1([matchValue[0], null]) : empty();
      }, data);
    })));
  };

  var handler = __exports.handler = function (state, evt) {
    if (evt.Case === "Draw") {
      var _ret = function () {
        var indexed = state.Guessed.map(function (x, y) {
          return [y, x];
        });
        var patternInput = reduce(function (f) {
          return function (x, y) {
            return f(x) < f(y) ? x : y;
          };
        }(function (tupledArg) {
          return Math.abs(evt.Fields[0] - tupledArg[1][0]);
        }), indexed);
        var Guessed = indexed.map(function (tupledArg_1) {
          return tupledArg_1[0] === patternInput[0] ? [tupledArg_1[1][0], evt.Fields[1]] : [tupledArg_1[1][0], tupledArg_1[1][1]];
        });
        return {
          v: new YouDrawState(state.Completed, state.Clip, state.Data, Guessed)
        };
      }();

      if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    } else {
      return new YouDrawState(true, state.Clip, state.Data, state.Guessed);
    }
  };

  var render$$1 = __exports.render = function (width, height, topLbl, leftLbl, rightLbl, leftClr, rightClr, guessClr, loy, hiy, trigger, state) {
    var all = _Array$from(delay(function () {
      return collect$1(function (matchValue) {
        return singleton$1([new Value("COV", [new continuous("CO", [matchValue[0]])]), new Value("COV", [new continuous("CO", [matchValue[1]])])]);
      }, state.Data);
    }));

    var known = _Array$from(delay(function () {
      return collect$1(function (matchValue_1) {
        return matchValue_1[0] <= state.Clip ? singleton$1([new Value("COV", [new continuous("CO", [matchValue_1[0]])]), new Value("COV", [new continuous("CO", [matchValue_1[1]])])]) : empty();
      }, state.Data);
    }));

    var right = _Array$from(delay(function () {
      return append$1(singleton$1(last(known)), delay(function () {
        return collect$1(function (matchValue_2) {
          return matchValue_2[0] > state.Clip ? singleton$1([new Value("COV", [new continuous("CO", [matchValue_2[0]])]), new Value("COV", [new continuous("CO", [matchValue_2[1]])])]) : empty();
        }, state.Data);
      }));
    }));

    var guessed = _Array$from(delay(function () {
      return append$1(singleton$1(last(known)), delay(function () {
        return collect$1(function (matchValue_3) {
          return function () {
            return matchValue_3[1] != null;
          }(null) ? singleton$1([new Value("COV", [new continuous("CO", [matchValue_3[0]])]), new Value("COV", [new continuous("CO", [matchValue_3[1]])])]) : empty();
        }, state.Guessed);
      }));
    }));

    var patternInput = [(head(state.Data)[0] + state.Clip) / 2, loy + (hiy - loy) / 10];
    var patternInput_1 = [(last(state.Data)[0] + state.Clip) / 2, loy + (hiy - loy) / 10];
    var patternInput_2 = [state.Clip, hiy - (hiy - loy) / 10];

    var setColor = function setColor(c) {
      return function (s$$1) {
        var Font = "12pt sans-serif";
        var Fill = new FillStyle("Solid", [[1, new Color("HTML", [c])]]);
        return new Style([0, new Color("RGB", [0, 0, 0])], s$$1.StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, Font, s$$1.Cursor);
      };
    };

    var labels = new Shape("Layered", [ofArray([new Shape("Style", [setColor(leftClr), new Shape("Text", [new Value("COV", [new continuous("CO", [patternInput[0]])]), new Value("COV", [new continuous("CO", [patternInput[1]])]), new VerticalAlign("Baseline", []), new HorizontalAlign("Center", []), leftLbl])]), new Shape("Style", [setColor(rightClr), new Shape("Text", [new Value("COV", [new continuous("CO", [patternInput_1[0]])]), new Value("COV", [new continuous("CO", [patternInput_1[1]])]), new VerticalAlign("Baseline", []), new HorizontalAlign("Center", []), rightLbl])]), new Shape("Style", [setColor(guessClr), new Shape("Text", [new Value("COV", [new continuous("CO", [patternInput_2[0]])]), new Value("COV", [new continuous("CO", [patternInput_2[1]])]), new VerticalAlign("Baseline", []), new HorizontalAlign("Center", []), topLbl])])])]);
    var chart = new Shape("Axes", [new Shape("Interactive", [state.Completed ? new List$2() : ofArray([new EventHandler("MouseMove", [function (evt) {
      return function (tupledArg) {
        if (tupledArg[0].Case === "COV") {
          var x = tupledArg[0].Fields[0].Fields[0];

          if (tupledArg[1].Case === "COV") {
            var y = tupledArg[1].Fields[0].Fields[0];

            if ((~~evt.buttons & 1) === 1) {
              trigger(new YouDrawEvent("Draw", [x, y]));
            }
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 70, 47);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 70, 35);
        }
      };
    }]), new EventHandler("TouchMove", [function (evt_1) {
      return function (tupledArg_1) {
        if (tupledArg_1[0].Case === "COV") {
          var x_1 = tupledArg_1[0].Fields[0].Fields[0];

          if (tupledArg_1[1].Case === "COV") {
            var y_1 = tupledArg_1[1].Fields[0].Fields[0];
            trigger(new YouDrawEvent("Draw", [x_1, y_1]));
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 72, 47);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 72, 35);
        }
      };
    }]), new EventHandler("MouseDown", [function (evt_2) {
      return function (tupledArg_2) {
        if (tupledArg_2[0].Case === "COV") {
          var x_2 = tupledArg_2[0].Fields[0].Fields[0];

          if (tupledArg_2[1].Case === "COV") {
            var y_2 = tupledArg_2[1].Fields[0].Fields[0];
            trigger(new YouDrawEvent("Draw", [x_2, y_2]));
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 74, 47);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 74, 35);
        }
      };
    }]), new EventHandler("TouchStart", [function (evt_3) {
      return function (tupledArg_3) {
        if (tupledArg_3[0].Case === "COV") {
          var x_3 = tupledArg_3[0].Fields[0].Fields[0];

          if (tupledArg_3[1].Case === "COV") {
            var y_3 = tupledArg_3[1].Fields[0].Fields[0];
            trigger(new YouDrawEvent("Draw", [x_3, y_3]));
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 75, 48);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 75, 36);
        }
      };
    }])]), new Shape("Scale", [null, [new continuous("CO", [loy]), new continuous("CO", [hiy])], new Shape("Layered", [toList(delay(function () {
      return append$1(singleton$1(labels), delay(function () {
        return append$1(singleton$1(new Shape("Style", [function ($var34) {
          return Drawing.hideStroke(Drawing.hideFill($var34));
        }, new Shape("Line", [all])])), delay(function () {
          return append$1(singleton$1(new Shape("Style", [function (s_1) {
            var StrokeColor = [1, new Color("HTML", [leftClr])];
            var Fill_1 = new FillStyle("Solid", [[0.2, new Color("HTML", [leftClr])]]);
            return new Style(StrokeColor, s_1.StrokeWidth, s_1.StrokeDashArray, Fill_1, s_1.Animation, s_1.Font, s_1.Cursor);
          }, new Shape("Layered", [ofArray([new Shape("Area", [known]), new Shape("Line", [known])])])])), delay(function () {
            return append$1(state.Completed ? singleton$1(new Shape("Style", [function (s_2) {
              var StrokeColor_1 = [1, new Color("HTML", [rightClr])];
              var StrokeDashArray = ofArray([new _Number("Percentage", [0]), new _Number("Percentage", [100])]);
              var Fill_2 = new FillStyle("Solid", [[0, new Color("HTML", [rightClr])]]);
              var Animation = [1000, "ease", function (s_3) {
                var StrokeDashArray_1 = ofArray([new _Number("Percentage", [100]), new _Number("Percentage", [0])]);
                var Fill_3 = new FillStyle("Solid", [[0.2, new Color("HTML", [rightClr])]]);
                return new Style(s_3.StrokeColor, s_3.StrokeWidth, StrokeDashArray_1, Fill_3, s_3.Animation, s_3.Font, s_3.Cursor);
              }];
              return new Style(StrokeColor_1, s_2.StrokeWidth, StrokeDashArray, Fill_2, Animation, s_2.Font, s_2.Cursor);
            }, new Shape("Layered", [ofArray([new Shape("Area", [right]), new Shape("Line", [right])])])])) : empty(), delay(function () {
              return guessed.length > 1 ? singleton$1(new Shape("Style", [function (s_4) {
                var StrokeColor_2 = [1, new Color("HTML", [guessClr])];
                var StrokeDashArray_2 = ofArray([new _Number("Integer", [5]), new _Number("Integer", [5])]);
                return new Style(StrokeColor_2, s_4.StrokeWidth, StrokeDashArray_2, s_4.Fill, s_4.Animation, s_4.Font, s_4.Cursor);
              }, new Shape("Line", [guessed])])) : empty();
            }));
          }));
        }));
      }));
    }))])])])]);
    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray([op_EqualsGreater("style", "text-align:center;padding-top:20px")]))(ofArray([Compost.createSvg(width, height, chart), function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(h$$1)("div")(ofArray([op_EqualsGreater("style", "padding-bottom:20px")]))(ofArray([function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("button")(toList(delay(function () {
      return append$1(singleton$1(op_EqualsBangGreater("click", function (_arg10) {
        return function (_arg9) {
          trigger(new YouDrawEvent("ShowResults", []));
        };
      })), delay(function () {
        return equals(last(state.Guessed)[1], null) ? singleton$1(op_EqualsGreater("disabled", "disabled")) : empty();
      }));
    })))(ofArray([text("Show me how I did")]))]))]));
  };

  return __exports;
}({});
var youdraw = function () {
  function youdraw(data, clip, min$$1, max$$1, knownColor, unknownColor, drawColor, topLabel, knownLabel, guessLabel) {
    _classCallCheck(this, youdraw);

    this.data = data;
    this.clip = clip;
    this.min = min$$1;
    this.max = max$$1;
    this.knownColor = knownColor;
    this.unknownColor = unknownColor;
    this.drawColor = drawColor;
    this.topLabel = topLabel;
    this.knownLabel = knownLabel;
    this.guessLabel = guessLabel;
  }

  _createClass(youdraw, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.youdraw",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          data: makeGeneric(series, {
            k: "number",
            v: "number"
          }),
          clip: Option("number"),
          min: Option("number"),
          max: Option("number"),
          knownColor: Option("string"),
          unknownColor: Option("string"),
          drawColor: Option("string"),
          topLabel: Option("string"),
          knownLabel: Option("string"),
          guessLabel: Option("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "setRange",
    value: function (min$$1, max$$1) {
      var min_1 = min$$1;
      var max_1 = max$$1;
      return new youdraw(this.data, this.clip, min_1, max_1, this.knownColor, this.unknownColor, this.drawColor, this.topLabel, this.knownLabel, this.guessLabel);
    }
  }, {
    key: "setClip",
    value: function (clip) {
      var clip_1 = clip;
      return new youdraw(this.data, clip_1, this.min, this.max, this.knownColor, this.unknownColor, this.drawColor, this.topLabel, this.knownLabel, this.guessLabel);
    }
  }, {
    key: "setColors",
    value: function (known, unknown) {
      var knownColor = known;
      var unknownColor = unknown;
      return new youdraw(this.data, this.clip, this.min, this.max, knownColor, unknownColor, this.drawColor, this.topLabel, this.knownLabel, this.guessLabel);
    }
  }, {
    key: "setDrawColor",
    value: function (draw) {
      var drawColor = draw;
      return new youdraw(this.data, this.clip, this.min, this.max, this.knownColor, this.unknownColor, drawColor, this.topLabel, this.knownLabel, this.guessLabel);
    }
  }, {
    key: "setLabels",
    value: function (top, known, guess) {
      var knownLabel = known;
      var topLabel = top;
      var guessLabel = guess;
      return new youdraw(this.data, this.clip, this.min, this.max, this.knownColor, this.unknownColor, this.drawColor, topLabel, knownLabel, guessLabel);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this = this;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          var id = "container" + replace$$1(function () {
            var copyOfStruct = newGuid();
            return copyOfStruct;
          }(), "-", "");
          renderTo(document.getElementById(outputId), function (arg0) {
            return function (arg1) {
              return El.op_Dynamic(arg0, arg1);
            };
          }(h$$1)("div")(ofArray([op_EqualsGreater("id", id)]))(new List$2()));
          return builder_.Bind(Async_AwaitFuture_Static(_this.data.data), function (_arg4) {
            var i = 10;
            return builder_.Combine(builder_.While(function () {
              return i > 0 ? document.getElementById(id) == null : false;
            }, builder_.Delay(function () {
              return builder_.Bind(sleep(10), function () {
                i = i - 1;
                return builder_.Zero();
              });
            })), builder_.Delay(function () {
              var element = document.getElementById(id);
              var size = [element.clientWidth, 400 > element.clientWidth / 2 ? 400 : element.clientWidth / 2];
              return builder_.TryWith(builder_.Delay(function () {
                var loy = _this.min != null ? _this.min : reduce(function (x, y) {
                  return Math.min(x, y);
                }, map$5(function (tuple) {
                  return tuple[1];
                }, _arg4));
                var hiy = _this.max != null ? _this.max : reduce(function (x, y) {
                  return Math.max(x, y);
                }, map$5(function (tuple_1) {
                  return tuple_1[1];
                }, _arg4));
                var clipx = _this.clip != null ? _this.clip : _arg4[~~(_arg4.length / 2)][0];

                var data = _Array$from(sortWith(function (x, y) {
                  return compare(function (tuple_2) {
                    return tuple_2[0];
                  }(x), function (tuple_2) {
                    return tuple_2[0];
                  }(y));
                }, _arg4));

                var patternInput = [defaultArg(_this.knownColor, "#606060"), defaultArg(_this.unknownColor, "#FFC700"), defaultArg(_this.drawColor, "#808080")];
                Compost.app(outputId, YouDrawHelpers.initState(data, clipx), function () {
                  var tupledArg = [defaultArg(_this.topLabel, ""), defaultArg(_this.knownLabel, ""), defaultArg(_this.guessLabel, "")];
                  var tupledArg_1 = [patternInput[0], patternInput[1], patternInput[2]];
                  var tupledArg_2 = [loy, hiy];
                  return function (trigger) {
                    return function (state) {
                      return YouDrawHelpers.render(size[0], size[1], tupledArg[0], tupledArg[1], tupledArg[2], tupledArg_1[0], tupledArg_1[1], tupledArg_1[2], tupledArg_2[0], tupledArg_2[1], trigger, state);
                    };
                  };
                }(), function (state_1) {
                  return function (evt) {
                    return YouDrawHelpers.handler(state_1, evt);
                  };
                });
                return builder_.Zero();
              }), function (_arg6) {
                Log.exn("GUI", "Interactive rendering failed: %O", _arg6);
                return builder_.Zero();
              });
            }));
          });
        });
      }(singleton$2));
    }
  }], [{
    key: "create",
    value: function (data) {
      var clip = null;
      var min$$1 = null;
      var max$$1 = null;
      var guessLabel = null;
      var topLabel = null;
      var knownLabel = null;
      return new youdraw(data, clip, min$$1, max$$1, null, null, null, topLabel, knownLabel, guessLabel);
    }
  }]);

  return youdraw;
}();
setType("TheGamma.Interactive.youdraw", youdraw);
var YouGuessColsHelpers = function (__exports) {
  var YouGuessState = __exports.YouGuessState = function () {
    function YouGuessState(completed, completionStep, _default, maximum, data, guesses) {
      _classCallCheck(this, YouGuessState);

      this.Completed = completed;
      this.CompletionStep = completionStep;
      this.Default = _default;
      this.Maximum = maximum;
      this.Data = data;
      this.Guesses = guesses;
    }

    _createClass(YouGuessState, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouGuessColsHelpers.YouGuessState",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            Completed: "boolean",
            CompletionStep: "number",
            Default: "number",
            Maximum: "number",
            Data: FableArray(Tuple(["string", "number"])),
            Guesses: makeGeneric(FableMap, {
              Key: "string",
              Value: "number"
            })
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return YouGuessState;
  }();

  setType("TheGamma.Interactive.YouGuessColsHelpers.YouGuessState", YouGuessState);

  var YouGuessEvent = __exports.YouGuessEvent = function () {
    function YouGuessEvent(caseName, fields) {
      _classCallCheck(this, YouGuessEvent);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(YouGuessEvent, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouGuessColsHelpers.YouGuessEvent",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Animate: [],
            ShowResults: [],
            Update: ["string", "number"]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return YouGuessEvent;
  }();

  setType("TheGamma.Interactive.YouGuessColsHelpers.YouGuessEvent", YouGuessEvent);

  var initState = __exports.initState = function (data) {
    var max_1 = void 0;
    var matchValue = Scales.generateContinuousRange(new continuous("CO", [0]), new continuous("CO", [reduce(function (x, y) {
      return Math.max(x, y);
    }, map$5(function (tuple) {
      return tuple[1];
    }, data))]));

    if (matchValue[0].Case === "Continuous") {
      var max$$1 = matchValue[0].Fields[1].Fields[0];
      max_1 = max$$1;
    } else {
      throw new Error("Failed to calculate maximum");
    }

    var Completed = false;
    var CompletionStep = 0;
    return new YouGuessState(Completed, CompletionStep, averageBy(function (tuple_1) {
      return tuple_1[1];
    }, data), max_1, data, create$3(null, new GenericComparer(compare)));
  };

  var update = __exports.update = function (state, evt) {
    if (evt.Case === "Animate") {
      var CompletionStep = 1 < state.CompletionStep + 0.05 ? 1 : state.CompletionStep + 0.05;
      return new YouGuessState(state.Completed, CompletionStep, state.Default, state.Maximum, state.Data, state.Guesses);
    } else if (evt.Case === "Update") {
      var Guesses = add$1(evt.Fields[0], evt.Fields[1], state.Guesses);
      return new YouGuessState(state.Completed, state.CompletionStep, state.Default, state.Maximum, state.Data, Guesses);
    } else {
      return new YouGuessState(true, state.CompletionStep, state.Default, state.Maximum, state.Data, state.Guesses);
    }
  };

  var vega10 = __exports.vega10 = ofArray(["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]);

  var renderBars = __exports.renderBars = function (width, height, topLabel, trigger, state) {
    if (state.Completed ? state.CompletionStep < 1 : false) {
      window.setTimeout(function () {
        trigger(new YouGuessEvent("Animate", []));
      }, 50);
    }

    var chart = new Shape("Axes", [new Shape("Interactive", [state.Completed ? new List$2() : ofArray([new EventHandler("MouseMove", [function (evt) {
      return function (tupledArg) {
        if (tupledArg[0].Case === "CAR") {
          var x = tupledArg[0].Fields[0].Fields[0];

          if (tupledArg[1].Case === "COV") {
            var y = tupledArg[1].Fields[0].Fields[0];

            if ((~~evt.buttons & 1) === 1) {
              trigger(new YouGuessEvent("Update", [x, y]));
            }
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 212, 64);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 212, 50);
        }
      };
    }]), new EventHandler("MouseDown", [function (evt_1) {
      return function (tupledArg_1) {
        if (tupledArg_1[0].Case === "CAR") {
          var x_1 = tupledArg_1[0].Fields[0].Fields[0];

          if (tupledArg_1[1].Case === "COV") {
            var y_1 = tupledArg_1[1].Fields[0].Fields[0];
            trigger(new YouGuessEvent("Update", [x_1, y_1]));
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 214, 64);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 214, 50);
        }
      };
    }]), new EventHandler("TouchStart", [function (evt_2) {
      return function (tupledArg_2) {
        if (tupledArg_2[0].Case === "CAR") {
          var x_2 = tupledArg_2[0].Fields[0].Fields[0];

          if (tupledArg_2[1].Case === "COV") {
            var y_2 = tupledArg_2[1].Fields[0].Fields[0];
            trigger(new YouGuessEvent("Update", [x_2, y_2]));
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 216, 65);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 216, 51);
        }
      };
    }]), new EventHandler("TouchMove", [function (evt_3) {
      return function (tupledArg_3) {
        if (tupledArg_3[0].Case === "CAR") {
          var x_3 = tupledArg_3[0].Fields[0].Fields[0];

          if (tupledArg_3[1].Case === "COV") {
            var y_3 = tupledArg_3[1].Fields[0].Fields[0];
            trigger(new YouGuessEvent("Update", [x_3, y_3]));
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 218, 64);
          }
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\libraries\\interactive.fs", 218, 50);
        }
      };
    }])]), new Shape("Style", [function (s$$1) {
      if (state.Completed) {
        return s$$1;
      } else {
        var Cursor = "row-resize";
        return new Style(s$$1.StrokeColor, s$$1.StrokeWidth, s$$1.StrokeDashArray, s$$1.Fill, s$$1.Animation, s$$1.Font, Cursor);
      }
    }, new Shape("Layered", [toList(delay(function () {
      return append$1(singleton$1(new Shape("Stack", [new Orientation("Horizontal", []), toList(delay(function () {
        return collect$1(function (matchValue) {
          var value = matchValue[1][1];
          var lbl = matchValue[1][0];
          return singleton$1(function () {
            var sh = new Shape("Style", [function (s_1) {
              var Fill = new FillStyle("Solid", [[0.2, new Color("HTML", ["#a0a0a0"])]]);
              return new Style(s_1.StrokeColor, s_1.StrokeWidth, s_1.StrokeDashArray, Fill, s_1.Animation, s_1.Font, s_1.Cursor);
            }, new Shape("Column", [new categorical("CA", [lbl]), new continuous("CO", [state.Maximum])])]);
            return new Shape("Padding", [[0, 10, 0, 10], sh]);
          }());
        }, zip(vega10, state.Data));
      }))])), delay(function () {
        return append$1(singleton$1(new Shape("Stack", [new Orientation("Horizontal", []), toList(delay(function () {
          return collect$1(function (matchValue_1) {
            var value_1 = matchValue_1[1][1];
            var lbl_1 = matchValue_1[1][0];
            return singleton$1(function () {
              var patternInput = void 0;
              var matchValue_2 = [state.Completed, tryFind$1(lbl_1, state.Guesses)];
              var $var35 = matchValue_2[0] ? matchValue_2[1] == null ? [2] : [0] : matchValue_2[1] == null ? [2] : [1];

              switch ($var35[0]) {
                case 0:
                  var guess = matchValue_2[1];
                  patternInput = [0.6, state.CompletionStep * value_1 + (1 - state.CompletionStep) * guess];
                  break;

                case 1:
                  var v = matchValue_2[1];
                  patternInput = [0.6, v];
                  break;

                case 2:
                  patternInput = [0.2, state.Default];
                  break;
              }

              var sh_1 = new Shape("Style", [function (s_2) {
                var Fill_1 = new FillStyle("Solid", [[patternInput[0], new Color("HTML", [matchValue_1[0]])]]);
                return new Style(s_2.StrokeColor, s_2.StrokeWidth, s_2.StrokeDashArray, Fill_1, s_2.Animation, s_2.Font, s_2.Cursor);
              }, new Shape("Column", [new categorical("CA", [lbl_1]), new continuous("CO", [patternInput[1]])])]);
              return new Shape("Padding", [[0, 10, 0, 10], sh_1]);
            }());
          }, zip(vega10, state.Data));
        }))])), delay(function () {
          return append$1(collect$1(function (matchValue_3) {
            var value_2 = matchValue_3[1][1];
            var lbl_2 = matchValue_3[1][0];
            var matchValue_4 = tryFind$1(lbl_2, state.Guesses);

            if (matchValue_4 != null) {
              var line = new Shape("Line", [ofArray([[new Value("CAR", [new categorical("CA", [lbl_2]), 0]), new Value("COV", [new continuous("CO", [matchValue_4])])], [new Value("CAR", [new categorical("CA", [lbl_2]), 1]), new Value("COV", [new continuous("CO", [matchValue_4])])]])]);
              return singleton$1(new Shape("Style", [function (s_3) {
                return new Style([1, new Color("HTML", [matchValue_3[0]])], new Width("Pixels", [4]), ofArray([new _Number("Integer", [5]), new _Number("Integer", [5])]), s_3.Fill, s_3.Animation, s_3.Font, s_3.Cursor);
              }, new Shape("Padding", [[0, 10, 0, 10], line])]));
            } else {
              return empty();
            }
          }, zip(vega10, state.Data)), delay(function () {
            if (topLabel != null) {
              var x_4 = new Value("CAR", [new categorical("CA", [state.Data[~~(state.Data.length / 2)][0]]), state.Data.length % 2 === 0 ? 0 : 0.5]);
              var y_4 = new Value("COV", [new continuous("CO", [state.Maximum * 0.9])]);
              return singleton$1(new Shape("Style", [function (s_4) {
                var Font = "13pt sans-serif";
                var Fill_2 = new FillStyle("Solid", [[1, new Color("HTML", ["#808080"])]]);
                return new Style([0, new Color("RGB", [0, 0, 0])], s_4.StrokeWidth, s_4.StrokeDashArray, Fill_2, s_4.Animation, Font, s_4.Cursor);
              }, new Shape("Text", [x_4, y_4, new VerticalAlign("Baseline", []), new HorizontalAlign("Center", []), topLabel])]));
            } else {
              return empty();
            }
          }));
        }));
      }));
    }))])])])]);
    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray([op_EqualsGreater("style", "text-align:center;padding-top:20px")]))(ofArray([Compost.createSvg(width, height, chart), function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(h$$1)("div")(ofArray([op_EqualsGreater("style", "padding-bottom:20px")]))(ofArray([function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("button")(toList(delay(function () {
      return append$1(singleton$1(op_EqualsBangGreater("click", function (_arg10) {
        return function (_arg9) {
          trigger(new YouGuessEvent("ShowResults", []));
        };
      })), delay(function () {
        return state.Guesses.size !== state.Data.length ? singleton$1(op_EqualsGreater("disabled", "disabled")) : empty();
      }));
    })))(ofArray([text("Show me how I did")]))]))]));
  };

  return __exports;
}({});
var YouGuessCols = function () {
  function YouGuessCols(data, topLabel) {
    _classCallCheck(this, YouGuessCols);

    this.data = data;
    this.topLabel = topLabel;
  }

  _createClass(YouGuessCols, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.YouGuessCols",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          data: makeGeneric(series, {
            k: "string",
            v: "number"
          }),
          topLabel: Option("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "setLabel",
    value: function (top) {
      var topLabel = top;
      return new YouGuessCols(this.data, topLabel);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this2 = this;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          var id = "container" + replace$$1(function () {
            var copyOfStruct = newGuid();
            return copyOfStruct;
          }(), "-", "");
          renderTo(document.getElementById(outputId), function (arg0) {
            return function (arg1) {
              return El.op_Dynamic(arg0, arg1);
            };
          }(h$$1)("div")(ofArray([op_EqualsGreater("id", id)]))(new List$2()));
          return builder_.Bind(Async_AwaitFuture_Static(_this2.data.data), function (_arg4) {
            var i = 10;
            return builder_.Combine(builder_.While(function () {
              return i > 0 ? document.getElementById(id) == null : false;
            }, builder_.Delay(function () {
              return builder_.Bind(sleep(10), function () {
                i = i - 1;
                return builder_.Zero();
              });
            })), builder_.Delay(function () {
              var element = document.getElementById(id);
              var size = [element.clientWidth, 400 > element.clientWidth / 2 ? 400 : element.clientWidth / 2];
              return builder_.Bind(Async_AwaitFuture_Static(_this2.data.data), function (_arg6) {
                try {
                  Compost.app(outputId, YouGuessColsHelpers.initState(_arg6), function (trigger) {
                    return function (state) {
                      return YouGuessColsHelpers.renderBars(size[0], size[1], _this2.topLabel, trigger, state);
                    };
                  }, function (state_1) {
                    return function (evt) {
                      return YouGuessColsHelpers.update(state_1, evt);
                    };
                  });
                } catch (e) {
                  Log.exn("GUI", "Interactive rendering failed: %O", e);
                }

                return builder_.Zero();
              });
            }));
          });
        });
      }(singleton$2));
    }
  }]);

  return YouGuessCols;
}();
setType("TheGamma.Interactive.YouGuessCols", YouGuessCols);
var youguess = function () {
  function youguess() {
    _classCallCheck(this, youguess);
  }

  _createClass(youguess, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.youguess",
        properties: {}
      };
    }
  }], [{
    key: "columns",
    value: function (data) {
      return new YouGuessCols(data, null);
    }
  }]);

  return youguess;
}();
setType("TheGamma.Interactive.youguess", youguess);

var TypeContext = function () {
    function TypeContext(equivalentVars) {
        _classCallCheck(this, TypeContext);

        this.EquivalentVars = equivalentVars;
    }

    _createClass(TypeContext, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Types.TypeContext",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    EquivalentVars: makeGeneric(List$2, {
                        T: Tuple(["string", "string"])
                    })
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TypeContext;
}();
setType("TheGamma.Types.TypeContext", TypeContext);
function listsEqual(l1, l2, f) {
    var matchValue = [l1, l2];
    var $var66 = matchValue[0].tail != null ? matchValue[1].tail != null ? function () {
        var ys = matchValue[1].tail;
        var y = matchValue[1].head;
        var xs = matchValue[0].tail;
        var x = matchValue[0].head;
        return f(x)(y);
    }() ? [1, matchValue[0].head, matchValue[0].tail, matchValue[1].head, matchValue[1].tail] : [2] : [2] : matchValue[1].tail == null ? [0] : [2];

    switch ($var66[0]) {
        case 0:
            return true;

        case 1:
            return listsEqual($var66[2], $var66[4], f);

        case 2:
            return false;
    }
}
function arraysEqual(l1, l2, f) {
    var loop = function loop(i) {
        loop: while (true) {
            if (i === l1.length ? i === l2.length : false) {
                return true;
            } else if (i < l1.length ? i < l2.length : false) {
                if (f(l1[i])(l2[i])) {
                    i = i + 1;
                    continue loop;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
    };

    return loop(0);
}
function memberNamesEqual(m1, m2) {
    var matchValue = [m1, m2];
    var $var67 = matchValue[0].Case === "Method" ? matchValue[1].Case === "Method" ? [0, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [1] : matchValue[1].Case === "Property" ? [0, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [1];

    switch ($var67[0]) {
        case 0:
            return $var67[1] === $var67[2];

        case 1:
            return false;
    }
}

function _BoundTypeVariables_(t) {
    if (t.Case === "Forall") {
        return [t.Fields[0], t];
    } else {
        return [new List$2(), t];
    }
}

function membersEqual(ctx, m1, m2) {
    var matchValue = [m1, m2];
    var $var68 = void 0;

    if (matchValue[0].Case === "Method") {
        var activePatternResult5448 = _BoundTypeVariables_(matchValue[0].Fields[2]);

        if (matchValue[1].Case === "Method") {
            var activePatternResult5449 = _BoundTypeVariables_(matchValue[1].Fields[2]);

            $var68 = [1, matchValue[0].Fields[1], matchValue[1].Fields[1], matchValue[0].Fields[0], matchValue[1].Fields[0], activePatternResult5448[1], activePatternResult5449[1], activePatternResult5448[0], activePatternResult5449[0]];
        } else {
            $var68 = [2];
        }
    } else if (matchValue[1].Case === "Property") {
        $var68 = [0, matchValue[0].Fields[0], matchValue[1].Fields[0], matchValue[0].Fields[1], matchValue[1].Fields[1]];
    } else {
        $var68 = [2];
    }

    var _ret = function () {
        switch ($var68[0]) {
            case 0:
                if ($var68[1] === $var68[2]) {
                    return {
                        v: typesEqualAux(ctx, $var68[3], $var68[4])
                    };
                } else {
                    return {
                        v: false
                    };
                }

            case 1:
                var ctx_1 = new TypeContext(append$$1(toList(zip($var68[7], $var68[8])), ctx.EquivalentVars));

                if ($var68[3] === $var68[4] ? typesEqualAux(ctx_1, $var68[5], $var68[6]) : false) {
                    return {
                        v: listsEqual($var68[1], $var68[2], function (tupledArg) {
                            return function (tupledArg_1) {
                                return (tupledArg[0] === tupledArg_1[0] ? tupledArg[1] === tupledArg_1[1] : false) ? typesEqualAux(ctx_1, tupledArg[2], tupledArg_1[2]) : false;
                            };
                        })
                    };
                } else {
                    return {
                        v: false
                    };
                }

            case 2:
                return {
                    v: false
                };
        }
    }();

    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}
function typesEqualAux(ctx, t1, t2) {
    var _loop = function _loop() {
        var matchValue = [t1, t2];
        var $var69 = matchValue[0].Case === "Any" ? [0] : matchValue[0].Case === "Parameter" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Parameter" ? [1, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [8] : matchValue[0].Case === "Delayed" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Delayed" ? [2, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [8] : matchValue[0].Case === "List" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "List" ? [3, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [8] : matchValue[0].Case === "Function" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Function" ? [4, matchValue[0].Fields[0], matchValue[1].Fields[0], matchValue[0].Fields[1], matchValue[1].Fields[1]] : [8] : matchValue[0].Case === "Object" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Object" ? [5, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [8] : matchValue[0].Case === "Primitive" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Primitive" ? [6, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [8] : matchValue[0].Case === "Forall" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Forall" ? function () {
            var v2 = matchValue[1].Fields[0];
            var v1 = matchValue[0].Fields[0];
            var t2_3 = matchValue[1].Fields[1];
            var t1_3 = matchValue[0].Fields[1];
            return v1.length === v2.length;
        }() ? [7, matchValue[0].Fields[1], matchValue[1].Fields[1], matchValue[0].Fields[0], matchValue[1].Fields[0]] : [8] : [8] : matchValue[1].Case === "Any" ? [0] : [8];

        switch ($var69[0]) {
            case 0:
                return {
                    v: true
                };

            case 1:
                return {
                    v: exists$1(function (tupledArg) {
                        return tupledArg[0] === $var69[1] ? tupledArg[1] === $var69[2] : false;
                    }, ctx.EquivalentVars)
                };

            case 2:
                return {
                    v: $var69[1] === $var69[2]
                };

            case 3:
                ctx = ctx;
                t1 = $var69[1];
                t2 = $var69[2];
                return "continue|typesEqualAux";

            case 4:
                return {
                    v: listsEqual(new List$2($var69[3], $var69[1]), new List$2($var69[4], $var69[2]), function (t1_1) {
                        return function (t2_1) {
                            return typesEqualAux(ctx, t1_1, t2_1);
                        };
                    })
                };

            case 5:
                return {
                    v: arraysEqual($var69[1].Members, $var69[2].Members, function (m1) {
                        return function (m2) {
                            return membersEqual(ctx, m1, m2);
                        };
                    })
                };

            case 6:
                return {
                    v: $var69[1].Equals($var69[2])
                };

            case 7:
                var ctx_1 = new TypeContext(append$$1(toList(zip($var69[3], $var69[4])), ctx.EquivalentVars));
                ctx = ctx_1;
                t1 = $var69[1];
                t2 = $var69[2];
                return "continue|typesEqualAux";

            case 8:
                var $var70 = matchValue[0].Case === "App" ? matchValue[1].Case === "App" ? function () {
                    var ts2 = matchValue[1].Fields[1];
                    var ts1 = matchValue[0].Fields[1];
                    var t2_2 = matchValue[1].Fields[0];
                    var t1_2 = matchValue[0].Fields[0];
                    return ts1.length === ts2.length;
                }() ? [0, matchValue[0].Fields[0], matchValue[1].Fields[0], matchValue[0].Fields[1], matchValue[1].Fields[1]] : [1] : [1] : [1];

                switch ($var70[0]) {
                    case 0:
                        return {
                            v: forAll$1(function (tupledArg_1) {
                                return typesEqualAux(ctx, tupledArg_1[0], tupledArg_1[1]);
                            }, new List$2([$var70[1], $var70[2]], toList(zip($var70[3], $var70[4]))))
                        };

                    case 1:
                        return {
                            v: false
                        };
                }

        }
    };

    typesEqualAux: while (true) {
        var _ret2 = _loop();

        switch (_ret2) {
            case "continue|typesEqualAux":
                continue typesEqualAux;

            default:
                if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        }
    }
}
var typesEqual = function () {
    var ctx = new TypeContext(new List$2());
    return function (t1) {
        return function (t2) {
            return typesEqualAux(ctx, t1, t2);
        };
    };
}();
function substituteMembers(assigns, members) {
    return members.map(function (_arg1) {
        if (_arg1.Case === "Property") {
            return new Member("Property", [_arg1.Fields[0], substituteTypes(assigns, _arg1.Fields[1]), _arg1.Fields[2], _arg1.Fields[3]]);
        } else {
            var _ret3 = function () {
                var activePatternResult5461 = _BoundTypeVariables_(_arg1.Fields[2]);

                var assigns_2 = function () {
                    var folder = function folder(assigns_1) {
                        return function (_var) {
                            return remove$1(_var, assigns_1);
                        };
                    };

                    return function (list) {
                        return fold$1(function ($var71, $var72) {
                            return folder($var71)($var72);
                        }, assigns, list);
                    };
                }()(activePatternResult5461[0]);

                var ars = map$4(function (tupledArg) {
                    return [tupledArg[0], tupledArg[1], substituteTypes(assigns_2, tupledArg[2])];
                }, _arg1.Fields[1]);
                return {
                    v: new Member("Method", [_arg1.Fields[0], ars, substituteTypes(assigns_2, activePatternResult5461[1]), _arg1.Fields[3], _arg1.Fields[4]])
                };
            }();

            if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
        }
    });
}
function substituteTypes(assigns, t) {
    var $var73 = t.Case === "Parameter" ? assigns.has(t.Fields[0]) ? [0, t.Fields[0]] : [1] : [1];

    switch ($var73[0]) {
        case 0:
            return assigns.get($var73[1]);

        case 1:
            var $var74 = t.Case === "Any" ? [0] : t.Case === "Primitive" ? [0] : t.Case === "Function" ? [1] : t.Case === "List" ? [2] : t.Case === "Object" ? [3] : t.Case === "Delayed" ? [4] : t.Case === "App" ? [5] : t.Case === "Forall" ? [6] : [0];

            switch ($var74[0]) {
                case 0:
                    return t;

                case 1:
                    return new Type("Function", [map$4(function (t_1) {
                        return substituteTypes(assigns, t_1);
                    }, t.Fields[0]), substituteTypes(assigns, t.Fields[1])]);

                case 2:
                    return new Type("List", [substituteTypes(assigns, t.Fields[0])]);

                case 3:
                    return new Type("Object", [new ObjectType(substituteMembers(assigns, t.Fields[0].Members))]);

                case 4:
                    var f = _defineProperty({
                        Then: function (g) {
                            t.Fields[1].Then(function (t_1) {
                                g(substituteTypes(assigns, t_1));
                            });
                        }
                    }, _Symbol.reflection, function () {
                        return {
                            interfaces: ["TheGamma.Common.Future"]
                        };
                    });

                    return new Type("Delayed", [t.Fields[0], f]);

                case 5:
                    return new Type("App", [substituteTypes(assigns, t.Fields[0]), map$4(function (t_2) {
                        return substituteTypes(assigns, t_2);
                    }, t.Fields[1])]);

                case 6:
                    var assigns_2 = function () {
                        var folder = function folder(assigns_1) {
                            return function (_var) {
                                return remove$1(_var, assigns_1);
                            };
                        };

                        return function (list) {
                            return fold$1(function ($var75, $var76) {
                                return folder($var75)($var76);
                            }, assigns, list);
                        };
                    }()(t.Fields[0]);

                    return new Type("Forall", [t.Fields[0], substituteTypes(assigns_2, t.Fields[1])]);
            }

    }
}
var UnifictionContext = function () {
    function UnifictionContext(freeVars, assignments, equivalentVars, errors) {
        _classCallCheck(this, UnifictionContext);

        this.FreeVars = freeVars;
        this.Assignments = assignments;
        this.EquivalentVars = equivalentVars;
        this.Errors = errors;
    }

    _createClass(UnifictionContext, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Types.UnifictionContext",
                interfaces: ["FSharpRecord"],
                properties: {
                    FreeVars: makeGeneric(FableSet, {
                        T: "string"
                    }),
                    Assignments: makeGeneric(List$2, {
                        T: Tuple(["string", Type])
                    }),
                    EquivalentVars: makeGeneric(List$2, {
                        T: Tuple(["string", "string"])
                    }),
                    Errors: makeGeneric(List$2, {
                        T: Tuple([Type, Type])
                    })
                }
            };
        }
    }]);

    return UnifictionContext;
}();
setType("TheGamma.Types.UnifictionContext", UnifictionContext);
function unifyTypesAux(ctx, ts1, ts2) {
    var _loop2 = function _loop2() {
        var matchValue = [ts1, ts2];
        var $var77 = matchValue[0].tail != null ? matchValue[0].head.Case === "Parameter" ? matchValue[1].tail != null ? function () {
            var ts2_4 = matchValue[1].tail;
            var ts1_4 = matchValue[0].tail;
            var t = matchValue[1].head;
            var n = matchValue[0].head.Fields[0];

            if (ctx.FreeVars.has(n)) {
                if (t.Case === "Parameter") {
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        }() ? [0, matchValue[0].head.Fields[0], matchValue[1].head, matchValue[0].tail, matchValue[1].tail] : [1] : [1] : [1] : [1];

        switch ($var77[0]) {
            case 0:
                ctx = function () {
                    var Assignments = new List$2([$var77[1], $var77[2]], ctx.Assignments);
                    return new UnifictionContext(ctx.FreeVars, Assignments, ctx.EquivalentVars, ctx.Errors);
                }();

                ts1 = $var77[3];
                ts2 = $var77[4];
                return "continue|unifyTypesAux";

            case 1:
                var $var78 = matchValue[0].tail != null ? matchValue[0].head.Case === "Function" ? matchValue[1].tail != null ? matchValue[1].head.Case === "Function" ? [0, matchValue[0].head.Fields[0], matchValue[1].head.Fields[0], matchValue[0].head.Fields[1], matchValue[1].head.Fields[1], matchValue[0].tail, matchValue[1].tail] : [2] : [2] : matchValue[0].head.Case === "Object" ? matchValue[1].tail != null ? matchValue[1].head.Case === "Object" ? function () {
                    var ts2_3 = matchValue[1].tail;
                    var ts1_3 = matchValue[0].tail;
                    var m2 = matchValue[1].head.Fields[0].Members;
                    var m1 = matchValue[0].head.Fields[0].Members;
                    return arraysEqual(m1, m2, function (m1_1) {
                        return function (m2_1) {
                            return memberNamesEqual(m1_1, m2_1);
                        };
                    });
                }() ? [1, matchValue[0].head.Fields[0].Members, matchValue[1].head.Fields[0].Members, matchValue[0].tail, matchValue[1].tail] : [2] : [2] : [2] : [2] : [2];

                switch ($var78[0]) {
                    case 0:
                        ctx = ctx;
                        ts1 = append$$1(new List$2($var78[3], $var78[1]), $var78[5]);
                        ts2 = append$$1(new List$2($var78[4], $var78[2]), $var78[6]);
                        return "continue|unifyTypesAux";

                    case 1:
                        ctx = ctx;
                        ts1 = $var78[3];
                        ts2 = $var78[4];
                        return "continue|unifyTypesAux";

                    case 2:
                        var $var79 = matchValue[0].tail != null ? matchValue[0].head.Case === "List" ? matchValue[1].tail != null ? matchValue[1].head.Case === "List" ? [0, matchValue[0].head.Fields[0], matchValue[1].head.Fields[0], matchValue[0].tail, matchValue[1].tail] : [2] : [2] : matchValue[0].head.Case === "Forall" ? matchValue[1].tail != null ? matchValue[1].head.Case === "Forall" ? function () {
                            var v2 = matchValue[1].head.Fields[0];
                            var v1 = matchValue[0].head.Fields[0];
                            var ts2_2 = matchValue[1].tail;
                            var ts1_2 = matchValue[0].tail;
                            var t2_2 = matchValue[1].head.Fields[1];
                            var t1_2 = matchValue[0].head.Fields[1];
                            return v1.length === v2.length;
                        }() ? [1, matchValue[0].head.Fields[1], matchValue[1].head.Fields[1], matchValue[0].tail, matchValue[1].tail, matchValue[0].head.Fields[0], matchValue[1].head.Fields[0]] : [2] : [2] : [2] : [2] : [2];

                        switch ($var79[0]) {
                            case 0:
                                ctx = ctx;
                                ts1 = new List$2($var79[1], $var79[3]);
                                ts2 = new List$2($var79[2], $var79[4]);
                                return "continue|unifyTypesAux";

                            case 1:
                                var ctx_1 = void 0;
                                var EquivalentVars = append$$1(toList(zip($var79[5], $var79[6])), ctx.EquivalentVars);
                                ctx_1 = new UnifictionContext(ctx.FreeVars, ctx.Assignments, EquivalentVars, ctx.Errors);
                                ctx = ctx_1;
                                ts1 = new List$2($var79[1], $var79[3]);
                                ts2 = new List$2($var79[2], $var79[4]);
                                return "continue|unifyTypesAux";

                            case 2:
                                var $var80 = matchValue[0].tail != null ? matchValue[0].head.Case === "App" ? matchValue[1].tail != null ? matchValue[1].head.Case === "App" ? function () {
                                    var tb2 = matchValue[1].tail;
                                    var tb1 = matchValue[0].tail;
                                    var ta2 = matchValue[1].head.Fields[1];
                                    var ta1 = matchValue[0].head.Fields[1];
                                    var t2_1 = matchValue[1].head.Fields[0];
                                    var t1_1 = matchValue[0].head.Fields[0];
                                    return ta1.length === ta2.length;
                                }() ? [0, matchValue[0].head.Fields[0], matchValue[1].head.Fields[0], matchValue[0].head.Fields[1], matchValue[1].head.Fields[1], matchValue[0].tail, matchValue[1].tail] : [1] : [1] : [1] : [1] : [1];

                                switch ($var80[0]) {
                                    case 0:
                                        ctx = ctx;
                                        ts1 = new List$2($var80[1], append$$1($var80[3], $var80[5]));
                                        ts2 = new List$2($var80[2], append$$1($var80[4], $var80[6]));
                                        return "continue|unifyTypesAux";

                                    case 1:
                                        var $var81 = matchValue[0].tail != null ? matchValue[1].tail != null ? function () {
                                            var ts2_1 = matchValue[1].tail;
                                            var ts1_1 = matchValue[0].tail;
                                            var t2 = matchValue[1].head;
                                            var t1 = matchValue[0].head;
                                            return typesEqualAux(new TypeContext(ctx.EquivalentVars), t1, t2);
                                        }() ? [0, matchValue[0].head, matchValue[1].head, matchValue[0].tail, matchValue[1].tail] : [1] : [1] : [1];

                                        var _ret5 = function () {
                                            switch ($var81[0]) {
                                                case 0:
                                                    ctx = ctx;
                                                    ts1 = $var81[3];
                                                    ts2 = $var81[4];
                                                    return {
                                                        v: "continue|unifyTypesAux"
                                                    };

                                                case 1:
                                                    var $var82 = matchValue[0].tail == null ? matchValue[1].tail == null ? [1] : [2] : matchValue[1].tail != null ? [0, matchValue[0].head, matchValue[1].head, matchValue[0].tail, matchValue[1].tail] : [2];

                                                    switch ($var82[0]) {
                                                        case 0:
                                                            ctx = function () {
                                                                var Errors = new List$2([$var82[1], $var82[2]], ctx.Errors);
                                                                return new UnifictionContext(ctx.FreeVars, ctx.Assignments, ctx.EquivalentVars, Errors);
                                                            }();

                                                            ts1 = $var82[3];
                                                            ts2 = $var82[4];
                                                            return {
                                                                v: "continue|unifyTypesAux"
                                                            };

                                                        case 1:
                                                            return {
                                                                v: {
                                                                    v: ctx
                                                                }
                                                            };

                                                        case 2:
                                                            throw new Error("unifyTypesAux: The lists of types had mismatching lengths");
                                                    }

                                            }
                                        }();

                                        if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
                                }

                        }

                }

        }
    };

    unifyTypesAux: while (true) {
        var _ret4 = _loop2();

        switch (_ret4) {
            case "continue|unifyTypesAux":
                continue unifyTypesAux;

            default:
                if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
        }
    }
}
function unifyTypes(free, ts1, ts2) {
    var ctx = new UnifictionContext(create$2(free, new GenericComparer(compare)), new List$2(), new List$2(), new List$2());
    var ctx_1 = unifyTypesAux(ctx, ofArray([ts1]), ofArray([ts2]));
    return [ctx_1.Assignments, ctx_1.Errors];
}
function reduceType(t) {
    reduceType: while (true) {
        var $var83 = t.Case === "App" ? t.Fields[0].Case === "Forall" ? [0, t.Fields[1], t.Fields[0].Fields[1], t.Fields[0].Fields[0]] : [1] : [1];

        switch ($var83[0]) {
            case 0:
                if ($var83[3].length !== $var83[1].length) {
                    throw new Error("reduceType: Invalid type application");
                }

                var t_1 = substituteTypes(create$3(toList(zip($var83[3], $var83[1])), new GenericComparer(compare)), $var83[2]);
                t = t_1;
                continue reduceType;

            case 1:
                return t;
        }
    }
}

var Lazy = (function () {
    function Lazy(factory) {
        this.factory = factory;
        this.isValueCreated = false;
    }
    Object.defineProperty(Lazy.prototype, "value", {
        get: function () {
            if (!this.isValueCreated) {
                this.createdValue = this.factory();
                this.isValueCreated = true;
            }
            return this.createdValue;
        },
        enumerable: true,
        configurable: true
    });
    return Lazy;
}());

function node(rng, node_1) {
  var Entity$$1 = null;
  var WhiteBefore = new List$2();
  var WhiteAfter = new List$2();
  return new _Node(WhiteBefore, WhiteAfter, rng, node_1, Entity$$1);
}
function needsEscaping(s) {
  if (s[0] >= "0" ? s[0] <= "9" : false) {
    return true;
  } else {
    return s.split("").some(function (c) {
      return !(((c >= "a" ? c <= "z" : false) ? true : c >= "A" ? c <= "Z" : false) ? true : c >= "0" ? c <= "9" : false);
    });
  }
}
function escapeIdent(s) {
  if (needsEscaping(s)) {
    return "'" + s + "'";
  } else {
    return s;
  }
}
function unionRanges(r1, r2) {
  return new _Range(r1.Start < r2.Start ? r1.Start : r2.Start, r1.End > r2.End ? r1.End : r2.End);
}
function strictSubRange(first, second) {
  if (first.Start > second.Start ? first.End <= second.End : false) {
    return true;
  } else if (first.Start >= second.Start) {
    return first.End < second.End;
  } else {
    return false;
  }
}
function formatToken(_arg1) {
  var $var59 = _arg1.Case === "RParen" ? [1] : _arg1.Case === "Equals" ? [2] : _arg1.Case === "Dot" ? [3] : _arg1.Case === "Comma" ? [4] : _arg1.Case === "Let" ? [5] : _arg1.Case === "LSquare" ? [6] : _arg1.Case === "RSquare" ? [7] : _arg1.Case === "Fun" ? [8] : _arg1.Case === "Arrow" ? [9] : _arg1.Case === "Operator" ? _arg1.Fields[0].Case === "GreaterThan" ? [11] : _arg1.Fields[0].Case === "GreaterThanOrEqual" ? [12] : _arg1.Fields[0].Case === "LessThan" ? [13] : _arg1.Fields[0].Case === "LessThanOrEqual" ? [14] : _arg1.Fields[0].Case === "Minus" ? [15] : _arg1.Fields[0].Case === "Multiply" ? [16] : _arg1.Fields[0].Case === "Plus" ? [17] : _arg1.Fields[0].Case === "Power" ? [18] : _arg1.Fields[0].Case === "Equals" ? [19] : [10] : _arg1.Case === "Boolean" ? _arg1.Fields[0] ? [20] : [21] : _arg1.Case === "Number" ? [22, _arg1.Fields[0]] : _arg1.Case === "String" ? [23, _arg1.Fields[0]] : _arg1.Case === "Ident" ? [24, _arg1.Fields[0]] : _arg1.Case === "QIdent" ? [25, _arg1.Fields[0]] : _arg1.Case === "White" ? [26, _arg1.Fields[0]] : _arg1.Case === "Newline" ? [27] : _arg1.Case === "Error" ? [28, _arg1.Fields[0]] : _arg1.Case === "EndOfFile" ? [29] : _arg1.Case === "By" ? [30] : _arg1.Case === "To" ? [30] : [0];

  switch ($var59[0]) {
    case 0:
      return "(";

    case 1:
      return ")";

    case 2:
      return "=";

    case 3:
      return ".";

    case 4:
      return ",";

    case 5:
      return "let";

    case 6:
      return "[";

    case 7:
      return "]";

    case 8:
      return "fun";

    case 9:
      return "->";

    case 10:
      return "/";

    case 11:
      return ">";

    case 12:
      return ">=";

    case 13:
      return "<";

    case 14:
      return "<=";

    case 15:
      return "-";

    case 16:
      return "*";

    case 17:
      return "+";

    case 18:
      return "^";

    case 19:
      return "=";

    case 20:
      return "true";

    case 21:
      return "false";

    case 22:
      return $var59[1];

    case 23:
      return "\"" + replace$$1(replace$$1(replace$$1($var59[1], "\\", "\\\\"), "\n", "\\n"), "\"", "\\\"") + "\"";

    case 24:
      return $var59[1];

    case 25:
      return "'" + $var59[1] + "'";

    case 26:
      return $var59[1];

    case 27:
      return "\n";

    case 28:
      return $var59[1];

    case 29:
      return "";

    case 30:
      throw new Error("Unsupported token");
  }
}
function formatTokenInfo(_arg1) {
  var $var60 = _arg1.Case === "RParen" ? [1] : _arg1.Case === "Equals" ? [2] : _arg1.Case === "Dot" ? [3] : _arg1.Case === "Comma" ? [4] : _arg1.Case === "Let" ? [5] : _arg1.Case === "LSquare" ? [6] : _arg1.Case === "RSquare" ? [7] : _arg1.Case === "Fun" ? [8] : _arg1.Case === "Arrow" ? [9] : _arg1.Case === "Operator" ? _arg1.Fields[0].Case === "Divide" ? [11] : _arg1.Fields[0].Case === "GreaterThan" ? [12] : _arg1.Fields[0].Case === "GreaterThanOrEqual" ? [13] : _arg1.Fields[0].Case === "LessThan" ? [14] : _arg1.Fields[0].Case === "LessThanOrEqual" ? [15] : _arg1.Fields[0].Case === "Minus" ? [16] : _arg1.Fields[0].Case === "Multiply" ? [17] : _arg1.Fields[0].Case === "Plus" ? [18] : _arg1.Fields[0].Case === "Power" ? [19] : [10] : _arg1.Case === "Boolean" ? _arg1.Fields[0] ? [20] : [21] : _arg1.Case === "Number" ? [22, _arg1.Fields[0]] : _arg1.Case === "String" ? [23, _arg1.Fields[0]] : _arg1.Case === "Ident" ? [24, _arg1.Fields[0]] : _arg1.Case === "QIdent" ? [25, _arg1.Fields[0]] : _arg1.Case === "White" ? [26, _arg1.Fields[0]] : _arg1.Case === "Newline" ? [27] : _arg1.Case === "Error" ? _arg1.Fields[0] === "`" ? [28] : [29, _arg1.Fields[0]] : _arg1.Case === "EndOfFile" ? [30] : _arg1.Case === "By" ? [31] : _arg1.Case === "To" ? [31] : [0];

  switch ($var60[0]) {
    case 0:
      return "left parenthesis `(`";

    case 1:
      return "right parenthesis `)`";

    case 2:
      return "equals sign `=`";

    case 3:
      return "dot character `.`";

    case 4:
      return "comma character `,`";

    case 5:
      return "`let` keyword";

    case 6:
      return "left square bracket `[`";

    case 7:
      return "right square bracket `]`";

    case 8:
      return "`fun` keyword";

    case 9:
      return "arrow sign `->`";

    case 10:
      return "equals operator `=`";

    case 11:
      return "division sign `/`";

    case 12:
      return "greater than sign `>`";

    case 13:
      return "greater than or equals sign `>=`";

    case 14:
      return "less than sign `<`";

    case 15:
      return "less than or equals sign `<=`";

    case 16:
      return "minus sign `-`";

    case 17:
      return "multiplication sign `*`";

    case 18:
      return "plus sign `+`";

    case 19:
      return "exponentiation sign `^`";

    case 20:
      return "logical `true` value";

    case 21:
      return "logical `false` value";

    case 22:
      return fsFormat("numerical value `%s`")(function (x) {
        return x;
      })($var60[1]);

    case 23:
      return fsFormat("string value `%s`")(function (x) {
        return x;
      })(replace$$1($var60[1], "`", "'"));

    case 24:
      return fsFormat("identifer `%s`")(function (x) {
        return x;
      })($var60[1]);

    case 25:
      return fsFormat("quoted identifer `'%s'`")(function (x) {
        return x;
      })($var60[1]);

    case 26:
      return "whitespace";

    case 27:
      return "end of line";

    case 28:
      return "back-tick character";

    case 29:
      return fsFormat("other character `%s`")(function (x) {
        return x;
      })($var60[1]);

    case 30:
      return "end of file";

    case 31:
      throw new Error("Unsupported token");
  }
}

var FormattingContext = function () {
  function FormattingContext(strings) {
    _classCallCheck(this, FormattingContext);

    this.Strings = strings;
  }

  _createClass(FormattingContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Ast.FormattingContext",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Strings: FableArray("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "Add",
    value: function (tok) {
      this.Strings.push(formatToken(tok));
    }
  }]);

  return FormattingContext;
}();
setType("TheGamma.Ast.FormattingContext", FormattingContext);
function formatNode(ctx, f, node_1) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(node_1.WhiteBefore), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var t = _step.value;
      ctx.Add(t.Token);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  f(ctx)(node_1.Node);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _getIterator(node_1.WhiteAfter), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var t_1 = _step2.value;
      ctx.Add(t_1.Token);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}
function formatName(ctx, name) {
  if (name.Name === "") {} else if (needsEscaping(name.Name)) {
    ctx.Add(new TokenKind("QIdent", [name.Name]));
  } else {
    ctx.Add(new TokenKind("Ident", [name.Name]));
  }
}
function formatArgument(ctx, arg) {
  if (arg.Name != null) {
    formatNode(ctx, function (ctx_1) {
      return function (name) {
        formatName(ctx_1, name);
      };
    }, arg.Name);
    ctx.Add(new TokenKind("Equals", []));
  }

  formatNode(ctx, function (ctx_2) {
    return function (expr) {
      formatExpression(ctx_2, expr);
    };
  }, arg.Value);
}
function formatExpression(ctx, expr) {
  if (expr.Case === "Property") {
    formatNode(ctx, function (ctx_1) {
      return function (expr_1) {
        formatExpression(ctx_1, expr_1);
      };
    }, expr.Fields[0]);
    ctx.Add(new TokenKind("Dot", []));
    formatNode(ctx, function (ctx_2) {
      return function (name) {
        formatName(ctx_2, name);
      };
    }, expr.Fields[1]);
  } else if (expr.Case === "Call") {
    if (expr.Fields[0] != null) {
      formatNode(ctx, function (ctx_3) {
        return function (expr_2) {
          formatExpression(ctx_3, expr_2);
        };
      }, expr.Fields[0]);
    }

    ctx.Add(new TokenKind("Dot", []));
    formatNode(ctx, function (ctx_4) {
      return function (name_1) {
        formatName(ctx_4, name_1);
      };
    }, expr.Fields[1]);
    ctx.Add(new TokenKind("LParen", []));
    (function () {
      var f = function f(ctx_5) {
        return function (args) {
          iterateIndexed(function (i, arg) {
            if (i !== 0) {
              ctx_5.Add(new TokenKind("Comma", []));
            }

            formatArgument(ctx_5, arg);
          }, args);
        };
      };

      return function (node_1) {
        formatNode(ctx, f, node_1);
      };
    })()(expr.Fields[2]);
    ctx.Add(new TokenKind("RParen", []));
  } else if (expr.Case === "String") {
    ctx.Add(new TokenKind("String", [expr.Fields[0]]));
  } else if (expr.Case === "Number") {
    ctx.Add(new TokenKind("Number", [String(expr.Fields[0]), expr.Fields[0]]));
  } else if (expr.Case === "Boolean") {
    ctx.Add(new TokenKind("Boolean", [expr.Fields[0]]));
  } else if (expr.Case === "Binary") {
    formatNode(ctx, function (ctx_6) {
      return function (expr_3) {
        formatExpression(ctx_6, expr_3);
      };
    }, expr.Fields[0]);
    (function () {
      var f_1 = function f_1(ctx_7) {
        return function (op) {
          ctx_7.Add(new TokenKind("Operator", [op]));
        };
      };

      return function (node_2) {
        formatNode(ctx, f_1, node_2);
      };
    })()(expr.Fields[1]);
    formatNode(ctx, function (ctx_8) {
      return function (expr_4) {
        formatExpression(ctx_8, expr_4);
      };
    }, expr.Fields[2]);
  } else if (expr.Case === "Function") {
    ctx.Add(new TokenKind("Fun", []));
    formatNode(ctx, function (ctx_9) {
      return function (name_2) {
        formatName(ctx_9, name_2);
      };
    }, expr.Fields[0]);
    ctx.Add(new TokenKind("Arrow", []));
    formatNode(ctx, function (ctx_10) {
      return function (expr_5) {
        formatExpression(ctx_10, expr_5);
      };
    }, expr.Fields[1]);
  } else if (expr.Case === "List") {
    ctx.Add(new TokenKind("LSquare", []));
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(expr.Fields[0]), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var e = _step3.value;
        formatNode(ctx, function (ctx_11) {
          return function (expr_6) {
            formatExpression(ctx_11, expr_6);
          };
        }, e);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    ctx.Add(new TokenKind("RSquare", []));
  } else if (expr.Case === "Empty") {} else {
    formatNode(ctx, function (ctx_12) {
      return function (name_3) {
        formatName(ctx_12, name_3);
      };
    }, expr.Fields[0]);
  }
}

function formatSingleExpression(expr) {
  var ctx = new FormattingContext([]);
  formatNode(ctx, function (ctx_1) {
    return function (expr_1) {
      formatExpression(ctx_1, expr_1);
    };
  }, expr);
  return join("", ctx.Strings);
}

function formatWhiteAfterExpr(nd) {
  var wa = void 0;
  var $var61 = nd.Node.Case === "Variable" ? [0, nd.Node.Fields[0]] : nd.Node.Case === "Property" ? [0, nd.Node.Fields[1]] : [1];

  switch ($var61[0]) {
    case 0:
      wa = append$$1($var61[1].WhiteAfter, nd.WhiteAfter);
      break;

    case 1:
      wa = nd.WhiteAfter;
      break;
  }

  return join("", toList(delay(function () {
    return map$5(function (t) {
      return formatToken(t.Token);
    }, wa);
  })));
}
function formatWhiteBeforeExpr(nd) {
  var wa = void 0;
  var $var62 = nd.Node.Case === "Variable" ? [0] : nd.Node.Case === "Call" ? [1, nd.Node.Fields[1]] : nd.Node.Case === "Property" ? [1, nd.Node.Fields[1]] : [2];

  switch ($var62[0]) {
    case 0:
      wa = append$$1(nd.WhiteBefore, nd.Node.Fields[0].WhiteBefore);
      break;

    case 1:
      wa = $var62[1].WhiteBefore;
      break;

    case 2:
      wa = nd.WhiteBefore;
      break;
  }

  return join("", toList(delay(function () {
    return map$5(function (t) {
      return formatToken(t.Token);
    }, wa);
  })));
}
function formatEntityKind(_arg1) {
  if (_arg1.Case === "Variable") {
    return "variable";
  } else if (_arg1.Case === "Binding") {
    return "binding";
  } else if (_arg1.Case === "Operator") {
    return formatToken(new TokenKind("Operator", [_arg1.Fields[1]])) + " operator";
  } else if (_arg1.Case === "List") {
    return "list";
  } else if (_arg1.Case === "Constant") {
    if (_arg1.Fields[0].Case === "Number") {
      return fsFormat("number `%f`")(function (x) {
        return x;
      })(_arg1.Fields[0].Fields[0]);
    } else if (_arg1.Fields[0].Case === "String") {
      return fsFormat("string `%s`")(function (x) {
        return x;
      })(_arg1.Fields[0].Fields[0]);
    } else if (_arg1.Fields[0].Case === "Boolean") {
      if (_arg1.Fields[0].Fields[0]) {
        return "`true` value";
      } else {
        return "`false` value";
      }
    } else {
      return "empty value";
    }
  } else if (_arg1.Case === "Function") {
    return "function";
  } else if (_arg1.Case === "LetCommand") {
    return "let command";
  } else if (_arg1.Case === "RunCommand") {
    return "run command";
  } else if (_arg1.Case === "Program") {
    return "program";
  } else if (_arg1.Case === "Root") {
    return "root";
  } else if (_arg1.Case === "CallSite") {
    return "call site";
  } else if (_arg1.Case === "NamedParam") {
    return "named param";
  } else if (_arg1.Case === "ChainElement") {
    return "chain element";
  } else if (_arg1.Case === "ArgumentList") {
    return "argument list";
  } else if (_arg1.Case === "NamedMember") {
    return "property or method";
  } else {
    return "global value";
  }
}
var anonymous = "";
function entityCodeNameAndAntecedents(_arg1) {
  if (_arg1.Case === "Program") {
    return [1, _arg1.Fields[0], anonymous];
  } else if (_arg1.Case === "RunCommand") {
    return [2, ofArray([_arg1.Fields[0]]), anonymous];
  } else if (_arg1.Case === "LetCommand") {
    return [3, ofArray([_arg1.Fields[0], _arg1.Fields[1]]), anonymous];
  } else if (_arg1.Case === "Operator") {
    return [4, ofArray([_arg1.Fields[0], _arg1.Fields[2]]), formatToken(new TokenKind("Operator", [_arg1.Fields[1]]))];
  } else if (_arg1.Case === "List") {
    return [5, _arg1.Fields[0], anonymous];
  } else if (_arg1.Case === "Constant") {
    if (_arg1.Fields[0].Case === "Number") {
      return [7, new List$2(), String(_arg1.Fields[0].Fields[0])];
    } else if (_arg1.Fields[0].Case === "Boolean") {
      return [8, new List$2(), String(_arg1.Fields[0].Fields[0])];
    } else if (_arg1.Fields[0].Case === "Empty") {
      return [9, new List$2(), anonymous];
    } else {
      return [6, new List$2(), _arg1.Fields[0].Fields[0]];
    }
  } else if (_arg1.Case === "Function") {
    return [10, ofArray([_arg1.Fields[0], _arg1.Fields[1]]), anonymous];
  } else if (_arg1.Case === "GlobalValue") {
    return [11, new List$2(), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "Variable") {
    return [12, ofArray([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "Binding") {
    return [13, ofArray([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "ArgumentList") {
    return [14, _arg1.Fields[0], anonymous];
  } else if (_arg1.Case === "CallSite") {
    if (_arg1.Fields[2].Case === "Choice2Of2") {
      return [16, ofArray([_arg1.Fields[0]]), _arg1.Fields[1].Name + "." + String(_arg1.Fields[2].Fields[0])];
    } else {
      return [15, ofArray([_arg1.Fields[0]]), _arg1.Fields[1].Name + "." + _arg1.Fields[2].Fields[0]];
    }
  } else if (_arg1.Case === "NamedParam") {
    return [17, ofArray([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "NamedMember") {
    return [18, ofArray([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "ChainElement") {
    return [19, choose$$1(function (x) {
      return x;
    }, ofArray([_arg1.Fields[2], _arg1.Fields[3], _arg1.Fields[4]])), _arg1.Fields[1].Name + "." + String(_arg1.Fields[0])];
  } else {
    return [0, new List$2(), anonymous];
  }
}

function Entity_get_Antecedents() {
  var patternInput = entityCodeNameAndAntecedents(this.Kind);
  return patternInput[1];
}

function Entity_get_Name() {
  var patternInput = entityCodeNameAndAntecedents(this.Kind);
  return patternInput[2];
}


function formatTypeInfo(_arg1) {
  if (_arg1.Case === "Parameter") {
    return "unresolved type parameter";
  } else if (_arg1.Case === "App") {
    return "unresolved type application";
  } else if (_arg1.Case === "Delayed") {
    return "delayed type";
  } else if (_arg1.Case === "Primitive") {
    if (_arg1.Fields[0].Case === "Number") {
      return "number";
    } else if (_arg1.Fields[0].Case === "String") {
      return "string";
    } else if (_arg1.Fields[0].Case === "Unit") {
      return "unit";
    } else {
      return "boolean";
    }
  } else if (_arg1.Case === "Object") {
    return "object type";
  } else if (_arg1.Case === "Function") {
    return "function type";
  } else if (_arg1.Case === "List") {
    return "list type";
  } else if (_arg1.Case === "Any") {
    return "unknown";
  } else {
    return "generic type";
  }
}
function rebuildExprNode(e, es, ns) {
  var matchValue = [e, es, ns];
  var $var63 = matchValue[0].Case === "Function" ? matchValue[1].tail != null ? matchValue[1].tail.tail == null ? matchValue[2].tail != null ? matchValue[2].tail.tail == null ? [1, matchValue[1].head, matchValue[2].head] : [10] : [10] : [10] : [10] : matchValue[0].Case === "Property" ? matchValue[1].tail != null ? matchValue[1].tail.tail == null ? matchValue[2].tail != null ? matchValue[2].tail.tail == null ? [2, matchValue[1].head, matchValue[2].head] : [7] : [7] : [7] : [7] : matchValue[0].Case === "Binary" ? matchValue[1].tail != null ? matchValue[1].tail.tail != null ? matchValue[1].tail.tail.tail == null ? matchValue[2].tail == null ? [3, matchValue[1].head, matchValue[1].tail.head, matchValue[0].Fields[1]] : [11] : [11] : [11] : [11] : matchValue[0].Case === "Call" ? matchValue[1].tail != null ? matchValue[2].tail != null ? [4, matchValue[0].Fields[2], matchValue[1].head, matchValue[1].tail, matchValue[0].Fields[0], matchValue[2].head, matchValue[2].tail] : [8] : [8] : matchValue[0].Case === "Variable" ? matchValue[1].tail == null ? matchValue[2].tail != null ? matchValue[2].tail.tail == null ? [5, matchValue[2].head] : [6] : [6] : [6] : matchValue[0].Case === "Number" ? [12] : matchValue[0].Case === "Boolean" ? [12] : matchValue[0].Case === "String" ? [12] : matchValue[0].Case === "Empty" ? [12] : matchValue[2].tail == null ? [0, matchValue[1]] : [9];

  var _ret = function () {
    switch ($var63[0]) {
      case 0:
        return {
          v: new Expr("List", [$var63[1]])
        };

      case 1:
        return {
          v: new Expr("Function", [$var63[2], $var63[1]])
        };

      case 2:
        return {
          v: new Expr("Property", [$var63[1], $var63[2]])
        };

      case 3:
        return {
          v: new Expr("Binary", [$var63[1], $var63[3], $var63[2]])
        };

      case 4:
        var patternInput = function () {
          return $var63[4] != null;
        }(null) ? [$var63[2], $var63[3]] : [null, new List$2($var63[2], $var63[3])];

        var rebuildArgs = function rebuildArgs(args) {
          return function (es_1) {
            return function (ns_1) {
              var matchValue_1 = [args, es_1, ns_1];
              var $var64 = matchValue_1[0].tail == null ? matchValue_1[1].tail == null ? matchValue_1[2].tail == null ? [2] : [3] : [3] : matchValue_1[0].head.Name != null ? matchValue_1[1].tail != null ? matchValue_1[2].tail != null ? [1, matchValue_1[0].tail, matchValue_1[1].head, matchValue_1[1].tail, matchValue_1[2].head, matchValue_1[2].tail] : [3] : [3] : matchValue_1[1].tail != null ? [0, matchValue_1[0].tail, matchValue_1[1].head, matchValue_1[1].tail, matchValue_1[2]] : [3];

              switch ($var64[0]) {
                case 0:
                  return new List$2(new Argument(null, $var64[2]), rebuildArgs($var64[1])($var64[3])($var64[4]));

                case 1:
                  return new List$2(new Argument($var64[4], $var64[2]), rebuildArgs($var64[1])($var64[3])($var64[5]));

                case 2:
                  return new List$2();

                case 3:
                  throw new Error("rebuildExprNode: Wrong call length");
              }
            };
          };
        };

        return {
          v: new Expr("Call", [patternInput[0], $var63[5], function () {
            var _Node$$1 = rebuildArgs($var63[1].Node)(patternInput[1])($var63[6]);

            return new _Node($var63[1].WhiteBefore, $var63[1].WhiteAfter, $var63[1].Range, _Node$$1, $var63[1].Entity);
          }()])
        };

      case 5:
        return {
          v: new Expr("Variable", [$var63[1]])
        };

      case 6:
        throw new Error("rebuildExprNode: Wrong variable length");

      case 7:
        throw new Error("rebuildExprNode: Wrong property length");

      case 8:
        throw new Error("rebuildExprNode: Wrong call length");

      case 9:
        throw new Error("rebuildExprNode: Wrong list length");

      case 10:
        throw new Error("rebuildExprNode: Wrong function length");

      case 11:
        throw new Error("rebuildExprNode: Wrong binary operator argument length");

      case 12:
        throw new Error("rebuildExprNode: Not a node");
    }
  }();

  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}

function _ExprLeaf_ExprNode_(e) {
  var $var65 = e.Case === "Call" ? e.Fields[0] == null ? [2, e.Fields[2], e.Fields[1]] : [1, e.Fields[2], e.Fields[0], e.Fields[1]] : e.Case === "Variable" ? [3, e.Fields[0]] : e.Case === "List" ? [4, e.Fields[0]] : e.Case === "Function" ? [5, e.Fields[1], e.Fields[0]] : e.Case === "Binary" ? [6, e.Fields[0], e.Fields[1], e.Fields[2]] : e.Case === "Number" ? [7] : e.Case === "Boolean" ? [7] : e.Case === "String" ? [7] : e.Case === "Empty" ? [7] : [0, e.Fields[0], e.Fields[1]];

  switch ($var65[0]) {
    case 0:
      return new Choice("Choice2Of2", [[ofArray([$var65[1]]), ofArray([$var65[2]])]]);

    case 1:
      return new Choice("Choice2Of2", [[new List$2($var65[2], toList(delay(function () {
        return map$5(function (a) {
          return a.Value;
        }, $var65[1].Node);
      }))), new List$2($var65[3], choose$$1(function (a_1) {
        return a_1.Name;
      }, $var65[1].Node))]]);

    case 2:
      return new Choice("Choice2Of2", [[toList(delay(function () {
        return map$5(function (a_2) {
          return a_2.Value;
        }, $var65[1].Node);
      })), new List$2($var65[2], choose$$1(function (a_3) {
        return a_3.Name;
      }, $var65[1].Node))]]);

    case 3:
      return new Choice("Choice2Of2", [[new List$2(), ofArray([$var65[1]])]]);

    case 4:
      return new Choice("Choice2Of2", [[$var65[1], new List$2()]]);

    case 5:
      return new Choice("Choice2Of2", [[ofArray([$var65[1]]), ofArray([$var65[2]])]]);

    case 6:
      return new Choice("Choice2Of2", [[ofArray([$var65[1], $var65[3]]), new List$2()]]);

    case 7:
      return new Choice("Choice1Of2", [null]);
  }
}

var BabelOptions = function () {
  function BabelOptions(presets) {
    _classCallCheck(this, BabelOptions);

    this.presets = presets;
  }

  _createClass(BabelOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interpreter.BabelOptions",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          presets: FableArray("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return BabelOptions;
}();
setType("TheGamma.Interpreter.BabelOptions", BabelOptions);
var BabelResult = function () {
  function BabelResult(code) {
    _classCallCheck(this, BabelResult);

    this.code = code;
  }

  _createClass(BabelResult, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interpreter.BabelResult",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          code: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return BabelResult;
}();
setType("TheGamma.Interpreter.BabelResult", BabelResult);
var EvaluationContext = function () {
  function EvaluationContext(globals) {
    _classCallCheck(this, EvaluationContext);

    this.Globals = globals;
  }

  _createClass(EvaluationContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interpreter.EvaluationContext",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Globals: Interface("System.Collections.Generic.IDictionary")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return EvaluationContext;
}();
setType("TheGamma.Interpreter.EvaluationContext", EvaluationContext);

function _FindProperty___(name, _arg1) {
  return tryPick(function (_arg2) {
    var $var136 = _arg2.Case === "Property" ? _arg2.Fields[0] === name.Name ? [0, _arg2.Fields[3], _arg2.Fields[0]] : [1] : [1];

    switch ($var136[0]) {
      case 0:
        return $var136[1];

      case 1:
        return null;
    }
  }, _arg1.Members);
}

function _FindMethod___(name, _arg1) {
  return tryPick(function (_arg2) {
    var $var137 = _arg2.Case === "Method" ? _arg2.Fields[0] === name.Name ? [0, _arg2.Fields[1], _arg2.Fields[4], _arg2.Fields[0]] : [1] : [1];

    switch ($var137[0]) {
      case 0:
        return [$var137[1], $var137[2]];

      case 1:
        return null;
    }
  }, _arg1.Members);
}

function storeArguments(values) {
  return [_Array$from(values), mapIndexed$$1(function (i, _arg1) {
    return new Expression("MemberExpression", [new Expression("IdentifierExpression", ["_stored", null]), new Expression("NumericLiteral", [i, null]), true, null]);
  }, values)];
}
function evaluateExpression(_stored, expr) {
  var prog = new Program$1(null, ofArray([new Statement("ExpressionStatement", [expr, null])]));
  var code = Babel.transformFromAst(Serializer.serializeProgram(prog), "", new BabelOptions(["es2015"]));
  Log.trace("interpreter", "Interpreter evaluating: %O", code.code);

  try {
    var s = series.create(function (builder_) {
      return builder_.Delay(function () {
        return builder_.Return([]);
      });
    }(singleton$2), "", "", "");
    new RuntimeContext("lol", "", "troll");

    (function (c) {
      return function (s_1) {
        return trimLeft(c, s_1);
      };
    });

    (function (f) {
      return function (g) {
        return function (data) {
          return convertTupleSequence(f, g, data);
        };
      };
    });

    (function (arg00) {
      return chart.bar(arg00);
    });

    table.create(s);
    timeline.create(s);
    series.values(new Int32Array([1]));
    placeholder.create("");

    (function (arg00_1) {
      return youdraw.create(arg00_1);
    });

    _stored.length;
    return eval(code.code);
  } catch (e) {
    Log.exn("interpreter", "Evaluation failed: %O", e);
    throw new Error();
  }
}
function evaluateExpr(args, exprBuilder) {
  var patternInput = storeArguments(args);
  return evaluateExpression(patternInput[0], exprBuilder(patternInput[1]));
}
function evaluateCall(emitter, inst, args) {
  var patternInput = storeArguments(new List$2(inst, args));
  return evaluateExpression(patternInput[0], emitter.Emit([patternInput[1].head, patternInput[1].tail]));
}
function evaluatePreview(typ, value) {
  var previewName = new Name("preview");
  var matchValue = defaultArg(typ, null, function (t) {
    return reduceType(t);
  });
  var $var138 = void 0;

  if (matchValue != null) {
    if (matchValue.Case === "Object") {
      var activePatternResult6195 = _FindProperty___(previewName, matchValue.Fields[0]);

      if (activePatternResult6195 != null) {
        $var138 = [0, activePatternResult6195];
      } else {
        $var138 = [1];
      }
    } else {
      $var138 = [1];
    }
  } else {
    $var138 = [1];
  }

  switch ($var138[0]) {
    case 0:
      return evaluateCall($var138[1], value, new List$2());

    case 1:
      var $var139 = void 0;

      if (matchValue != null) {
        if (matchValue.Case === "Object") {
          var activePatternResult6193 = _FindMethod___(previewName, matchValue.Fields[0]);

          if (activePatternResult6193 != null) {
            $var139 = [0, activePatternResult6193[1]];
          } else {
            $var139 = [1];
          }
        } else {
          $var139 = [1];
        }
      } else {
        $var139 = [1];
      }

      switch ($var139[0]) {
        case 0:
          return evaluateCall($var139[1], value, new List$2());

        case 1:
          return null;
      }

  }
}
function ensureValue(ctx, e) {
  if (function () {
    return e.Value == null;
  }(null)) {
    (function () {
      var matchValue = evaluateEntity(ctx, e);

      if (matchValue != null) {
        e.Value = new EntityValue(matchValue, new Lazy(function () {
          return evaluatePreview(e.Type, matchValue);
        }));
      }
    })();
  }
}
function getValue(ctx, e) {
  if (function () {
    return e.Value == null;
  }(null)) {
    Log.error("interpreter", "getValue: Value of entity %O has not been evaluated.", e);
  }

  return e.Value.Value;
}
function evaluateEntity(ctx, e) {
  var $var140 = e.Kind.Case === "Constant" ? e.Kind.Fields[0].Case === "Number" ? [1, e.Kind.Fields[0].Fields[0]] : e.Kind.Fields[0].Case === "String" ? [2, e.Kind.Fields[0].Fields[0]] : e.Kind.Fields[0].Case === "Empty" ? [3] : [0, e.Kind.Fields[0].Fields[0]] : e.Kind.Case === "GlobalValue" ? [4, e.Kind.Fields[1], e.Kind.Fields[0]] : e.Kind.Case === "ChainElement" ? e.Kind.Fields[0] ? e.Kind.Fields[3] != null ? [5, e.Kind.Fields[3], e.Kind.Fields[1]] : [12] : e.Kind.Fields[3] != null ? e.Kind.Fields[4] != null ? e.Kind.Fields[4].Kind.Case === "ArgumentList" ? [6, e.Kind.Fields[4].Kind.Fields[0], e.Kind.Fields[3], e.Kind.Fields[1]] : [12] : [12] : [12] : e.Kind.Case === "Operator" ? e.Kind.Fields[1].Case === "Power" ? [7, e.Kind.Fields[0], e.Kind.Fields[2]] : [8, e.Kind.Fields[0], e.Kind.Fields[1], e.Kind.Fields[2]] : e.Kind.Case === "Variable" ? [9, e.Kind.Fields[1]] : e.Kind.Case === "List" ? [10, e.Kind.Fields[0]] : e.Kind.Case === "ArgumentList" ? [11] : e.Kind.Case === "NamedParam" ? [11] : e.Kind.Case === "NamedMember" ? [11] : [12];

  var _ret2 = function () {
    switch ($var140[0]) {
      case 0:
        return {
          v: $var140[1]
        };

      case 1:
        return {
          v: $var140[1]
        };

      case 2:
        return {
          v: $var140[1]
        };

      case 3:
        return {
          v: null
        };

      case 4:
        if ($var140[1] != null) {
          return {
            v: evaluateExpression([], $var140[1])
          };
        } else {
          return {
            v: null
          };
        }

      case 5:
        var matchValue = reduceType($var140[1].Type);
        var $var141 = void 0;

        if (matchValue.Case === "Object") {
          var activePatternResult6204 = _FindProperty___($var140[2], matchValue.Fields[0]);

          if (activePatternResult6204 != null) {
            $var141 = [0, activePatternResult6204];
          } else {
            $var141 = [1];
          }
        } else {
          $var141 = [1];
        }

        switch ($var141[0]) {
          case 0:
            return {
              v: evaluateCall($var141[1], getValue(ctx, $var140[1]), new List$2())
            };

          case 1:
            return {
              v: null
            };
        }

      case 6:
        var pb = toList(takeWhile(function (_arg1) {
          return _arg1.Kind.Case === "NamedParam" ? false : true;
        }, $var140[1]));
        var nb = toList(skipWhile(function (_arg2) {
          return _arg2.Kind.Case === "NamedParam" ? false : true;
        }, $var140[1]));

        var positionBased = _Array$from(map$4(function (e_1) {
          return getValue(ctx, e_1);
        }, pb));

        var nameBased = new _Map(choose$$1(function (_arg3) {
          if (_arg3.Kind.Case === "NamedParam") {
            var value = _arg3.Kind.Fields[1];
            var name = _arg3.Kind.Fields[0];
            return [name.Name, getValue(ctx, value)];
          } else {
            return null;
          }
        }, nb));
        var matchValue_1 = reduceType($var140[2].Type);
        var $var142 = void 0;

        if (matchValue_1.Case === "Object") {
          var activePatternResult6211 = _FindMethod___($var140[3], matchValue_1.Fields[0]);

          if (activePatternResult6211 != null) {
            $var142 = [0, activePatternResult6211[1], activePatternResult6211[0]];
          } else {
            $var142 = [1];
          }
        } else {
          $var142 = [1];
        }

        switch ($var142[0]) {
          case 0:
            var args = mapIndexed$$1(function (i, tupledArg) {
              return i < positionBased.length ? positionBased[i] : nameBased.has(tupledArg[0]) ? nameBased.get(tupledArg[0]) : null;
            }, $var142[2]);
            return {
              v: evaluateCall($var142[1], getValue(ctx, $var140[2]), args)
            };

          case 1:
            return {
              v: null
            };
        }

      case 7:
        return {
          v: evaluateExpr(ofArray([getValue(ctx, $var140[1]), getValue(ctx, $var140[2])]), function (_arg4) {
            var $var143 = _arg4.tail != null ? _arg4.tail.tail != null ? _arg4.tail.tail.tail == null ? [0, _arg4.head, _arg4.tail.head] : [1] : [1] : [1];

            switch ($var143[0]) {
              case 0:
                var pow = new Expression("MemberExpression", [new Expression("IdentifierExpression", ["pow", null]), new Expression("IdentifierExpression", ["Math", null]), false, null]);
                return new Expression("CallExpression", [pow, ofArray([$var143[1], $var143[2]]), null]);

              case 1:
                throw new Error("evaluateEntity: Expected two arguments");
            }
          })
        };

      case 8:
        return {
          v: evaluateExpr(ofArray([getValue(ctx, $var140[1]), getValue(ctx, $var140[3])]), function (_arg5) {
            var $var144 = _arg5.tail != null ? _arg5.tail.tail != null ? _arg5.tail.tail.tail == null ? [0, _arg5.head, _arg5.tail.head] : [1] : [1] : [1];

            switch ($var144[0]) {
              case 0:
                var op = void 0;

                if ($var140[2].Case === "Plus") {
                  op = new BinaryOperator("BinaryPlus", []);
                } else if ($var140[2].Case === "Minus") {
                  op = new BinaryOperator("BinaryMinus", []);
                } else if ($var140[2].Case === "Multiply") {
                  op = new BinaryOperator("BinaryMultiply", []);
                } else if ($var140[2].Case === "Divide") {
                  op = new BinaryOperator("BinaryDivide", []);
                } else if ($var140[2].Case === "GreaterThan") {
                  op = new BinaryOperator("BinaryGreater", []);
                } else if ($var140[2].Case === "LessThan") {
                  op = new BinaryOperator("BinaryLess", []);
                } else if ($var140[2].Case === "GreaterThanOrEqual") {
                  op = new BinaryOperator("BinaryGreaterOrEqual", []);
                } else if ($var140[2].Case === "LessThanOrEqual") {
                  op = new BinaryOperator("BinaryLessOrEqual", []);
                } else if ($var140[2].Case === "Power") {
                  throw new Error("evaluateEntity: Power is not a binary operation");
                } else {
                  op = new BinaryOperator("BinaryEqualStrict", []);
                }

                return new Expression("BinaryExpression", [op, $var144[1], $var144[2], null]);

              case 1:
                throw new Error("evaluateEntity: Expected two arguments");
            }
          })
        };

      case 9:
        return {
          v: defaultArg($var140[1].Value, null, function (v) {
            return v.Value;
          })
        };

      case 10:
        return {
          v: evaluateExpr(map$4(function (e_2) {
            return getValue(ctx, e_2);
          }, $var140[1]), function (elements) {
            return new Expression("ArrayExpression", [elements, null]);
          })
        };

      case 11:
        return {
          v: null
        };

      case 12:
        Log.error("interpreter", "Cannot evaluate entity: %O", e);
        return {
          v: null
        };
    }
  }();

  if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
}
function evaluateEntityTree(ctx, e) {
  var visited = new _Map();

  var loop = function loop(e_1) {
    if (!visited.has(e_1.Symbol) ? function () {
      return e_1.Value == null;
    }(null) : false) {
      visited.set(e_1.Symbol, true);
      var inputSequence = Entity_get_Antecedents.bind(e_1)();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(inputSequence), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var e_2 = _step.value;
          loop(e_2);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      ensureValue(ctx, e_1);
    }
  };

  loop(e);
  return e.Value;
}
function globalEntity(name, meta, typ, expr) {
  var Kind = new EntityKind("GlobalValue", [new Name(name), expr]);

  var _Symbol$$1 = _Symbol2();

  var Type$$1 = typ;
  return new Entity(Kind, _Symbol$$1, null, meta, Type$$1, new List$2());
}
function evaluate(globals, e) {
  Log.trace("interpreter", "Evaluating entity %s (%O)", Entity_get_Name.bind(e)(), e.Kind);
  var ctx = new EvaluationContext(new _Map(toList(delay(function () {
    return map$5(function (e_1) {
      return [Entity_get_Name.bind(e_1)(), e_1];
    }, globals);
  }))));
  var res = evaluateEntityTree(ctx, e);
  Log.trace("interpreter", "Evaluated entity %s (%O) = %O", Entity_get_Name.bind(e)(), e.Kind, res);
  return res;
}

var QueueCell = (function () {
    function QueueCell(message) {
        this.value = message;
    }
    return QueueCell;
}());
var MailboxQueue = (function () {
    function MailboxQueue() {
    }
    MailboxQueue.prototype.add = function (message) {
        var itCell = new QueueCell(message);
        if (this.firstAndLast) {
            this.firstAndLast[1].next = itCell;
            this.firstAndLast = [this.firstAndLast[0], itCell];
        }
        else
            this.firstAndLast = [itCell, itCell];
    };
    MailboxQueue.prototype.tryGet = function () {
        if (this.firstAndLast) {
            var value = this.firstAndLast[0].value;
            if (this.firstAndLast[0].next)
                this.firstAndLast = [this.firstAndLast[0].next, this.firstAndLast[1]];
            else
                delete this.firstAndLast;
            return value;
        }
        return void 0;
    };
    return MailboxQueue;
}());
var MailboxProcessor = (function () {
    function MailboxProcessor(body, cancellationToken$$1) {
        this.body = body;
        this.cancellationToken = cancellationToken$$1 || defaultCancellationToken;
        this.messages = new MailboxQueue();
    }
    MailboxProcessor.prototype.__processEvents = function () {
        if (this.continuation) {
            var value = this.messages.tryGet();
            if (value) {
                var cont = this.continuation;
                delete this.continuation;
                cont(value);
            }
        }
    };
    MailboxProcessor.prototype.start = function () {
        startImmediate(this.body(this), this.cancellationToken);
    };
    MailboxProcessor.prototype.receive = function () {
        var _this = this;
        return fromContinuations(function (conts) {
            if (_this.continuation)
                throw new Error("Receive can only be called once!");
            _this.continuation = conts[0];
            _this.__processEvents();
        });
    };
    MailboxProcessor.prototype.post = function (message) {
        this.messages.add(message);
        this.__processEvents();
    };
    MailboxProcessor.prototype.postAndAsyncReply = function (buildMessage) {
        var result;
        var continuation;
        function checkCompletion() {
            if (result && continuation)
                continuation(result);
        }
        var reply = {
            reply: function (res) {
                result = res;
                checkCompletion();
            }
        };
        this.messages.add(buildMessage(reply));
        this.__processEvents();
        return fromContinuations(function (conts) {
            continuation = conts[0];
            checkCompletion();
        });
    };
    return MailboxProcessor;
}());
function start$1(body, cancellationToken$$1) {
    var mbox = new MailboxProcessor(body, cancellationToken$$1);
    mbox.start();
    return mbox;
}

var Property = function () {
  function Property(caseName, fields) {
    _classCallCheck(this, Property);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Property, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Editors.Property",
        interfaces: ["FSharpUnion"],
        cases: {
          Property: ["string", Option(Metadata), Type]
        }
      };
    }
  }]);

  return Property;
}();
setType("TheGamma.Editors.Property", Property);
var Editor = function () {
  function Editor(caseName, fields) {
    _classCallCheck(this, Editor);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Editor, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Editors.Editor",
        interfaces: ["FSharpUnion"],
        cases: {
          CreateList: [Documentation, makeGeneric(_Node, {
            T: Name
          }), FableArray(makeGeneric(_Node, {
            T: Name
          })), FableArray(Property)],
          NestedChoice: [Documentation, Documentation, makeGeneric(_Node, {
            T: Name
          }), makeGeneric(_Node, {
            T: Name
          }), FableArray(Tuple([Property, FableArray(Property)]))],
          SingleChoice: [Documentation, makeGeneric(_Node, {
            T: Name
          }), FableArray(Property)]
        }
      };
    }
  }, {
    key: "Range",
    get: function () {
      if (this.Case === "NestedChoice") {
        return unionRanges(this.Fields[2].Range, this.Fields[3].Range);
      } else if (this.Case === "CreateList") {
        return fold$1(function (r, n) {
          return unionRanges(r, n.Range);
        }, new _Range(this.Fields[1].Range.End, this.Fields[1].Range.End), this.Fields[2]);
      } else {
        return this.Fields[1].Range;
      }
    }
  }]);

  return Editor;
}();
setType("TheGamma.Editors.Editor", Editor);
function getMembers(typ) {
  return function (builder_) {
    return builder_.Delay(function () {
      if (typ.Case === "Object") {
        return builder_.Return(typ.Fields[0].Members);
      } else if (typ.Case === "Delayed") {
        return builder_.Bind(Async_AwaitFuture_Static(typ.Fields[1]), function (_arg1) {
          return builder_.ReturnFrom(getMembers(_arg1));
        });
      } else {
        Log.error("editors", "getMembers: Type %O is not an object", typ);
        return builder_.Return(function () {
          throw new Error("getMembers: Not an object");
        }());
      }
    });
  }(singleton$2);
}
function extractMetadata(m) {
  var doc = tryPick(function (m_1) {
    return (m_1.Context === "http://thegamma.net" ? m_1.Type === "Documentation" : false) ? m_1.Data : null;
  }, m);
  var schema = tryPick(function (m_2) {
    return m_2.Context === "http://schema.org" ? m_2 : null;
  }, m);
  return [schema, doc != null ? doc : new Documentation("None", [])];
}
function getProperty(name, members) {
  return tryPick(function (_arg1) {
    var $var195 = _arg1.Case === "Property" ? _arg1.Fields[0] === name.Name ? [0, _arg1.Fields[2], _arg1.Fields[0], _arg1.Fields[1]] : [1] : [1];

    switch ($var195[0]) {
      case 0:
        var patternInput = extractMetadata($var195[1]);
        return [patternInput[0], $var195[3], patternInput[1]];

      case 1:
        return null;
    }
  }, members);
}
function filterProperties(f, members) {
  var filtered = _Array$from(choose$1(function (_arg1) {
    if (_arg1.Case === "Property") {
      var patternInput = extractMetadata(_arg1.Fields[2]);

      if (f([_arg1.Fields[0], patternInput[0], _arg1.Fields[1]])) {
        return new Property("Property", [_arg1.Fields[0], patternInput[0], _arg1.Fields[1]]);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }, members));

  return filtered;
}
function dominant(all, subset) {
  var nall = count(all);
  var nsub = count(subset);

  if (nsub >= 2) {
    return nsub >= ~~(nall * 2 / 3);
  } else {
    return false;
  }
}
function chooseableProperty(equalTyp, name, typ) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(getMembers(typ), function (_arg1) {
        var matchValue = getProperty(name.Node, _arg1);
        var $var196 = matchValue != null ? matchValue[0] != null ? [0, matchValue[0], matchValue[1]] : [1] : [1];

        switch ($var196[0]) {
          case 0:
            var alts = filterProperties(function (_arg2) {
              if (_arg2[1] != null) {
                var s$$1 = _arg2[1];

                if (s$$1.Type === $var196[1].Type) {
                  if (!equalTyp) {
                    return true;
                  } else {
                    return typesEqual(_arg2[2])($var196[2]);
                  }
                } else {
                  return false;
                }
              } else {
                return false;
              }
            }, _arg1);

            if (dominant(_arg1, alts)) {
              return builder_.Return([name, alts]);
            } else {
              return builder_.Return(null);
            }

          case 1:
            return builder_.Return(null);
        }
      });
    });
  }(singleton$2);
}
function pickChainSuffixes(f, expr) {
  var loop = function loop(res) {
    return function (suffix) {
      return function (expr_1) {
        return function (builder_) {
          return builder_.Delay(function () {
            if (expr_1.Node.Case === "Property") {
              return builder_.Bind(getMembers(expr_1.Node.Fields[0].Entity.Type), function (_arg1) {
                var matchValue = getProperty(expr_1.Node.Fields[1].Node, _arg1);

                if (matchValue == null) {
                  return builder_.ReturnFrom(loop(res)(suffix)(expr_1.Node.Fields[0]));
                } else {
                  var _ret = function () {
                    var propTy = matchValue[1];
                    var propSch = matchValue[0];
                    var propDoc = matchValue[2];
                    var suffix_1 = new List$2([expr_1.Node.Fields[0].Entity.Type, expr_1.Node.Fields[1], propSch, propTy, propDoc], suffix);
                    return {
                      v: builder_.Bind(f(suffix_1), function (_arg2) {
                        return _arg2 != null ? builder_.ReturnFrom(loop(new List$2(_arg2, res))(suffix_1)(expr_1.Node.Fields[0])) : builder_.ReturnFrom(loop(res)(suffix_1)(expr_1.Node.Fields[0]));
                      })
                    };
                  }();

                  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
                }
              });
            } else {
              var activePatternResult7398 = _ExprLeaf_ExprNode_(expr_1.Node);

              if (activePatternResult7398.Case === "Choice1Of2") {
                return builder_.Return(res);
              } else {
                return builder_.ReturnFrom(function () {
                  var f_1 = function f_1(st) {
                    return function (e) {
                      return loop(st)(new List$2())(e);
                    };
                  };

                  return function (l) {
                    return Async.fold(f_1, res, l);
                  };
                }()(activePatternResult7398.Fields[0][0]));
              }
            }
          });
        }(singleton$2);
      };
    };
  };

  return loop(new List$2())(new List$2())(expr);
}
var collectSingleChoiceEditors = function () {
  var f = function f(chain) {
    return function (builder_) {
      return builder_.Delay(function () {
        if (chain.tail != null) {
          var _ret2 = function () {
            var tyParent = chain.head[0];
            var name = chain.head[1];
            var doc = chain.head[4];
            return {
              v: builder_.Bind(chooseableProperty(true, name, tyParent), function (_arg1) {
                return builder_.Return(defaultArg(_arg1, null, function (tupledArg) {
                  return new Editor("SingleChoice", [doc, tupledArg[0], tupledArg[1]]);
                }));
              })
            };
          }();

          if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        } else {
          return builder_.Return(null);
        }
      });
    }(singleton$2);
  };

  return function (expr) {
    return pickChainSuffixes(f, expr);
  };
}();
var collectNestedChoiceEditors = function () {
  var f = function f(chain) {
    return function (builder_) {
      return builder_.Delay(function () {
        var $var197 = chain.tail != null ? chain.tail.tail != null ? chain.tail.head[2] != null ? [0, chain.head[4], chain.head[1], chain.head[0], chain.head[2], chain.head[3], chain.tail.head[4], chain.tail.head[1], chain.tail.head[0], chain.tail.head[2], chain.tail.head[3]] : [1] : [1] : [1];

        switch ($var197[0]) {
          case 0:
            Log.trace("editors", "checking %s.%s", $var197[2].Node.Name, $var197[7].Node.Name);
            return builder_.Bind(chooseableProperty(false, $var197[2], $var197[3]), function (_arg1) {
              return builder_.Bind(chooseableProperty(true, $var197[7], $var197[8]), function (_arg2) {
                var matchValue = [_arg1, _arg2];
                var $var198 = matchValue[0] != null ? matchValue[1] != null ? [0, matchValue[0][1], matchValue[0][0], matchValue[1][1], matchValue[1][0]] : [1] : [1];

                var _ret3 = function () {
                  switch ($var198[0]) {
                    case 0:
                      Log.trace("editors", "collecting %s nested members", $var198[1].length);

                      var nestedMembers = function nestedMembers(trunc) {
                        return Async.Array.map(function (_arg1_1) {
                          return function (builder__1) {
                            return builder__1.Delay(function () {
                              return builder__1.Bind(getMembers(_arg1_1.Fields[2]), function (_arg3) {
                                var filtered = filterProperties(function (_arg4) {
                                  if (_arg4[1] != null) {
                                    var s$$1 = _arg4[1];

                                    if (s$$1.Type === $var197[9].Type) {
                                      return typesEqual(_arg4[2])($var197[10]);
                                    } else {
                                      return false;
                                    }
                                  } else {
                                    return false;
                                  }
                                }, _arg3);
                                return builder__1.Return([_arg1_1, [_arg3, filtered]]);
                              });
                            });
                          }(singleton$2);
                        }, trunc($var198[1]));
                      };

                      return {
                        v: builder_.Bind(nestedMembers(function ($var199) {
                          return _Array$from(truncate(5, $var199));
                        }), function (_arg5) {
                          return (count(_arg5) > 2 ? dominant(collect$1(function ($var200) {
                            return $var200[1][0];
                          }, _arg5), collect$1(function ($var201) {
                            return $var201[1][1];
                          }, _arg5)) : false) ? builder_.Bind(nestedMembers(function (x) {
                            return x;
                          }), function (_arg6) {
                            var props = _arg6.map(function (tupledArg) {
                              return [tupledArg[0], tupledArg[1][1]];
                            });

                            return builder_.Return(new Editor("NestedChoice", [$var197[1], $var197[6], $var198[2], $var198[4], props]));
                          }) : builder_.Return(null);
                        })
                      };

                    case 1:
                      return {
                        v: builder_.Return(null)
                      };
                  }
                }();

                if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
              });
            });

          case 1:
            return builder_.Return(null);
        }
      });
    }(singleton$2);
  };

  return function (expr) {
    return pickChainSuffixes(f, expr);
  };
}();
var ItemListSchema = function () {
  function ItemListSchema(name) {
    _classCallCheck(this, ItemListSchema);

    this.name = name;
  }

  _createClass(ItemListSchema, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Editors.ItemListSchema",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          name: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return ItemListSchema;
}();
setType("TheGamma.Editors.ItemListSchema", ItemListSchema);
var CreateActionSchema = function () {
  function CreateActionSchema(result) {
    _classCallCheck(this, CreateActionSchema);

    this.result = result;
  }

  _createClass(CreateActionSchema, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Editors.CreateActionSchema",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          result: ItemListSchema
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return CreateActionSchema;
}();
setType("TheGamma.Editors.CreateActionSchema", CreateActionSchema);
var AddActionSchema = function () {
  function AddActionSchema(targetCollection) {
    _classCallCheck(this, AddActionSchema);

    this.targetCollection = targetCollection;
  }

  _createClass(AddActionSchema, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Editors.AddActionSchema",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          targetCollection: ItemListSchema
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return AddActionSchema;
}();
setType("TheGamma.Editors.AddActionSchema", AddActionSchema);
var collectItemListEditors = function () {
  var f = function f(chain) {
    return function (builder_) {
      return builder_.Delay(function () {
        var $var202 = chain.tail != null ? chain.head[2] != null ? chain.tail.tail != null ? chain.tail.head[2] != null ? function () {
          var caSch2 = chain.tail.head[2];
          var caSch1 = chain.head[2];

          if (caSch1.Type === "CreateAction") {
            return caSch2.Type === "CreateAction";
          } else {
            return false;
          }
        }() ? [0, chain.head[2], chain.tail.head[2]] : [1] : [1] : [1] : [1] : [1];

        var _ret4 = function () {
          switch ($var202[0]) {
            case 0:
              return {
                v: builder_.Return(null)
              };

            case 1:
              var $var203 = chain.tail != null ? chain.head[2] != null ? function () {
                var catDoc = chain.head[4];
                var caTy = chain.head[3];
                var caSch = chain.head[2];
                var caParentTy = chain.head[0];
                var caName = chain.head[1];
                return caSch.Type === "CreateAction";
              }() ? [0, chain.tail, chain.head[1], chain.head[0], chain.head[2], chain.head[3], chain.head[4]] : [1] : [1] : [1];

              var _ret5 = function () {
                switch ($var203[0]) {
                  case 0:
                    var listName = $var203[4].Data.result.name;

                    var collectAdds = function collectAdds(added) {
                      return function (lastTy) {
                        return function (_arg1) {
                          collectAdds: while (true) {
                            var $var204 = _arg1.tail != null ? _arg1.head[2] != null ? function () {
                              var addTy = _arg1.head[3];
                              var addSch = _arg1.head[2];
                              var addParentTy = _arg1.head[0];
                              var addName = _arg1.head[1];

                              if (addSch.Type === "AddAction") {
                                return listName === addSch.Data.targetCollection.name;
                              } else {
                                return false;
                              }
                            }() ? [0, _arg1.tail, _arg1.head[1], _arg1.head[0], _arg1.head[2], _arg1.head[3]] : [1] : [1] : [1];

                            switch ($var204[0]) {
                              case 0:
                                added = new List$2($var204[2], added);
                                lastTy = $var204[5];
                                _arg1 = $var204[1];
                                continue collectAdds;

                              case 1:
                                return [reverse$$1(added), lastTy];
                            }
                          }
                        };
                      };
                    };

                    var patternInput = collectAdds(new List$2())($var203[5])($var203[1]);
                    return {
                      v: {
                        v: builder_.Bind(getMembers(patternInput[1]), function (_arg2) {
                          var availableAdds = filterProperties(function (_arg3) {
                            var $var205 = _arg3[1] != null ? function () {
                              var s$$1 = _arg3[1];
                              return s$$1.Type === "AddAction";
                            }() ? [0, _arg3[0], _arg3[1], _arg3[2]] : [1] : [1];

                            switch ($var205[0]) {
                              case 0:
                                return $var205[2].Data.targetCollection.name === listName;

                              case 1:
                                return false;
                            }
                          }, _arg2);
                          return builder_.Return(new Editor("CreateList", [$var203[6], $var203[2], _Array$from(patternInput[0]), availableAdds]));
                        })
                      }
                    };

                  case 1:
                    return {
                      v: {
                        v: builder_.Return(null)
                      }
                    };
                }
              }();

              if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
          }
        }();

        if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
      });
    }(singleton$2);
  };

  return function (expr) {
    return pickChainSuffixes(f, expr);
  };
}();
function collectCmdEditors(cmd) {
  return function (builder_) {
    return builder_.Delay(function () {
      var $var206 = cmd.Node.Case === "Expr" ? [0, cmd.Node.Fields[0]] : [0, cmd.Node.Fields[1]];

      switch ($var206[0]) {
        case 0:
          Log.trace("editors", "single choice");
          return builder_.Bind(collectSingleChoiceEditors($var206[1]), function (_arg1) {
            Log.trace("editors", "item list");
            return builder_.Bind(collectItemListEditors($var206[1]), function (_arg2) {
              Log.trace("editors", "multi choice");
              return builder_.Bind(collectNestedChoiceEditors($var206[1]), function (_arg3) {
                return builder_.Return(append$$1(_arg1, append$$1(_arg3, _arg2)));
              });
            });
          });
      }
    });
  }(singleton$2);
}

var BindingContext = function () {
  function BindingContext(variables, globalValues, root, table, bound) {
    _classCallCheck(this, BindingContext);

    this.Variables = variables;
    this.GlobalValues = globalValues;
    this.Root = root;
    this.Table = table;
    this.Bound = bound;
  }

  _createClass(BindingContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Binder.BindingContext",
        interfaces: ["FSharpRecord"],
        properties: {
          Variables: makeGeneric(FableMap, {
            Key: Name,
            Value: Entity
          }),
          GlobalValues: makeGeneric(FableMap, {
            Key: Name,
            Value: Entity
          }),
          Root: Entity,
          Table: makeGeneric(_Map, {
            TKey: Interface("TheGamma.Common.Symbol"),
            TValue: makeGeneric(ListDictionaryNode, {
              K: Interface("TheGamma.Common.Symbol"),
              T: makeGeneric(FableMap, {
                Key: Tuple(["number", "string"]),
                Value: Entity
              })
            })
          }),
          Bound: FableArray(Tuple([_Range, Entity]))
        }
      };
    }
  }]);

  return BindingContext;
}();
setType("TheGamma.Binder.BindingContext", BindingContext);
var BindingResult = function () {
  _createClass(BindingResult, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Binder.BindingResult",
        properties: {
          Entities: FableArray(Tuple([_Range, Entity]))
        }
      };
    }
  }]);

  function BindingResult(ents) {
    _classCallCheck(this, BindingResult);

    this.ents = ents;
    var res = new _Map();

    var add$$1 = function add$$1(a) {
      return function (e) {
        if (!res.has(a)) {
          res.set(a, []);
        }

        res.get(a).push(e);
      };
    };

    var arr = this.ents;

    for (var idx = 0; idx <= arr.length - 1; idx++) {
      var forLoopVar = arr[idx];
      var inputSequence = Entity_get_Antecedents.bind(forLoopVar[1])();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(inputSequence), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var a_1 = _step.value;
          add$$1(a_1.Symbol)(forLoopVar[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    this.childrenLookup = res;
  }

  _createClass(BindingResult, [{
    key: "GetChildren",
    value: function (ent) {
      var matchValue = tryGetValue(this.childrenLookup, ent.Symbol, null);

      if (matchValue[0]) {
        return _Array$from(matchValue[1]);
      } else {
        return [];
      }
    }
  }, {
    key: "Entities",
    get: function () {
      return this.ents;
    }
  }]);

  return BindingResult;
}();
setType("TheGamma.Binder.BindingResult", BindingResult);
function bindEntity(ctx, kind) {
  var patternInput = entityCodeNameAndAntecedents(kind);
  var symbols = map$4(function (a) {
    return a.Symbol;
  }, new List$2(ctx.Root, patternInput[1]));
  var nestedDict = void 0;
  var matchValue = ListDictionaryModule.tryFind(symbols, ctx.Table);

  if (matchValue != null) {
    nestedDict = matchValue;
  } else {
    nestedDict = create$3(null, new GenericComparer(compare));
  }

  if (nestedDict.has([patternInput[0], patternInput[2]])) {
    Log.trace("binder", "Cached: binding %s %s", formatEntityKind(kind), patternInput[2]);
    return nestedDict.get([patternInput[0], patternInput[2]]);
  } else {
    Log.trace("binder", "New: binding %s %s", formatEntityKind(kind), patternInput[2]);

    var symbol = _Symbol2();

    var entity = void 0;
    var Type$$1 = null;
    var Errors = new List$2();
    var Meta = new List$2();
    entity = new Entity(kind, symbol, null, Meta, Type$$1, Errors);
    ListDictionaryModule.set(symbols, add$1([patternInput[0], patternInput[2]], entity, nestedDict), ctx.Table);
    return entity;
  }
}
function setEntity(ctx, node$$1, entity) {
  ctx.Bound.push([node$$1.Range, entity]);
  node$$1.Entity = entity;
  return entity;
}
function bindExpression(callSite, ctx, node$$1) {
  var bindCallArgExpression = function bindCallArgExpression(site) {
    var callSite_1 = site;
    return function (ctx_1) {
      return function (node_1) {
        return bindExpression(callSite_1, ctx_1, node_1);
      };
    };
  };

  var bindExpression_1 = void 0;
  var callSite_2 = null;

  bindExpression_1 = function bindExpression_1(ctx_2) {
    return function (node_2) {
      return bindExpression(callSite_2, ctx_2, node_2);
    };
  };

  if (node$$1.Node.Case === "Call") {
    var _ret = function () {
      var inst = defaultArg(defaultArg(node$$1.Node.Fields[0], null, bindExpression_1(ctx)), ctx.Root);

      var site_1 = function site_1(arg) {
        return bindEntity(ctx, new EntityKind("CallSite", [inst, node$$1.Node.Fields[1].Node, arg]));
      };

      var args = mapIndexed$$1(function (idx, arg_1) {
        var site_2 = site_1(arg_1.Name != null ? new Choice("Choice1Of2", [arg_1.Name.Node.Name]) : new Choice("Choice2Of2", [idx]));
        var expr = bindCallArgExpression(site_2)(ctx)(arg_1.Value);

        if (arg_1.Name == null) {
          return expr;
        } else {
          return function (entity) {
            return setEntity(ctx, arg_1.Name, entity);
          }(bindEntity(ctx, new EntityKind("NamedParam", [arg_1.Name.Node, expr])));
        }
      }, node$$1.Node.Fields[2].Node);

      var args_1 = function (entity_1) {
        return setEntity(ctx, node$$1.Node.Fields[2], entity_1);
      }(bindEntity(ctx, new EntityKind("ArgumentList", [args])));

      var named = function (entity_2) {
        return setEntity(ctx, node$$1.Node.Fields[1], entity_2);
      }(bindEntity(ctx, new EntityKind("NamedMember", [node$$1.Node.Fields[1].Node, inst])));

      return {
        v: function (entity_3) {
          return setEntity(ctx, node$$1, entity_3);
        }(bindEntity(ctx, new EntityKind("ChainElement", [false, node$$1.Node.Fields[1].Node, named, inst, args_1])))
      };
    }();

    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
  } else if (node$$1.Node.Case === "Property") {
    var inst_1 = bindExpression_1(ctx)(node$$1.Node.Fields[0]);

    var named_1 = function (entity_4) {
      return setEntity(ctx, node$$1.Node.Fields[1], entity_4);
    }(bindEntity(ctx, new EntityKind("NamedMember", [node$$1.Node.Fields[1].Node, inst_1])));

    return function (entity_5) {
      return setEntity(ctx, node$$1, entity_5);
    }(bindEntity(ctx, new EntityKind("ChainElement", [true, node$$1.Node.Fields[1].Node, named_1, inst_1, null])));
  } else if (node$$1.Node.Case === "Binary") {
    var lentity = bindExpression_1(ctx)(node$$1.Node.Fields[0]);
    var rentity = bindExpression_1(ctx)(node$$1.Node.Fields[2]);
    return function (entity_6) {
      return setEntity(ctx, node$$1, entity_6);
    }(bindEntity(ctx, new EntityKind("Operator", [lentity, node$$1.Node.Fields[1].Node, rentity])));
  } else if (node$$1.Node.Case === "List") {
    var entities = map$4(bindExpression_1(ctx), node$$1.Node.Fields[0]);
    return function (entity_7) {
      return setEntity(ctx, node$$1, entity_7);
    }(bindEntity(ctx, new EntityKind("List", [entities])));
  } else if (node$$1.Node.Case === "Function") {
    var callSite_3 = void 0;

    if (callSite == null) {
      throw new Error("bindExpression: Function missing call site");
    } else {
      callSite_3 = callSite;
    }

    var _var = function (entity_8) {
      return setEntity(ctx, node$$1.Node.Fields[0], entity_8);
    }(bindEntity(ctx, new EntityKind("Binding", [node$$1.Node.Fields[0].Node, callSite_3])));

    var body = bindExpression_1(new BindingContext(add$1(node$$1.Node.Fields[0].Node, _var, ctx.Variables), ctx.GlobalValues, ctx.Root, ctx.Table, ctx.Bound))(node$$1.Node.Fields[1]);
    return function (entity_9) {
      return setEntity(ctx, node$$1, entity_9);
    }(bindEntity(ctx, new EntityKind("Function", [_var, body])));
  } else if (node$$1.Node.Case === "Boolean") {
    return function (entity_10) {
      return setEntity(ctx, node$$1, entity_10);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("Boolean", [node$$1.Node.Fields[0]])])));
  } else if (node$$1.Node.Case === "String") {
    return function (entity_11) {
      return setEntity(ctx, node$$1, entity_11);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("String", [node$$1.Node.Fields[0]])])));
  } else if (node$$1.Node.Case === "Number") {
    return function (entity_12) {
      return setEntity(ctx, node$$1, entity_12);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("Number", [node$$1.Node.Fields[0]])])));
  } else if (node$$1.Node.Case === "Empty") {
    return function (entity_13) {
      return setEntity(ctx, node$$1, entity_13);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("Empty", [])])));
  } else {
    var matchValue = tryFind$1(node$$1.Node.Fields[0].Node, ctx.Variables);

    if (matchValue != null) {
      return function (entity_14) {
        return setEntity(ctx, node$$1, entity_14);
      }(bindEntity(ctx, new EntityKind("Variable", [node$$1.Node.Fields[0].Node, matchValue])));
    } else {
      var matchValue_1 = tryFind$1(node$$1.Node.Fields[0].Node, ctx.GlobalValues);

      if (matchValue_1 == null) {
        return function (entity_15) {
          return setEntity(ctx, node$$1, entity_15);
        }(bindEntity(ctx, new EntityKind("GlobalValue", [node$$1.Node.Fields[0].Node, null])));
      } else {
        return function (entity_16) {
          return setEntity(ctx, node$$1, entity_16);
        }(matchValue_1);
      }
    }
  }
}
function bindCommand(ctx, node$$1) {
  if (node$$1.Node.Case === "Expr") {
    var body = bindExpression(null, ctx, node$$1.Node.Fields[0]);

    var node_1 = function (entity) {
      return setEntity(ctx, node$$1, entity);
    }(bindEntity(ctx, new EntityKind("RunCommand", [body])));

    return [ctx, node_1];
  } else {
    var body_1 = bindExpression(null, ctx, node$$1.Node.Fields[1]);

    var _var = function (entity_1) {
      return setEntity(ctx, node$$1.Node.Fields[0], entity_1);
    }(bindEntity(ctx, new EntityKind("Variable", [node$$1.Node.Fields[0].Node, body_1])));

    var node_2 = function (entity_2) {
      return setEntity(ctx, node$$1, entity_2);
    }(bindEntity(ctx, new EntityKind("LetCommand", [_var, body_1])));

    return [new BindingContext(add$1(node$$1.Node.Fields[0].Node, _var, ctx.Variables), ctx.GlobalValues, ctx.Root, ctx.Table, ctx.Bound), node_2];
  }
}
function bindProgram(ctx, program) {
  ctx.Bound.splice(0);
  var patternInput_1 = fold$1(function (tupledArg, cmd) {
    var patternInput = bindCommand(tupledArg[0], cmd);
    return [patternInput[0], new List$2(patternInput[1], tupledArg[1])];
  }, [ctx, new List$2()], program.Body.Node);
  return [bindEntity(ctx, new EntityKind("Program", [patternInput_1[1]])), new BindingResult(_Array$from(ctx.Bound))];
}
function createContext(globals, name) {
  var root = void 0;
  var Kind = new EntityKind("Root", []);
  var Errors = new List$2();

  var _Symbol$$1 = _Symbol2();

  var Type$$1 = null;
  var Meta = new List$2();
  root = new Entity(Kind, _Symbol$$1, null, Meta, Type$$1, Errors);
  var Table = new _Map();
  var Bound = [];
  return new BindingContext(create$3(null, new GenericComparer(function (x, y) {
    return x.CompareTo(y);
  })), create$3(toList(delay(function () {
    return map$5(function (e) {
      return [new Name(Entity_get_Name.bind(e)()), e];
    }, globals);
  })), new GenericComparer(function (x, y) {
    return x.CompareTo(y);
  })), root, Table, Bound);
}

var Tokenizer = function (__exports) {
  var inputEndInsideString = __exports.inputEndInsideString = function (rng, s) {
    var _Number = 101;
    return new _Error(_Number, fsFormat("Missing \" at the end of the input. The string \"%s\" ends without closing double-quote.")(function (x) {
      return x;
    })(s), rng);
  };

  var missingClosingQuote = __exports.missingClosingQuote = function (rng, q) {
    var _Number = 102;
    return new _Error(_Number, fsFormat("Quoted identifier '%s' is missing closing quote.")(function (x) {
      return x;
    })(q), rng);
  };

  var unexpectedCharacter = __exports.unexpectedCharacter = function (rng, c) {
    var _Number = 103;
    return new _Error(_Number, fsFormat("Unexcpected character '%s' in the input.")(function (x) {
      return x;
    })(c), rng);
  };

  return __exports;
}({});
var Parser = function (__exports) {
  var unexpectedTokenAfterDot = __exports.unexpectedTokenAfterDot = function (rng, tok) {
    var _Number = 201;
    return new _Error(_Number, fsFormat("Unexpected %s after '.' in method chain")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndAfterDot = __exports.unexpectedScopeEndAfterDot = function (rng, chainRng, tok) {
    var _Number = 202;
    return new _Error(_Number, fsFormat("Unexpected end of scope after '.' in method chain before %s")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unindentedIdentifierAfterDot = __exports.unindentedIdentifierAfterDot = function (rng, chainRng, id) {
    var _Number = 203;
    return new _Error(_Number, fsFormat("Unexpected end of scope after '.' and before '%s'. Indent the identifier?")(function (x) {
      return x;
    })(id), rng);
  };

  var unindentedDotAfterIdentifier = __exports.unindentedDotAfterIdentifier = function (rng, dotRng) {
    var _Number = 204;
    return new _Error(_Number, "Dot after this identifier is not correctly nested", rng);
  };

  var unindentedBlock = __exports.unindentedBlock = function (rng, tok) {
    var _Number = 205;
    return new _Error(_Number, fsFormat("Token following %s needs to be indented further")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedTokenAfterOperator = __exports.unexpectedTokenAfterOperator = function (rng, op, tok) {
    var _Number = 206;
    return new _Error(_Number, fsFormat("Unexpected token '%s' after operator '%s'")(function (x) {
      return x;
    })(formatTokenInfo(tok))(formatTokenInfo(op)), rng);
  };

  var unexpectedTokenInArgList = __exports.unexpectedTokenInArgList = function (rng, tok) {
    var _Number = 207;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in list of call arguments")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndInArgList = __exports.unexpectedScopeEndInArgList = function (rng) {
    var _Number = 208;
    return new _Error(_Number, "Unexpected end of scope in argument list", rng);
  };

  var unexpectedTokenInParenthesizedExpr = __exports.unexpectedTokenInParenthesizedExpr = function (rng, tok) {
    var _Number = 209;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in parenthesized expression. Are you missing ')'?")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unindentedTokenInParenthesizedExpr = __exports.unindentedTokenInParenthesizedExpr = function (rng) {
    var _Number = 210;
    return new _Error(_Number, "Unexpected end of nested expression in `(`", rng);
  };

  var missingParenthesizedExpr = __exports.missingParenthesizedExpr = function (rng) {
    var _Number = 211;
    return new _Error(_Number, "The parenthesized expression (...) is missing body!", rng);
  };

  var unexpectedTokenInList = __exports.unexpectedTokenInList = function (rng, tok) {
    var _Number = 212;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in list expression")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndInList = __exports.unexpectedScopeEndInList = function (rng) {
    var _Number = 213;
    return new _Error(_Number, "Unexpected end of scope in list expression", rng);
  };

  var unexpectedTokenInLetBinding = __exports.unexpectedTokenInLetBinding = function (rng, tok) {
    var _Number = 214;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in let declaration (should be let name = expr)")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var missingBodyInLetBinding = __exports.missingBodyInLetBinding = function (rng) {
    var _Number = 215;
    return new _Error(_Number, "This let binding is missing body after equals", rng);
  };

  var nestedExpressionInCommand = __exports.nestedExpressionInCommand = function (rng) {
    var _Number = 216;
    return new _Error(_Number, "Unexpected expression", rng);
  };

  var unexpectedTokenAfterFun = __exports.unexpectedTokenAfterFun = function (rng, tok) {
    var _Number = 217;
    return new _Error(_Number, fsFormat("Unexpected token '%s' after `fun`. Expected variable name.")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var missingArrowInFunc = __exports.missingArrowInFunc = function (rng) {
    var _Number = 218;
    return new _Error(_Number, "Missing arrow after variable in function definition", rng);
  };

  var unexpectedScopeEndInFunc = __exports.unexpectedScopeEndInFunc = function (rng) {
    var _Number = 219;
    return new _Error(_Number, "Unexpected end of scope in function declaration", rng);
  };

  var missingBodyOfFunc = __exports.missingBodyOfFunc = function (rng) {
    var _Number = 220;
    return new _Error(_Number, "The function is missing body. If it is on the next line, you need to indent it further.", rng);
  };

  var exceptionWhileParsing = __exports.exceptionWhileParsing = function (rng, msg) {
    var _Number = 299;
    return new _Error(_Number, "Unexpected exception while parsing: " + msg, rng);
  };

  return __exports;
}({});
var TypeChecker = function (__exports) {
  var numericOperatorExpectsNumbers = __exports.numericOperatorExpectsNumbers = function (op, idx, typ, rng) {
    var _Number = 301;
    return new _Error(_Number, fsFormat("Both operands of binary operator '%s' should be numbers but the %s operand was %s instead.")(function (x) {
      return x;
    })(formatToken(new TokenKind("Operator", [op])))(idx === 0 ? "left" : "right")(formatTypeInfo(typ)), rng);
  };

  var variableNotInScope = __exports.variableNotInScope = function (name, rng) {
    var _Number = 302;
    return new _Error(_Number, fsFormat("Variable '%s' is not in scope.")(function (x) {
      return x;
    })(name), rng);
  };

  var formatMembers = function formatMembers(members) {
    return join(", ", toList(delay(function () {
      return collect$1(function (matchValue) {
        var $var84 = matchValue.Case === "Property" ? [0, matchValue.Fields[0]] : [0, matchValue.Fields[0]];

        switch ($var84[0]) {
          case 0:
            return singleton$1($var84[1]);
        }
      }, members);
    })));
  };

  var propertyMissing = __exports.propertyMissing = function (name, members, rng) {
    var _Number = 303;
    return new _Error(_Number, fsFormat("Could not find property '%s' in the list '%s'.")(function (x) {
      return x;
    })(name)(formatMembers(members)), rng);
  };

  var methodMissing = __exports.methodMissing = function (name, members, rng) {
    var _Number = 304;
    return new _Error(_Number, fsFormat("Could not find method '%s' in the list '%s'.")(function (x) {
      return x;
    })(name)(formatMembers(members)), rng);
  };

  var notAnObject = __exports.notAnObject = function (name, typ, rng) {
    var _Number = 305;
    return new _Error(_Number, fsFormat("Type is not an object but %s and it does not have member `%s`")(function (x) {
      return x;
    })(formatTypeInfo(typ))(name), rng);
  };

  var listElementTypeDoesNotMatch = __exports.listElementTypeDoesNotMatch = function (listty, elty, rng) {
    var _Number = 306;
    return new _Error(_Number, fsFormat("The type of this list element is %s but it should be %s")(function (x) {
      return x;
    })(formatTypeInfo(elty))(formatTypeInfo(listty)), rng);
  };

  var nameBasedParamMustBeLast = __exports.nameBasedParamMustBeLast = function (rng) {
    var _Number = 307;
    return new _Error(_Number, "All named parameters must be at the end of parameter list.", rng);
  };

  var parameterMissingValue = __exports.parameterMissingValue = function (par, rng) {
    var _Number = 308;
    return new _Error(_Number, fsFormat("Required parameter `%s` is not given a value.")(function (x) {
      return x;
    })(par), rng);
  };

  var incorrectParameterType = __exports.incorrectParameterType = function (parName, parType, actualType, err1, err2, rng) {
    var _Number = 309;
    return new _Error(_Number, fsFormat("The value of parameter `%s` has wrong type. Expected %s but got %s. The type %s does not match the type %s.")(function (x) {
      return x;
    })(parName)(formatTypeInfo(parType))(formatTypeInfo(actualType))(formatTypeInfo(err1))(formatTypeInfo(err2)), rng);
  };

  var inferenceConflict = __exports.inferenceConflict = function (_var, t1, t2, rng) {
    var _Number = 310;
    return new _Error(_Number, fsFormat("The arguments of the call have conflicting types. The type %s assigned to a variable %s does not match the type %s.")(function (x) {
      return x;
    })(formatTypeInfo(t1))(_var)(formatTypeInfo(t2)), rng);
  };

  var callMissingInstance = __exports.callMissingInstance = function (name, rng) {
    var _Number = 311;
    return new _Error(_Number, fsFormat("The `%s` property access or call is missing an instance")(function (x) {
      return x;
    })(name), rng);
  };

  return __exports;
}({});

var $parseFloat$1 = _global.parseFloat;
var $trim$1       = _stringTrim.trim;

var _parseFloat$3 = 1 / $parseFloat$1(_stringWs + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim$1(String(str), 3)
    , result = $parseFloat$1(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat$1;

var $export$11     = _export;
var $parseFloat = _parseFloat$3;
// 20.1.2.12 Number.parseFloat(string)
$export$11($export$11.S + $export$11.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

var _parseFloat$1 = parseFloat;

var _parseFloat = createCommonjsModule(function (module) {
module.exports = { "default": _parseFloat$1, __esModule: true };
});

var _Number$parseFloat = unwrapExports(_parseFloat);

var Context$1 = function () {
  function Context(tokens, errors, input) {
    _classCallCheck(this, Context);

    this.Tokens = tokens;
    this.Errors = errors;
    this.Input = input;
  }

  _createClass(Context, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Tokenizer.Context",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Tokens: FableArray(Token),
          Errors: FableArray(makeGeneric(_Error, {
            Range: _Range
          })),
          Input: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return Context;
}();
setType("TheGamma.Tokenizer.Context", Context$1);
function startsWith(s, i, j, prefix) {
  startsWith: while (true) {
    if (j === prefix.length) {
      return true;
    } else if (i === s.length) {
      return false;
    } else if (s[i] !== prefix[j]) {
      return false;
    } else {
      s = s;
      i = i + 1;
      j = j + 1;
      prefix = prefix;
      continue startsWith;
    }
  }
}
function letter(c) {
  if (c >= "a" ? c <= "z" : false) {
    return true;
  } else if (c >= "A") {
    return c <= "Z";
  } else {
    return false;
  }
}
function number(c) {
  if (c >= "0") {
    return c <= "9";
  } else {
    return false;
  }
}
function addAndTokenize(ctx, tok, i, l) {
  (function (arg00) {
    ctx.Tokens.push(arg00);
  })(new Token(tok, new _Range(i, i + l - 1)));

  return tokenizeInput(ctx, i + l);
}
function tokenizeIdent(ctx, start, l) {
  tokenizeIdent: while (true) {
    if (start + l < ctx.Input.length ? letter(ctx.Input[start + l]) ? true : number(ctx.Input[start + l]) : false) {
      ctx = ctx;
      start = start;
      l = l + 1;
      continue tokenizeIdent;
    } else {
      return addAndTokenize(ctx, new TokenKind("Ident", [ctx.Input.substr(start, l)]), start, l);
    }
  }
}
function tokenizeString(ctx, acc, start, l) {
  tokenizeString: while (true) {
    if (start + l >= ctx.Input.length) {
      return tokenizeStringEnd(true, ctx, acc, start, l);
    } else {
      var matchValue = ctx.Input[start + l];
      var $var85 = matchValue === "\\" ? start + l + 1 >= ctx.Input.length ? [0] : [1] : [1];

      switch ($var85[0]) {
        case 0:
          return tokenizeStringEnd(true, ctx, new List$2("\\", acc), start, l + 1);

        case 1:
          if (matchValue === "\"") {
            return tokenizeStringEnd(false, ctx, acc, start, l + 1);
          } else if (matchValue === "\\") {
            var matchValue_1 = ctx.Input[start + l + 1];

            if (matchValue_1 === "\"") {
              ctx = ctx;
              acc = new List$2("\"", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else if (matchValue_1 === "\\") {
              ctx = ctx;
              acc = new List$2("\\", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else if (matchValue_1 === "n") {
              ctx = ctx;
              acc = new List$2("\n", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else if (matchValue_1 === "t") {
              ctx = ctx;
              acc = new List$2("\t", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else {
              ctx = ctx;
              acc = ofArray([matchValue_1, "\\"], acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            }
          } else {
            ctx = ctx;
            acc = new List$2(matchValue, acc);
            start = start;
            l = l + 1;
            continue tokenizeString;
          }

      }
    }
  }
}
function tokenizeStringEnd(error, ctx, acc, start, l) {
  var str = _Array$from(acc).slice().reverse().join('');

  var rng = new _Range(start, start + l);

  if (error) {
    ctx.Errors.push(Tokenizer.inputEndInsideString(rng, str));
  }

  return addAndTokenize(ctx, new TokenKind("String", [str]), start, l);
}
function tokenizeQuotedIdent(ctx, start, l) {
  tokenizeQuotedIdent: while (true) {
    if (start + l >= ctx.Input.length) {
      return tokenizeQuotedIdentEnd(true, ctx, start, l);
    } else {
      var matchValue = ctx.Input[start + l];

      if (matchValue === "\n") {
        return tokenizeQuotedIdentEnd(true, ctx, start, l + 1);
      } else if (matchValue === "'") {
        return tokenizeQuotedIdentEnd(false, ctx, start, l + 1);
      } else {
        ctx = ctx;
        start = start;
        l = l + 1;
        continue tokenizeQuotedIdent;
      }
    }
  }
}
function tokenizeQuotedIdentEnd(error, ctx, start, l) {
  var rng = new _Range(start, start + l);
  var qid = ctx.Input.substr(start + 1, l - (error ? 1 : 2));
  var qid_1 = endsWith(qid, "\n") ? qid.substr(0, qid.length - 1) : qid;

  if (error) {
    ctx.Errors.push(Tokenizer.missingClosingQuote(rng, qid_1));
  }

  return addAndTokenize(ctx, new TokenKind("QIdent", [qid_1]), start, l);
}
function tokenizeWhite(ctx, start, l) {
  tokenizeWhite: while (true) {
    if (start + l < ctx.Input.length ? ctx.Input[start + l] === " " : false) {
      ctx = ctx;
      start = start;
      l = l + 1;
      continue tokenizeWhite;
    } else {
      return addAndTokenize(ctx, new TokenKind("White", [ctx.Input.substr(start, l)]), start, l);
    }
  }
}
function tokenizeNumber(ctx, decimal, start, l) {
  tokenizeNumber: while (true) {
    if (start + l < ctx.Input.length ? number(ctx.Input[start + l]) : false) {
      ctx = ctx;
      decimal = decimal;
      start = start;
      l = l + 1;
      continue tokenizeNumber;
    } else if ((start + l < ctx.Input.length ? !decimal : false) ? ctx.Input[start + l] === "." : false) {
      ctx = ctx;
      decimal = true;
      start = start;
      l = l + 1;
      continue tokenizeNumber;
    } else {
      var str = ctx.Input.substr(start, l);
      return addAndTokenize(ctx, new TokenKind("Number", [str, _Number$parseFloat(str)]), start, l);
    }
  }
}
function tokenizeInput(ctx, i) {
  if (i >= ctx.Input.length) {
    return ctx;
  } else {
    var matchValue = ctx.Input[i];
    var $var86 = matchValue === "-" ? startsWith(ctx.Input, i, 0, "->") ? [0] : [1] : [1];

    switch ($var86[0]) {
      case 0:
        return addAndTokenize(ctx, new TokenKind("Arrow", []), i, 2);

      case 1:
        var $var87 = matchValue === "f" ? startsWith(ctx.Input, i, 0, "fun") ? [0] : [1] : [1];

        switch ($var87[0]) {
          case 0:
            return addAndTokenize(ctx, new TokenKind("Fun", []), i, 3);

          case 1:
            var $var88 = matchValue === "l" ? startsWith(ctx.Input, i, 0, "let") ? [0] : [1] : [1];

            switch ($var88[0]) {
              case 0:
                return addAndTokenize(ctx, new TokenKind("Let", []), i, 3);

              case 1:
                var $var89 = matchValue === "t" ? startsWith(ctx.Input, i, 0, "true") ? [0] : [1] : [1];

                switch ($var89[0]) {
                  case 0:
                    return addAndTokenize(ctx, new TokenKind("Boolean", [true]), i, 4);

                  case 1:
                    var $var90 = matchValue === "f" ? startsWith(ctx.Input, i, 0, "false") ? [0] : [1] : [1];

                    switch ($var90[0]) {
                      case 0:
                        return addAndTokenize(ctx, new TokenKind("Boolean", [false]), i, 5);

                      case 1:
                        var $var91 = matchValue === "<" ? startsWith(ctx.Input, i, 0, "<=") ? [0] : [1] : [1];

                        switch ($var91[0]) {
                          case 0:
                            return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("LessThanOrEqual", [])]), i, 2);

                          case 1:
                            var $var92 = matchValue === ">" ? startsWith(ctx.Input, i, 0, ">=") ? [0] : [1] : [1];

                            switch ($var92[0]) {
                              case 0:
                                return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("GreaterThanOrEqual", [])]), i, 2);

                              case 1:
                                if (matchValue === "\n") {
                                  return addAndTokenize(ctx, new TokenKind("Newline", []), i, 1);
                                } else if (matchValue === " ") {
                                  return tokenizeWhite(ctx, i, 1);
                                } else if (matchValue === "\"") {
                                  return tokenizeString(ctx, new List$2(), i, 1);
                                } else if (matchValue === "'") {
                                  return tokenizeQuotedIdent(ctx, i, 1);
                                } else if (matchValue === "(") {
                                  return addAndTokenize(ctx, new TokenKind("LParen", []), i, 1);
                                } else if (matchValue === ")") {
                                  return addAndTokenize(ctx, new TokenKind("RParen", []), i, 1);
                                } else if (matchValue === "*") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Multiply", [])]), i, 1);
                                } else if (matchValue === "+") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Plus", [])]), i, 1);
                                } else if (matchValue === ",") {
                                  return addAndTokenize(ctx, new TokenKind("Comma", []), i, 1);
                                } else if (matchValue === "-") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Minus", [])]), i, 1);
                                } else if (matchValue === ".") {
                                  return addAndTokenize(ctx, new TokenKind("Dot", []), i, 1);
                                } else if (matchValue === "/") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Divide", [])]), i, 1);
                                } else if (matchValue === "<") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("LessThan", [])]), i, 1);
                                } else if (matchValue === "=") {
                                  return addAndTokenize(ctx, new TokenKind("Equals", []), i, 1);
                                } else if (matchValue === ">") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("GreaterThan", [])]), i, 1);
                                } else if (matchValue === "[") {
                                  return addAndTokenize(ctx, new TokenKind("LSquare", []), i, 1);
                                } else if (matchValue === "]") {
                                  return addAndTokenize(ctx, new TokenKind("RSquare", []), i, 1);
                                } else if (matchValue === "^") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Power", [])]), i, 1);
                                } else if (letter(matchValue)) {
                                  return tokenizeIdent(ctx, i, 1);
                                } else if (number(matchValue)) {
                                  return tokenizeNumber(ctx, false, i, 1);
                                } else {
                                  ctx.Errors.push(Tokenizer.unexpectedCharacter(new _Range(i, i), matchValue));
                                  return addAndTokenize(ctx, new TokenKind("Error", [matchValue]), i, 1);
                                }

                            }

                        }

                    }

                }

            }

        }

    }
  }
}
function tokenize(input) {
  var ctx = void 0;
  var Errors = [];
  ctx = new Context$1([], Errors, input);
  var ctx_1 = tokenizeInput(ctx, 0);
  ctx_1.Tokens.push(new Token(new TokenKind("EndOfFile", []), new _Range(input.length, input.length)));
  return [_Array$from(ctx_1.Tokens), _Array$from(ctx_1.Errors)];
}

var Context$$1 = function () {
  function Context$$1(tokens, whitespace, errors, topLevel, silent, strictlyNested, indentCurrent, indentStack, position) {
    _classCallCheck(this, Context$$1);

    this.Tokens = tokens;
    this.Whitespace = whitespace;
    this.Errors = errors;
    this.TopLevel = topLevel;
    this.Silent = silent;
    this.StrictlyNested = strictlyNested;
    this.IndentCurrent = indentCurrent;
    this.IndentStack = indentStack;
    this.Position = position;
  }

  _createClass(Context$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Parser.Context",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Tokens: FableArray(Token),
          Whitespace: FableArray(Token),
          Errors: FableArray(makeGeneric(_Error, {
            Range: _Range
          })),
          TopLevel: "boolean",
          Silent: "boolean",
          StrictlyNested: "boolean",
          IndentCurrent: "number",
          IndentStack: makeGeneric(List$2, {
            T: Tuple(["number", "boolean"])
          }),
          Position: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return Context$$1;
}();
setType("TheGamma.Parser.Context", Context$$1);
function clone(ctx) {
  return new Context$$1(ctx.Tokens, _Array$from(ctx.Whitespace), _Array$from(ctx.Errors), ctx.TopLevel, ctx.Silent, ctx.StrictlyNested, ctx.IndentCurrent, ctx.IndentStack, ctx.Position);
}
function next(ctx) {
  ctx.Position = ctx.Position + 1;
}
var DisposableHelper = function () {
  _createClass(DisposableHelper, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Parser.DisposableHelper",
        interfaces: ["System.IDisposable"],
        properties: {}
      };
    }
  }]);

  function DisposableHelper(f) {
    _classCallCheck(this, DisposableHelper);

    this.f = f;
  }

  _createClass(DisposableHelper, [{
    key: "Dispose",
    value: function () {
      this.f(null);
    }
  }]);

  return DisposableHelper;
}();
setType("TheGamma.Parser.DisposableHelper", DisposableHelper);
function disposable(f) {
  return new DisposableHelper(f);
}
function usingSilentMode(ctx) {
  var prev = ctx.Silent;
  ctx.Silent = true;
  return disposable(function () {
    ctx.Silent = prev;
  });
}
function addError(ctx, e) {
  if (!ctx.Silent) {
    ctx.Errors.push(e);
  }
}
function usingIndent(current, tok, ctx) {
  var started = void 0;
  var matchValue = ctx.IndentStack;
  var $var93 = matchValue.tail != null ? matchValue.head[1] ? function () {
    var prev_1 = matchValue.head[0];
    return prev_1 > ctx.IndentCurrent;
  }() ? [0, matchValue.head[0]] : [1] : [1] : [1];

  switch ($var93[0]) {
    case 0:
      (function (e) {
        addError(ctx, e);
      })(Parser.unindentedBlock(tok.Range, tok.Token));

      started = false;
      break;

    case 1:
      var $var94 = matchValue.tail != null ? matchValue.head[1] ? [1] : function () {
        var prev = matchValue.head[0];
        return prev !== ctx.IndentCurrent;
      }() ? [0, matchValue.head[0]] : [1] : [1];

      switch ($var94[0]) {
        case 0:
          throw new Error("usingIndent: We forgot to set the top-stack line indentation");
          break;

        case 1:
          ctx.IndentStack = new List$2([ctx.IndentCurrent, current], ctx.IndentStack);
          started = true;
          break;
      }

      break;
  }

  return disposable(function () {
    var matchValue_1 = [started, ctx.IndentStack];

    if (matchValue_1[0]) {
      if (matchValue_1[1].tail != null) {
        var t = matchValue_1[1].head;
        var stack = matchValue_1[1].tail;
        ctx.IndentStack = stack;
      } else {
        throw new Error("usingIndent: We lost item from an indentation stack");
      }
    }
  });
}
function usingTopLevelNesting(ctx) {
  var prev = ctx.StrictlyNested;
  ctx.StrictlyNested = true;
  var matchValue = ctx.IndentStack;

  if (matchValue.tail != null) {
    ctx.IndentStack = new List$2([0, true], matchValue.tail);
  }

  return disposable(function () {
    ctx.StrictlyNested = prev;
  });
}
function usingNonTopLevel(ctx) {
  var prev = ctx.TopLevel;
  ctx.TopLevel = false;
  return disposable(function () {
    ctx.TopLevel = prev;
  });
}
function setLineIndent(ctx, l) {
  ctx.IndentCurrent = l;
  var matchValue = ctx.IndentStack;
  var $var95 = matchValue.tail != null ? matchValue.head[1] ? [1] : function () {
    var oldl = matchValue.head[0];
    return l <= oldl;
  }() ? [0, matchValue.head[0], matchValue.tail] : [1] : [1];

  switch ($var95[0]) {
    case 0:
      ctx.IndentStack = new List$2([2147483647, true], $var95[2]);
      break;

    case 1:
      var $var96 = matchValue.tail != null ? matchValue.head[1] ? [1] : [0, matchValue.head[0], matchValue.tail] : [1];

      switch ($var96[0]) {
        case 0:
          ctx.IndentStack = new List$2([l, true], $var96[2]);
          break;

        case 1:
          break;
      }

      break;
  }
}
function justToken(ctx) {
  justToken: while (true) {
    var current = function current(ctx_1) {
      return ctx_1.Tokens[ctx_1.Position];
    };

    var matchValue = current(ctx);
    var $var97 = matchValue.Token.Case === "Newline" ? [0] : matchValue.Token.Case === "Error" ? [1, matchValue] : matchValue.Token.Case === "White" ? [1, matchValue] : [2];

    switch ($var97[0]) {
      case 0:
        ctx.Whitespace.push(matchValue);
        next(ctx);
        var matchValue_1 = current(ctx);

        if (matchValue_1.Token.Case === "White") {
          var s = matchValue_1.Token.Fields[0];
          ctx.Whitespace.push(matchValue_1);
          setLineIndent(ctx, s.length);
          next(ctx);
        } else {
          setLineIndent(ctx, 0);
        }

        ctx = ctx;
        continue justToken;

      case 1:
        ctx.Whitespace.push($var97[1]);
        next(ctx);
        ctx = ctx;
        continue justToken;

      case 2:
        return matchValue;
    }
  }
}
function token(ctx) {
  var t = justToken(ctx);
  var white = toList(ctx.Whitespace);
  ctx.Whitespace.splice(0);
  return [white, t];
}
function nestedToken(ctx) {
  var white_1 = function white_1() {
    var white = toList(ctx.Whitespace);
    ctx.Whitespace.splice(0);
    return white;
  };

  var t = justToken(ctx);
  var matchValue = ctx.IndentStack;
  var $var98 = matchValue.tail != null ? function () {
    var indent = matchValue.head[0];

    if (ctx.IndentCurrent > indent) {
      return true;
    } else if (!ctx.StrictlyNested) {
      return ctx.IndentCurrent === indent;
    } else {
      return false;
    }
  }() ? [0, matchValue.head[0]] : [1] : [1];

  switch ($var98[0]) {
    case 0:
      return [white_1(null), t];

    case 1:
      if (matchValue.tail == null) {
        return [white_1(null), t];
      } else {
        return null;
      }

  }
}
function node$1(rng, n) {
  return new _Node(new List$2(), new List$2(), rng, n, null);
}
function whiteAfter(w, n) {
  var WhiteAfter = append$$1(n.WhiteAfter, w);
  return new _Node(n.WhiteBefore, WhiteAfter, n.Range, n.Node, n.Entity);
}
function whiteBefore(w, n) {
  return new _Node(append$$1(w, n.WhiteBefore), n.WhiteAfter, n.Range, n.Node, n.Entity);
}
function lastCallOrPropertyRange(expr, id) {
  var $var99 = expr.Node.Case === "Call" ? [0, expr.Node.Fields[1]] : expr.Node.Case === "Property" ? [0, expr.Node.Fields[1]] : [1];

  switch ($var99[0]) {
    case 0:
      return $var99[1].Range;

    case 1:
      return expr.Range;
  }
}

function _Identifier___(t_0, t_1) {
  var t = [t_0, t_1];
  var $var100 = t[1].Token.Case === "Ident" ? [0, t[1].Token.Fields[0], t[1].Range, t[0]] : t[1].Token.Case === "QIdent" ? [0, t[1].Token.Fields[0], t[1].Range, t[0]] : [1];

  switch ($var100[0]) {
    case 0:
      return function (n) {
        return whiteBefore($var100[3], n);
      }(node$1($var100[2], new Name($var100[1])));

    case 1:
      return null;
  }
}

var Associativity = function () {
  function Associativity(caseName, fields) {
    _classCallCheck(this, Associativity);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Associativity, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Parser.Associativity",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Left: [],
          Right: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Associativity;
}();
setType("TheGamma.Parser.Associativity", Associativity);
function precedence(_arg1) {
  var $var101 = _arg1.Case === "GreaterThan" ? [1] : _arg1.Case === "GreaterThanOrEqual" ? [1] : _arg1.Case === "LessThan" ? [1] : _arg1.Case === "LessThanOrEqual" ? [1] : _arg1.Case === "Plus" ? [2] : _arg1.Case === "Minus" ? [2] : _arg1.Case === "Multiply" ? [3] : _arg1.Case === "Divide" ? [3] : _arg1.Case === "Power" ? [4] : [0];

  switch ($var101[0]) {
    case 0:
      return [0, new Associativity("Left", [])];

    case 1:
      return [1, new Associativity("Left", [])];

    case 2:
      return [2, new Associativity("Left", [])];

    case 3:
      return [3, new Associativity("Left", [])];

    case 4:
      return [4, new Associativity("Right", [])];
  }
}
var OpExpr = function () {
  function OpExpr(caseName, fields) {
    _classCallCheck(this, OpExpr);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(OpExpr, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Parser.OpExpr",
        interfaces: ["FSharpUnion"],
        cases: {
          OpExpr: [makeGeneric(_Node, {
            T: Expr
          }), Option(Tuple([makeGeneric(_Node, {
            T: Operator
          }), OpExpr]))]
        }
      };
    }
  }]);

  return OpExpr;
}();
setType("TheGamma.Parser.OpExpr", OpExpr);
function precClimb(minPrec, _arg1) {
  var loop = function loop(result) {
    return function (next_1) {
      loop: while (true) {
        var $var102 = next_1 != null ? function () {
          var op = next_1[0];
          var next_2 = next_1[1];
          return precedence(op.Node)[0] >= minPrec;
        }() ? [0, next_1[1], next_1[0]] : [1] : [1];

        switch ($var102[0]) {
          case 0:
            var patternInput = precedence($var102[2].Node);
            var nextMinPrec = patternInput[1].Equals(new Associativity("Left", [])) ? patternInput[0] + 1 : patternInput[0];
            var patternInput_1 = precClimb(nextMinPrec, $var102[1]);
            var result_1 = node$1(unionRanges(result.Range, patternInput_1[0].Range), new Expr("Binary", [result, $var102[2], patternInput_1[0]]));
            result = result_1;
            next_1 = patternInput_1[1];
            continue loop;

          case 1:
            return [result, next_1];
        }
      }
    };
  };

  return loop(_arg1.Fields[0])(_arg1.Fields[1]);
}
function buildExpression(terms, term) {
  return precClimb(0, fold$1(function (oe, tupledArg) {
    return new OpExpr("OpExpr", [tupledArg[0], [tupledArg[1], oe]]);
  }, new OpExpr("OpExpr", [term, null]), terms))[0];
}
function makeCallOrProp(optInst, prevId, prevArgs) {
  var matchValue = [optInst, prevArgs];
  var $var103 = matchValue[0] == null ? matchValue[1] != null ? [2, matchValue[1]] : [1] : matchValue[1] != null ? [2, matchValue[1]] : [0, matchValue[0]];

  switch ($var103[0]) {
    case 0:
      return node$1(unionRanges($var103[1].Range, prevId.Range), new Expr("Property", [$var103[1], prevId]));

    case 1:
      return node$1(prevId.Range, new Expr("Variable", [prevId]));

    case 2:
      var fullRng = optInst != null ? unionRanges(optInst.Range, $var103[1].Range) : unionRanges(prevId.Range, $var103[1].Range);
      return node$1(fullRng, new Expr("Call", [optInst, prevId, $var103[1]]));
  }
}
function parseChain(dotRng, optInst, prevId, prevArgs, prevWhite, ctx) {
  var inst = function (n) {
    return whiteAfter(prevWhite, n);
  }(makeCallOrProp(optInst, prevId, prevArgs));

  var emptyRng = new _Range(dotRng.End + 1, dotRng.End + 1);
  var emptyMember = node$1(emptyRng, new Expr("Property", [inst, node$1(emptyRng, new Name(""))]));
  var matchValue = nestedToken(ctx);
  var $var104 = void 0;

  if (matchValue != null) {
    var activePatternResult5730 = _Identifier___(matchValue[0], matchValue[1]);

    if (activePatternResult5730 != null) {
      $var104 = [0, activePatternResult5730];
    } else {
      $var104 = [1];
    }
  } else {
    $var104 = [1];
  }

  switch ($var104[0]) {
    case 0:
      next(ctx);
      return parseMember(inst, $var104[1], ctx);

    case 1:
      if (matchValue == null) {
        var matchValue_1 = token(ctx);

        var activePatternResult5729 = _Identifier___(matchValue_1[0], matchValue_1[1]);

        if (activePatternResult5729 != null) {
          var _ret = function () {
            var rng = function rng(id) {
              return lastCallOrPropertyRange(inst, id);
            };

            (function (e) {
              addError(ctx, e);
            })(Parser.unindentedIdentifierAfterDot(activePatternResult5729.Range, rng, activePatternResult5729.Node.Name));

            var matchValue_2 = [ctx.TopLevel, ctx.IndentStack];
            var $var105 = matchValue_2[0] ? [1] : matchValue_2[1].tail != null ? function () {
              var stack = matchValue_2[1].tail;
              var sl = matchValue_2[1].head[0];
              var si = matchValue_2[1].head[1];
              return ctx.IndentCurrent > 0;
            }() ? [0, matchValue_2[1].head[1], matchValue_2[1].head[0], matchValue_2[1].tail] : [1] : [1];

            switch ($var105[0]) {
              case 0:
                next(ctx);
                ctx.IndentStack = new List$2([ctx.IndentCurrent, $var105[1]], $var105[3]);
                return {
                  v: parseMember(inst, activePatternResult5729, ctx)
                };

              case 1:
                return {
                  v: emptyMember
                };
            }
          }();

          if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
        } else {
          var rng_1 = function rng_1(id_1) {
            return lastCallOrPropertyRange(inst, id_1);
          };

          (function (e_1) {
            addError(ctx, e_1);
          })(Parser.unexpectedScopeEndAfterDot(matchValue_1[1].Range, rng_1, matchValue_1[1].Token));

          return emptyMember;
        }
      } else {
        var t = matchValue[1];

        (function (e_2) {
          addError(ctx, e_2);
        })(Parser.unexpectedTokenAfterDot(t.Range, t.Token));

        if (t.Token.Equals(new TokenKind("EndOfFile", []))) {
          return emptyMember;
        } else {
          next(ctx);

          var _silent = usingSilentMode(ctx);

          try {
            return parseMember(inst, node$1(emptyRng, new Name("")), ctx);
          } finally {
            if (hasInterface(_silent, "System.IDisposable")) {
              _silent.Dispose();
            }
          }
        }
      }

  }
}
function parseDotOrLParen(optInst, id, ctx, tok) {
  if (tok.Token.Case === "LParen") {
    next(ctx);

    var _top = usingNonTopLevel(ctx);

    try {
      var _ret2 = function () {
        var patternInput = parseCallArgList(false, tok.Range, new List$2(), ctx);

        var args = function (n) {
          return whiteAfter(patternInput[1], n);
        }(node$1(unionRanges(tok.Range, patternInput[0]), patternInput[2]));

        var matchValue = nestedToken(ctx);
        var $var106 = matchValue != null ? matchValue[1].Token.Case === "Dot" ? [0, matchValue[1].Range, matchValue[0]] : [1] : [1];

        switch ($var106[0]) {
          case 0:
            next(ctx);
            return {
              v: parseChain($var106[1], optInst, id, args, $var106[2], ctx)
            };

          case 1:
            return {
              v: makeCallOrProp(optInst, id, args)
            };
        }
      }();

      if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    } finally {
      if (hasInterface(_top, "System.IDisposable")) {
        _top.Dispose();
      }
    }
  } else if (tok.Token.Case === "Dot") {
    next(ctx);
    return parseChain(tok.Range, optInst, id, null, new List$2(), ctx);
  } else {
    return null;
  }
}
function parseMember(optInst, id, ctx) {
  var parsed = void 0;
  var matchValue = nestedToken(ctx);

  if (matchValue != null) {
    var white = matchValue[0];
    var res = matchValue[1];
    parsed = parseDotOrLParen(optInst, whiteAfter(white, id), ctx, res);
  } else {
    var patternInput = token(ctx);
    var matchValue_1 = void 0;

    var _silent = usingSilentMode(ctx);

    try {
      matchValue_1 = parseDotOrLParen(optInst, whiteAfter(patternInput[0], id), ctx, patternInput[1]);
    } finally {
      if (hasInterface(_silent, "System.IDisposable")) {
        _silent.Dispose();
      }
    }

    if (matchValue_1 != null) {
      (function (e) {
        addError(ctx, e);
      })(Parser.unindentedDotAfterIdentifier(id.Range, patternInput[1].Range));

      parsed = matchValue_1;
    } else {
      parsed = null;
    }
  }

  if (parsed == null) {
    if (optInst == null) {
      return node$1(id.Range, new Expr("Variable", [id]));
    } else {
      return node$1(unionRanges(optInst.Range, id.Range), new Expr("Property", [optInst, id]));
    }
  } else {
    return parsed;
  }
}
function parseFunction(ctx, funRng) {
  var matchValue = nestedToken(ctx);
  var $var107 = void 0;

  if (matchValue != null) {
    var activePatternResult5752 = _Identifier___(matchValue[0], matchValue[1]);

    if (activePatternResult5752 != null) {
      $var107 = [0, activePatternResult5752];
    } else {
      $var107 = [1];
    }
  } else {
    $var107 = [1];
  }

  switch ($var107[0]) {
    case 0:
      next(ctx);
      var matchValue_1 = nestedToken(ctx);
      var $var108 = matchValue_1 != null ? matchValue_1[1].Token.Case === "Arrow" ? [0, matchValue_1[1].Range, matchValue_1[0]] : [1, matchValue_1] : [1, matchValue_1];

      switch ($var108[0]) {
        case 0:
          next(ctx);
          var body = void 0;
          var matchValue_2 = parseExpression(new List$2(), ctx);

          if (matchValue_2 != null) {
            body = matchValue_2;
          } else {
            (function (e) {
              addError(ctx, e);
            })(Parser.missingBodyOfFunc(unionRanges(funRng, $var108[1])));

            body = node$1(new _Range($var108[1].End, $var108[1].End), new Expr("Empty", []));
          }

          var rng = unionRanges(funRng, body.Range);
          return node$1(rng, new Expr("Function", [whiteAfter($var108[2], $var107[1]), body]));

        case 1:
          var patternInput = void 0;

          if ($var108[1] != null) {
            var whiteAfterId = $var108[1][0];
            var t = $var108[1][1];
            patternInput = [t.Range, whiteAfterId];
          } else {
            patternInput = [unionRanges(funRng, $var107[1].Range), new List$2()];
          }

          (function (e_1) {
            addError(ctx, e_1);
          })(Parser.missingArrowInFunc(patternInput[0]));

          var body_1 = void 0;
          var matchValue_3 = parseExpression(new List$2(), ctx);

          if (matchValue_3 != null) {
            body_1 = matchValue_3;
          } else {
            body_1 = node$1(new _Range($var107[1].Range.End, $var107[1].Range.End), new Expr("Empty", []));
          }

          return node$1(unionRanges(funRng, body_1.Range), new Expr("Function", [$var107[1], whiteBefore(patternInput[1], body_1)]));
      }

    case 1:
      if (matchValue == null) {
        (function (e_2) {
          addError(ctx, e_2);
        })(Parser.unexpectedScopeEndInFunc(funRng));

        var rng_1 = new _Range(funRng.End, funRng.End);
        return node$1(rng_1, new Expr("Function", [node$1(rng_1, new Name("")), node$1(rng_1, new Expr("Empty", []))]));
      } else {
        var _ret3 = function () {
          var white = matchValue[0];
          var t_1 = matchValue[1];

          (function (e_3) {
            addError(ctx, e_3);
          })(Parser.unexpectedTokenAfterFun(t_1.Range, t_1.Token));

          var rng_2 = new _Range(funRng.End, funRng.End);
          return {
            v: function (n) {
              return whiteBefore(white, n);
            }(node$1(rng_2, new Expr("Function", [node$1(rng_2, new Name("")), node$1(rng_2, new Expr("Empty", []))])))
          };
        }();

        if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
      }

  }
}
function parseTerm(ctx) {
  var matchValue = nestedToken(ctx);
  var $var109 = void 0;

  if (matchValue != null) {
    var activePatternResult5762 = _Identifier___(matchValue[0], matchValue[1]);

    if (activePatternResult5762 != null) {
      $var109 = [0, activePatternResult5762, matchValue[1]];
    } else {
      $var109 = [1];
    }
  } else {
    $var109 = [1];
  }

  var _ret4 = function () {
    switch ($var109[0]) {
      case 0:
        next(ctx);

        var _indent = usingIndent(false, $var109[2], ctx);

        try {
          var varOrCall = parseMember(null, $var109[1], ctx);
          return {
            v: varOrCall
          };
        } finally {
          if (hasInterface(_indent, "System.IDisposable")) {
            _indent.Dispose();
          }
        }

      case 1:
        var $var110 = matchValue != null ? matchValue[1].Token.Case === "Number" ? [0, matchValue[1].Token.Fields[1], matchValue[1].Range, matchValue[0]] : matchValue[1].Token.Case === "String" ? [1, matchValue[1].Range, matchValue[1].Token.Fields[0], matchValue[0]] : matchValue[1].Token.Case === "Boolean" ? [2, matchValue[1].Token.Fields[0], matchValue[1].Range, matchValue[0]] : matchValue[1].Token.Case === "LParen" ? [3, matchValue[1], matchValue[0]] : matchValue[1].Token.Case === "LSquare" ? [4, matchValue[1], matchValue[0]] : matchValue[1].Token.Case === "Fun" ? [5, matchValue[1], matchValue[0]] : [6] : [6];

        switch ($var110[0]) {
          case 0:
            next(ctx);
            return {
              v: function (n) {
                return whiteAfter($var110[3], n);
              }(node$1($var110[2], new Expr("Number", [$var110[1]])))
            };

          case 1:
            next(ctx);
            return {
              v: function (n_1) {
                return whiteAfter($var110[3], n_1);
              }(node$1($var110[1], new Expr("String", [$var110[2]])))
            };

          case 2:
            next(ctx);
            return {
              v: function (n_2) {
                return whiteAfter($var110[3], n_2);
              }(node$1($var110[2], new Expr("Boolean", [$var110[1]])))
            };

          case 3:
            next(ctx);
            return {
              v: parseParenTermEnd(new List$2($var110[1], reverse$$1($var110[2])), new List$2(), parseExpression(new List$2(), ctx), ctx)
            };

          case 4:
            next(ctx);

            var _nest = usingNonTopLevel(ctx);

            try {
              return {
                v: parseListElements(false, $var110[1].Range, $var110[2], $var110[1].Range, new List$2(), ctx)
              };
            } finally {
              if (hasInterface(_nest, "System.IDisposable")) {
                _nest.Dispose();
              }
            }

          case 5:
            next(ctx);
            return {
              v: parseFunction(ctx, $var110[1].Range)
            };

          case 6:
            return {
              v: null
            };
        }

    }
  }();

  if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
}
function parseListElements(expectMore, lastRng, whiteStart, startRng, acc, ctx) {
  var _loop = function _loop() {
    var patternInput = void 0;
    var matchValue = parseExpression(new List$2(), ctx);

    if (matchValue != null) {
      patternInput = [true, function (white) {
        return new List$2(whiteAfter(white, matchValue), acc);
      }];
    } else {
      patternInput = [false, function (_arg1) {
        return acc;
      }];
    }

    var matchValue_1 = nestedToken(ctx);
    var $var111 = matchValue_1 != null ? matchValue_1[1].Token.Case === "RSquare" ? [0, matchValue_1[1].Range, matchValue_1[0]] : matchValue_1[1].Token.Case === "Comma" ? [1, matchValue_1[1].Range, matchValue_1[0]] : function () {
      var t = matchValue_1[1];
      return !t.Token.Equals(new TokenKind("EndOfFile", []));
    }() ? [2, matchValue_1[1]] : [3] : [3];

    switch ($var111[0]) {
      case 0:
        next(ctx);
        return {
          v: function (n) {
            return whiteBefore($var111[2], n);
          }(node$1(unionRanges(startRng, $var111[1]), new Expr("List", [reverse$$1(patternInput[1](new List$2()))])))
        };

      case 1:
        next(ctx);

        if (!patternInput[0] ? expectMore : false) {
          (function (e) {
            addError(ctx, e);
          })(Parser.unexpectedTokenInList($var111[1], new TokenKind("Comma", [])));
        }

        expectMore = true;
        lastRng = $var111[1];
        whiteStart = whiteStart;
        startRng = startRng;
        acc = patternInput[1]($var111[2]);
        ctx = ctx;
        return "continue|parseListElements";

      case 2:
        next(ctx);

        (function (e_1) {
          addError(ctx, e_1);
        })(Parser.unexpectedTokenInList($var111[1].Range, $var111[1].Token));

        expectMore = expectMore;
        lastRng = $var111[1].Range;
        whiteStart = whiteStart;
        startRng = startRng;
        acc = patternInput[1](new List$2());
        ctx = ctx;
        return "continue|parseListElements";

      case 3:
        (function (e_2) {
          addError(ctx, e_2);
        })(Parser.unexpectedScopeEndInList(lastRng));

        return {
          v: node$1(unionRanges(startRng, lastRng), new Expr("List", [reverse$$1(patternInput[1](new List$2()))]))
        };
    }
  };

  parseListElements: while (true) {
    var _ret5 = _loop();

    switch (_ret5) {
      case "continue|parseListElements":
        continue parseListElements;

      default:
        if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
    }
  }
}
function parseParenTermEnd(wb, wa, bodyOpt, ctx) {
  parseParenTermEnd: while (true) {
    var makeBody = function makeBody(wa_1) {
      var body = void 0;

      if (bodyOpt == null) {
        var rng = function (list) {
          return reduce(function (r1, r2) {
            return unionRanges(r1, r2);
          }, list);
        }(map$4(function (t) {
          return t.Range;
        }, append$$1(ofArray([wb.head]), wa_1)));

        (function (e) {
          addError(ctx, e);
        })(Parser.missingParenthesizedExpr(rng));

        body = node$1(rng, new Expr("Empty", []));
      } else {
        body = bodyOpt;
      }

      return whiteAfter(reverse$$1(wa_1), whiteBefore(reverse$$1(wb), body));
    };

    var _matchValue = nestedToken(ctx);

    if (_matchValue == null) {
      var rng_1 = bodyOpt != null ? bodyOpt.Range : wb.head.Range;

      (function (e_1) {
        addError(ctx, e_1);
      })(Parser.unindentedTokenInParenthesizedExpr(rng_1));

      return makeBody(wa);
    } else if (_matchValue[1].Token.Case === "RParen") {
      next(ctx);
      return makeBody(new List$2(_matchValue[1], append$$1(reverse$$1(_matchValue[0]), wa)));
    } else {
      next(ctx);

      (function (e_2) {
        addError(ctx, e_2);
      })(Parser.unexpectedTokenInParenthesizedExpr(_matchValue[1].Range, _matchValue[1].Token));

      wb = wb;
      wa = new List$2(_matchValue[1], append$$1(reverse$$1(_matchValue[0]), wa));
      bodyOpt = bodyOpt;
      ctx = ctx;
      continue parseParenTermEnd;
    }
  }
}
function parseExpression(terms, ctx) {
  parseExpression: while (true) {
    var _matchValue2 = [terms, parseTerm(ctx)];

    if (_matchValue2[1] == null) {
      if (_matchValue2[0].tail != null) {
        var terms_1 = _matchValue2[0].tail;
        var term = _matchValue2[0].head[0];
        var op = _matchValue2[0].head[1];
        var next_1 = justToken(ctx);

        (function (e) {
          addError(ctx, e);
        })(Parser.unexpectedTokenAfterOperator(next_1.Range, new TokenKind("Operator", [op.Node]), next_1.Token));

        return buildExpression(terms_1, term);
      } else {
        return null;
      }
    } else {
      var term_1 = _matchValue2[1];

      var _matchValue_ = nestedToken(ctx);

      var $var112 = _matchValue_ != null ? _matchValue_[1].Token.Case === "Equals" ? [0, _matchValue_[1], _matchValue_[0]] : _matchValue_[1].Token.Case === "Operator" ? [1, _matchValue_[1].Token.Fields[0], _matchValue_[1], _matchValue_[0]] : [2] : [2];

      switch ($var112[0]) {
        case 0:
          next(ctx);
          terms = new List$2([term_1, whiteBefore($var112[2], node$1($var112[1].Range, new Operator("Equals", [])))], _matchValue2[0]);
          ctx = ctx;
          continue parseExpression;

        case 1:
          next(ctx);
          terms = new List$2([term_1, whiteBefore($var112[3], node$1($var112[2].Range, $var112[1]))], _matchValue2[0]);
          ctx = ctx;
          continue parseExpression;

        case 2:
          return buildExpression(_matchValue2[0], term_1);
      }
    }
  }
}
function parseExpressionOrNamedParam(ctx) {
  var lookAheadCtx = clone(ctx);
  var matchValue = nestedToken(lookAheadCtx);
  var $var113 = void 0;

  if (matchValue != null) {
    var activePatternResult5782 = _Identifier___(matchValue[0], matchValue[1]);

    if (activePatternResult5782 != null) {
      $var113 = [0, activePatternResult5782];
    } else {
      $var113 = [1];
    }
  } else {
    $var113 = [1];
  }

  switch ($var113[0]) {
    case 0:
      next(lookAheadCtx);

      var _matchValue_2 = nestedToken(lookAheadCtx);

      var $var114 = _matchValue_2 != null ? _matchValue_2[1].Token.Case === "Equals" ? [0, _matchValue_2[1], _matchValue_2[0]] : [1] : [1];

      switch ($var114[0]) {
        case 0:
          nestedToken(ctx);
          next(ctx);
          nestedToken(ctx);
          next(ctx);
          var matchValue_2 = parseExpression(new List$2(), ctx);

          if (matchValue_2 == null) {
            (function (e) {
              addError(ctx, e);
            })(Parser.unexpectedTokenInArgList($var114[1].Range, $var114[1].Token));

            return new Choice("Choice2Of2", [node$1($var113[1].Range, new Expr("Variable", [$var113[1]]))]);
          } else {
            return new Choice("Choice1Of2", [[whiteAfter($var114[2], $var113[1]), matchValue_2]]);
          }

        case 1:
          return new Choice("Choice2Of2", [parseExpression(new List$2(), ctx)]);
      }

    case 1:
      return new Choice("Choice2Of2", [parseExpression(new List$2(), ctx)]);
  }
}
function parseCallArgList(expectMore, lastRng, acc, ctx) {
  var _loop2 = function _loop2() {
    var patternInput = void 0;
    var matchValue = parseExpressionOrNamedParam(ctx);

    if (matchValue.Case === "Choice1Of2") {
      patternInput = [true, new List$2(new Argument(matchValue.Fields[0][0], matchValue.Fields[0][1]), acc)];
    } else if (matchValue.Fields[0] != null) {
      patternInput = [true, new List$2(new Argument(null, matchValue.Fields[0]), acc)];
    } else {
      patternInput = [false, acc];
    }

    var matchValue_1 = nestedToken(ctx);
    var $var115 = matchValue_1 != null ? matchValue_1[1].Token.Case === "RParen" ? [0, matchValue_1[1], matchValue_1[0]] : matchValue_1[1].Token.Case === "Comma" ? function () {
      var white = matchValue_1[0];
      var lastRng_1 = matchValue_1[1].Range;
      return patternInput[0];
    }() ? [1, matchValue_1[1].Range, matchValue_1[0]] : [2] : [2] : [2];

    switch ($var115[0]) {
      case 0:
        next(ctx);

        if (expectMore ? !patternInput[0] : false) {
          (function (e) {
            addError(ctx, e);
          })(Parser.unexpectedTokenInArgList(lastRng, new TokenKind("RParen", [])));
        }

        return {
          v: [$var115[1].Range, $var115[2], reverse$$1(patternInput[1])]
        };

      case 1:
        next(ctx);
        expectMore = true;
        lastRng = $var115[1];
        acc = patternInput[1];
        ctx = ctx;
        return "continue|parseCallArgList";

      case 2:
        var $var116 = matchValue_1 != null ? function () {
          var t = matchValue_1[1];
          return !t.Token.Equals(new TokenKind("EndOfFile", []));
        }() ? [0, matchValue_1[1]] : [1] : [1];

        switch ($var116[0]) {
          case 0:
            next(ctx);

            (function (e_1) {
              addError(ctx, e_1);
            })(Parser.unexpectedTokenInArgList($var116[1].Range, $var116[1].Token));

            expectMore = expectMore;
            lastRng = $var116[1].Range;
            acc = patternInput[1];
            ctx = ctx;
            return "continue|parseCallArgList";

          case 1:
            (function (e_2) {
              addError(ctx, e_2);
            })(Parser.unexpectedScopeEndInArgList(lastRng));

            return {
              v: [lastRng, new List$2(), reverse$$1(patternInput[1])]
            };
        }

    }
  };

  parseCallArgList: while (true) {
    var _ret6 = _loop2();

    switch (_ret6) {
      case "continue|parseCallArgList":
        continue parseCallArgList;

      default:
        if ((typeof _ret6 === "undefined" ? "undefined" : _typeof(_ret6)) === "object") return _ret6.v;
    }
  }
}
function parseNestedExpressions(wacc, acc, ctx) {
  parseNestedExpressions: while (true) {
    var _matchValue3 = parseExpression(new List$2(), ctx);

    if (_matchValue3 != null) {
      if (!(acc.tail == null)) {
        (function (e) {
          addError(ctx, e);
        })(Parser.nestedExpressionInCommand(_matchValue3.Range));

        var _var119 = new List$2();

        acc = new List$2(whiteBefore(reverse$$1(wacc), _matchValue3), acc);
        ctx = ctx;
        wacc = _var119;
        continue parseNestedExpressions;
      } else {
        var _strict = usingTopLevelNesting(ctx);

        try {
          return parseNestedExpressions(new List$2(), new List$2(whiteBefore(reverse$$1(wacc), _matchValue3), acc), ctx);
        } finally {
          if (hasInterface(_strict, "System.IDisposable")) {
            _strict.Dispose();
          }
        }
      }
    } else {
      var _matchValue_3 = nestedToken(ctx);

      var $var117 = _matchValue_3 == null ? [0] : _matchValue_3[1].Token.Case === "EndOfFile" ? [0] : [1, _matchValue_3[1], _matchValue_3[0]];

      switch ($var117[0]) {
        case 0:
          if (acc.tail == null) {
            return new List$2();
          } else {
            return new List$2(whiteAfter(reverse$$1(wacc), acc.head), acc.tail);
          }

        case 1:
          next(ctx);
          wacc = append$$1(new List$2($var117[1], reverse$$1($var117[2])), wacc);
          acc = acc;
          ctx = ctx;
          continue parseNestedExpressions;
      }
    }
  }
}
function parseLetBinding(whiteBeforeLet, rngLet, ctx) {
  var matchValue = nestedToken(ctx);
  var $var118 = void 0;

  if (matchValue != null) {
    var activePatternResult5793 = _Identifier___(matchValue[0], matchValue[1]);

    if (activePatternResult5793 != null) {
      $var118 = [0, activePatternResult5793];
    } else {
      $var118 = [1];
    }
  } else {
    $var118 = [1];
  }

  switch ($var118[0]) {
    case 0:
      next(ctx);

      var _matchValue_4 = nestedToken(ctx);

      if (_matchValue_4 == null) {
        (function (e) {
          addError(ctx, e);
        })(Parser.missingBodyInLetBinding($var118[1].Range));

        var body = node$1(new _Range($var118[1].Range.End, $var118[1].Range.End), new Expr("Empty", []));
        return [new List$2(), function (n) {
          return whiteBefore(whiteBeforeLet, n);
        }(node$1(unionRanges(rngLet, $var118[1].Range), new Command("Let", [$var118[1], body])))];
      } else if (_matchValue_4[1].Token.Case === "Equals") {
        next(ctx);
        var matchValue_2 = reverse$$1(parseNestedExpressions(new List$2(), new List$2(), ctx));

        if (matchValue_2.tail == null) {
          (function (e_1) {
            addError(ctx, e_1);
          })(Parser.missingBodyInLetBinding(unionRanges(rngLet, _matchValue_4[1].Range)));

          return [new List$2(), function (n_1) {
            return whiteBefore(whiteBeforeLet, n_1);
          }(node$1(unionRanges(rngLet, _matchValue_4[1].Range), new Command("Let", [whiteAfter(_matchValue_4[0], $var118[1]), node$1(new _Range(_matchValue_4[1].Range.End, _matchValue_4[1].Range.End), new Expr("Empty", []))])))];
        } else {
          return [matchValue_2.tail, function (n_2) {
            return whiteBefore(whiteBeforeLet, n_2);
          }(node$1(unionRanges(rngLet, matchValue_2.head.Range), new Command("Let", [whiteAfter(_matchValue_4[0], $var118[1]), matchValue_2.head])))];
        }
      } else {
        (function (e_2) {
          addError(ctx, e_2);
        })(Parser.unexpectedTokenInLetBinding(_matchValue_4[1].Range, _matchValue_4[1].Token));

        var _patternInput = void 0;

        var matchValue_3 = reverse$$1(parseNestedExpressions(new List$2(), new List$2(), ctx));

        if (matchValue_3.tail == null) {
          _patternInput = [node$1(new _Range($var118[1].Range.End, $var118[1].Range.End), new Expr("Empty", [])), new List$2()];
        } else {
          _patternInput = [matchValue_3.head, matchValue_3.tail];
        }

        return [_patternInput[1], function (n_3) {
          return whiteBefore(whiteBeforeLet, n_3);
        }(node$1(unionRanges(rngLet, $var118[1].Range), new Command("Let", [whiteAfter(_matchValue_4[0], $var118[1]), _patternInput[0]])))];
      }

    case 1:
      if (matchValue == null) {
        (function (e_3) {
          addError(ctx, e_3);
        })(Parser.missingBodyInLetBinding(rngLet));

        var rng = new _Range(rngLet.End, rngLet.End);
        return [new List$2(), function (n_4) {
          return whiteBefore(whiteBeforeLet, n_4);
        }(node$1(rng, new Command("Let", [node$1(rng, new Name("")), node$1(rng, new Expr("Empty", []))])))];
      } else {
        var whiteAfterLet = matchValue[0];
        var t = matchValue[1];

        (function (e_4) {
          addError(ctx, e_4);
        })(Parser.unexpectedTokenInLetBinding(t.Range, t.Token));

        var letEndRng = new _Range(rngLet.End, rngLet.End);
        var patternInput_1 = void 0;
        var matchValue_4 = reverse$$1(parseNestedExpressions(new List$2(), new List$2(), ctx));

        if (matchValue_4.tail == null) {
          patternInput_1 = [node$1(letEndRng, new Expr("Empty", [])), new List$2()];
        } else {
          patternInput_1 = [matchValue_4.head, matchValue_4.tail];
        }

        return [patternInput_1[1], function (n_5) {
          return whiteBefore(whiteBeforeLet, n_5);
        }(node$1(unionRanges(rngLet, patternInput_1[0].Range), new Command("Let", [whiteBefore(whiteAfterLet, node$1(letEndRng, new Name(""))), patternInput_1[0]])))];
      }

  }
}
function parseCommands(acc, ctx) {
  parseCommands: while (true) {
    var c = token(ctx);

    if (c[1].Token.Case === "Let") {
      var rngLet = c[1].Range;
      next(ctx);

      var _patternInput2 = void 0;

      var _indent = usingIndent(false, c[1], ctx);

      try {
        _patternInput2 = parseLetBinding(c[0], rngLet, ctx);
      } finally {
        if (hasInterface(_indent, "System.IDisposable")) {
          _indent.Dispose();
        }
      }

      var rest = map$4(function (e) {
        return node$1(e.Range, new Command("Expr", [e]));
      }, _patternInput2[0]);
      acc = append$$1(rest, new List$2(_patternInput2[1], acc));
      ctx = ctx;
      continue parseCommands;
    } else if (c[1].Token.Case === "EndOfFile") {
      if (acc.tail == null) {
        return new List$2();
      } else {
        return reverse$$1(new List$2(new _Node(acc.head.WhiteBefore, c[0], acc.head.Range, acc.head.Node, acc.head.Entity), acc.tail));
      }
    } else {
      var cmds = void 0;

      var _indent_1 = usingIndent(true, c[1], ctx);

      try {
        cmds = map$4(function (expr) {
          return node$1(expr.Range, new Command("Expr", [expr]));
        }, parseNestedExpressions(reverse$$1(c[0]), new List$2(), ctx));
      } finally {
        if (hasInterface(_indent_1, "System.IDisposable")) {
          _indent_1.Dispose();
        }
      }

      acc = append$$1(cmds, acc);
      ctx = ctx;
      continue parseCommands;
    }
  }
}
function parseProgram(input) {
  try {
    var _patternInput3 = tokenize(input);

    var ctx = void 0;
    var TopLevel = true;
    var Silent = false;
    var StrictlyNested = false;
    var Position = 0;
    var IndentCurrent = 0;
    var IndentStack = new List$2();
    var Errors = [];
    ctx = new Context$$1(_patternInput3[0], [], Errors, TopLevel, Silent, StrictlyNested, IndentCurrent, IndentStack, Position);
    var cmds = parseCommands(new List$2(), ctx);

    var errors = _patternInput3[1].concat(_Array$from(ctx.Errors));

    var rng_1 = fold$1(function (rng, cmd) {
      return unionRanges(rng, cmd.Range);
    }, new _Range(0, 0), cmds);
    return [new Program$$1(node$1(rng_1, cmds)), errors];
  } catch (e) {
    Log.exn("parsing", "Exception while parsing program: %O", e);
    var rng_2 = new _Range(0, 0);
    var error = Parser.exceptionWhileParsing(rng_2, toString$2(e));
    return [new Program$$1(node$1(rng_2, new List$2())), [error]];
  }
}

var CheckingContext = function () {
  function CheckingContext(errors, globals, ranges) {
    _classCallCheck(this, CheckingContext);

    this.Errors = errors;
    this.Globals = globals;
    this.Ranges = ranges;
  }

  _createClass(CheckingContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeChecker.CheckingContext",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Errors: FableArray(makeGeneric(_Error, {
            Range: _Range
          })),
          Globals: Interface("System.Collections.Generic.IDictionary"),
          Ranges: Interface("System.Collections.Generic.IDictionary")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return CheckingContext;
}();
setType("TheGamma.TypeChecker.CheckingContext", CheckingContext);
function addError$1(ctx, ent, err) {
  ctx.Errors.push(err(ctx.Ranges.get(ent.Symbol)));
}

function _FindProperty___$1(name, _arg1) {
  return tryPick(function (_arg2) {
    var $var127 = _arg2.Case === "Property" ? _arg2.Fields[0] === name.Name ? [0, _arg2.Fields[2], _arg2.Fields[0], _arg2.Fields[1]] : [1] : [1];

    switch ($var127[0]) {
      case 0:
        return [$var127[1], $var127[3]];

      case 1:
        return null;
    }
  }, _arg1.Members);
}

function _FindMethod___$1(name, _arg1) {
  return tryPick(function (_arg2) {
    var $var128 = _arg2.Case === "Method" ? _arg2.Fields[0] === name.Name ? [0, _arg2.Fields[1], _arg2.Fields[3], _arg2.Fields[0], _arg2.Fields[2]] : [1] : [1];

    switch ($var128[0]) {
      case 0:
        return [$var128[2], $var128[1], $var128[4]];

      case 1:
        return null;
    }
  }, _arg1.Members);
}

function inferListType(typs) {
  return reduce(function (f) {
    return function (x, y) {
      return f(x) > f(y) ? x : y;
    };
  }(function (tuple) {
    return tuple[1];
  }), append$$1(ofArray([[new Type("Any", []), 0]]), map$4(function (g) {
    return [g.head, g.length];
  }, function (list) {
    return List.groupWith(typesEqual, list);
  }(filter$1(function (_arg1) {
    return _arg1.Case === "Any" ? false : true;
  }, typs)))))[0];
}
function resolveParameterType(instTy, methName, parSpec) {
  var $var129 = void 0;

  if (instTy.Case === "Object") {
    var activePatternResult6033 = _FindMethod___$1(methName, instTy.Fields[0]);

    if (activePatternResult6033 != null) {
      $var129 = [0, activePatternResult6033[1]];
    } else {
      $var129 = [1];
    }
  } else {
    $var129 = [1];
  }

  switch ($var129[0]) {
    case 0:
      if (parSpec.Case === "Choice2Of2") {
        var patternInput = item(parSpec.Fields[0], $var129[1]);
        return patternInput[2];
      } else {
        return pick(function (tupledArg) {
          return tupledArg[0] === parSpec.Fields[0] ? tupledArg[2] : null;
        }, $var129[1]);
      }

    case 1:
      throw new Error("resolveParameterType: Instance is not an object");
  }
}
function checkMethodCall(ctx, memTy, pars, argList, args) {
  var patternInput = void 0;
  var pb = toList(takeWhile(function (_arg1) {
    return _arg1.Kind.Case === "NamedParam" ? false : true;
  }, args));
  var nb = toList(skipWhile(function (_arg2) {
    return _arg2.Kind.Case === "NamedParam" ? false : true;
  }, args));
  patternInput = [_Array$from(pb), create$3(choose$$1(function (arg) {
    if (arg.Kind.Case === "NamedParam") {
      return [arg.Kind.Fields[0].Name, arg.Kind.Fields[1]];
    } else {
      (function (err) {
        addError$1(ctx, arg, err);
      })(function (rng) {
        return TypeChecker.nameBasedParamMustBeLast(rng);
      });

      return null;
    }
  }, nb), new GenericComparer(compare))];
  var matchedArguments = mapIndexed$$1(function (index, tupledArg) {
    var arg_1 = index < patternInput[0].length ? patternInput[0][index] : tryFind$1(tupledArg[0], patternInput[1]);

    if (arg_1 == null) {
      if (tupledArg[1]) {
        return [tupledArg[0], tupledArg[2], tupledArg[2], null];
      } else if (arg_1 == null) {
        (function (err_1) {
          addError$1(ctx, argList, err_1);
        })(function (rng_1) {
          return TypeChecker.parameterMissingValue(tupledArg[0], rng_1);
        });

        return [tupledArg[0], tupledArg[2], new Type("Any", []), null];
      } else {
        throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\analyzer/typechecker.fs", 72, 12);
      }
    } else {
      return [tupledArg[0], tupledArg[2], getType$1(ctx, arg_1), arg_1];
    }
  }, pars);
  var patternInput_1 = memTy.Case === "Forall" ? [memTy.Fields[0], memTy.Fields[1]] : [new List$2(), memTy];
  var assigns = collect$$1(function (tupledArg_1) {
    var patternInput_2 = unifyTypes(patternInput_1[0], tupledArg_1[1], tupledArg_1[2]);

    if (function () {
      return tupledArg_1[3] != null;
    }(null)) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var forLoopVar = _step.value;
          (function () {
            var ent = tupledArg_1[3];
            return function (err_2) {
              addError$1(ctx, ent, err_2);
            };
          })()(function (rng_2) {
            return TypeChecker.incorrectParameterType(tupledArg_1[0], tupledArg_1[1], tupledArg_1[2], forLoopVar[0], forLoopVar[1], rng_2);
          });
        };

        for (var _iterator = _getIterator(patternInput_2[1]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    return patternInput_2[0];
  }, matchedArguments);
  var inputSequence = groupBy$1(function (tuple) {
    return tuple[0];
  }, assigns);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop2 = function _loop2() {
      var forLoopVar_1 = _step2.value;
      var matchValue = toList(forLoopVar_1[1]);
      var $var130 = matchValue.tail != null ? matchValue.tail.tail != null ? [0, matchValue.head[1], matchValue.tail, matchValue.head[0]] : [1] : [1];

      switch ($var130[0]) {
        case 0:
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            var _loop3 = function _loop3() {
              var forLoopVar_2 = _step3.value;

              (function (err_3) {
                addError$1(ctx, argList, err_3);
              })(function (rng_3) {
                return TypeChecker.inferenceConflict($var130[3], $var130[1], forLoopVar_2[1], rng_3);
              });
            };

            for (var _iterator3 = _getIterator($var130[2]), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              _loop3();
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          break;

        case 1:
          break;
      }
    };

    for (var _iterator2 = _getIterator(inputSequence), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      _loop2();
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var res = substituteTypes(create$3(assigns, new GenericComparer(compare)), patternInput_1[1]);
  return res;
}
function getType$1(ctx, e) {
  if (function () {
    return e.Type == null;
  }(null)) {
    (function () {
      var errorCount = ctx.Errors.length;
      e.Type = typeCheckEntity(ctx, e);
      e.Errors = toList(delay(function () {
        return map$5(function (i) {
          return ctx.Errors[i];
        }, range(errorCount, ctx.Errors.length - 1));
      }));
    })();
  }

  return e.Type;
}
function typeCheckEntity(ctx, e) {
  var $var131 = e.Kind.Case === "Variable" ? [1, e.Kind.Fields[1]] : e.Kind.Case === "ChainElement" ? e.Kind.Fields[0] ? e.Kind.Fields[3] == null ? [4, e.Kind.Fields[2], e.Kind.Fields[1]] : [2, e.Kind.Fields[2], e.Kind.Fields[3], e.Kind.Fields[1]] : e.Kind.Fields[3] == null ? [4, e.Kind.Fields[2], e.Kind.Fields[1]] : e.Kind.Fields[4] != null ? e.Kind.Fields[4].Kind.Case === "ArgumentList" ? [3, e.Kind.Fields[4], e.Kind.Fields[4].Kind.Fields[0], e.Kind.Fields[2], e.Kind.Fields[3], e.Kind.Fields[1]] : [5, e.Kind.Fields[1]] : [5, e.Kind.Fields[1]] : e.Kind.Case === "Operator" ? [6, e.Kind.Fields[0], e.Kind.Fields[1], e.Kind.Fields[2]] : e.Kind.Case === "List" ? [7, e.Kind.Fields[0]] : e.Kind.Case === "Binding" ? e.Kind.Fields[1].Kind.Case === "CallSite" ? [8, e.Kind.Fields[1].Kind.Fields[0], e.Kind.Fields[1].Kind.Fields[1], e.Kind.Fields[0], e.Kind.Fields[1].Kind.Fields[2]] : [9, e.Kind.Fields[0]] : e.Kind.Case === "Function" ? [10, e.Kind.Fields[1], e.Kind.Fields[0]] : e.Kind.Case === "Constant" ? e.Kind.Fields[0].Case === "String" ? [12] : e.Kind.Fields[0].Case === "Boolean" ? [13] : e.Kind.Fields[0].Case === "Empty" ? [14] : [11] : e.Kind.Case === "Root" ? [15] : e.Kind.Case === "LetCommand" ? [16] : e.Kind.Case === "RunCommand" ? [17] : e.Kind.Case === "ArgumentList" ? [18] : e.Kind.Case === "NamedParam" ? [19] : e.Kind.Case === "NamedMember" ? [20] : e.Kind.Case === "CallSite" ? [21] : e.Kind.Case === "Program" ? [22] : [0, e.Kind.Fields[0]];

  var _ret5 = function () {
    switch ($var131[0]) {
      case 0:
        if (!ctx.Globals.has($var131[1].Name)) {
          (function (err) {
            addError$1(ctx, e, err);
          })(function (rng) {
            return TypeChecker.variableNotInScope($var131[1].Name, rng);
          });

          return {
            v: new Type("Any", [])
          };
        } else {
          return {
            v: getType$1(ctx, ctx.Globals.get($var131[1].Name))
          };
        }

      case 1:
        return {
          v: getType$1(ctx, $var131[1])
        };

      case 2:
        var matchValue = reduceType(getType$1(ctx, $var131[2]));
        var $var132 = void 0;

        if (matchValue.Case === "Any") {
          $var132 = [0];
        } else if (matchValue.Case === "Object") {
          var activePatternResult6065 = _FindProperty___$1($var131[3], matchValue.Fields[0]);

          if (activePatternResult6065 != null) {
            $var132 = [1, activePatternResult6065[0], activePatternResult6065[1]];
          } else {
            $var132 = [2];
          }
        } else {
          $var132 = [2];
        }

        switch ($var132[0]) {
          case 0:
            return {
              v: new Type("Any", [])
            };

          case 1:
            e.Meta = $var132[1];
            return {
              v: $var132[2]
            };

          case 2:
            if (matchValue.Case === "Object") {
              var _ret6 = function () {
                var members = matchValue.Fields[0].Members;

                (function (err_1) {
                  addError$1(ctx, $var131[1], err_1);
                })(function (rng_1) {
                  return TypeChecker.propertyMissing($var131[3].Name, members, rng_1);
                });

                return {
                  v: {
                    v: new Type("Any", [])
                  }
                };
              }();

              if ((typeof _ret6 === "undefined" ? "undefined" : _typeof(_ret6)) === "object") return _ret6.v;
            } else {
              (function (err_2) {
                addError$1(ctx, $var131[2], err_2);
              })(function (rng_2) {
                return TypeChecker.notAnObject($var131[3].Name, matchValue, rng_2);
              });

              return {
                v: new Type("Any", [])
              };
            }

        }

      case 3:
        var matchValue_1 = reduceType(getType$1(ctx, $var131[4]));
        var $var133 = void 0;

        if (matchValue_1.Case === "Any") {
          $var133 = [0];
        } else if (matchValue_1.Case === "Object") {
          var activePatternResult6067 = _FindMethod___$1($var131[5], matchValue_1.Fields[0]);

          if (activePatternResult6067 != null) {
            $var133 = [1, activePatternResult6067[1], activePatternResult6067[0], activePatternResult6067[2]];
          } else {
            $var133 = [2];
          }
        } else {
          $var133 = [2];
        }

        switch ($var133[0]) {
          case 0:
            return {
              v: new Type("Any", [])
            };

          case 1:
            e.Meta = $var133[2];
            return {
              v: checkMethodCall(ctx, $var133[3], $var133[1], $var131[1], $var131[2])
            };

          case 2:
            if (matchValue_1.Case === "Object") {
              var _ret7 = function () {
                var members_1 = matchValue_1.Fields[0].Members;

                (function (err_3) {
                  addError$1(ctx, $var131[3], err_3);
                })(function (rng_3) {
                  return TypeChecker.methodMissing($var131[5].Name, members_1, rng_3);
                });

                return {
                  v: {
                    v: new Type("Any", [])
                  }
                };
              }();

              if ((typeof _ret7 === "undefined" ? "undefined" : _typeof(_ret7)) === "object") return _ret7.v;
            } else {
              (function (err_4) {
                addError$1(ctx, $var131[4], err_4);
              })(function (rng_4) {
                return TypeChecker.notAnObject($var131[5].Name, matchValue_1, rng_4);
              });

              return {
                v: new Type("Any", [])
              };
            }

        }

      case 4:
        (function (err_5) {
          addError$1(ctx, $var131[1], err_5);
        })(function (rng_5) {
          return TypeChecker.callMissingInstance($var131[2].Name, rng_5);
        });

        return {
          v: new Type("Any", [])
        };

      case 5:
        throw new Error(fsFormat("typeCheckEntity: Call to %s is missing argument list!")(function (x) {
          return x;
        })($var131[1].Name));

      case 6:
        iterateIndexed(function (idx, operand) {
          var typ = getType$1(ctx, operand);

          if (!typesEqual(typ)(new Type("Primitive", [new PrimitiveType("Number", [])]))) {
            (function (err_6) {
              addError$1(ctx, operand, err_6);
            })(function (rng_6) {
              return TypeChecker.numericOperatorExpectsNumbers($var131[2], idx, typ, rng_6);
            });
          }
        }, ofArray([$var131[1], $var131[3]]));
        return {
          v: new Type("Primitive", [new PrimitiveType("Number", [])])
        };

      case 7:
        var typs = map$4(function (e_1) {
          return getType$1(ctx, e_1);
        }, $var131[1]);
        var typ_1 = inferListType(typs);
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          var _loop4 = function _loop4() {
            var a = _step4.value;
            var elty = getType$1(ctx, a);

            if (!typesEqual(typ_1)(elty)) {
              (function (err_7) {
                addError$1(ctx, a, err_7);
              })(function (rng_7) {
                return TypeChecker.listElementTypeDoesNotMatch(typ_1, elty, rng_7);
              });
            }
          };

          for (var _iterator4 = _getIterator($var131[1]), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            _loop4();
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        return {
          v: new Type("App", [new Type("Forall", [ofArray(["a"]), new Type("List", [new Type("Parameter", ["a"])])]), ofArray([typ_1])])
        };

      case 8:
        var matchValue_2 = resolveParameterType(reduceType(getType$1(ctx, $var131[1])), $var131[2], $var131[4]);
        var $var134 = matchValue_2.Case === "Function" ? matchValue_2.Fields[0].tail != null ? matchValue_2.Fields[0].tail.tail == null ? [0, matchValue_2.Fields[0].head] : [1] : [1] : [1];

        switch ($var134[0]) {
          case 0:
            return {
              v: $var134[1]
            };

          case 1:
            throw new Error("typeCheckEntity: Expected parameter of function type");
        }

      case 9:
        throw new Error(fsFormat("typeCheckEntity: Variable binding %s is missing call site!")(function (x) {
          return x;
        })($var131[1].Name));

      case 10:
        return {
          v: new Type("Function", [ofArray([getType$1(ctx, $var131[2])]), getType$1(ctx, $var131[1])])
        };

      case 11:
        return {
          v: new Type("Primitive", [new PrimitiveType("Number", [])])
        };

      case 12:
        return {
          v: new Type("Primitive", [new PrimitiveType("String", [])])
        };

      case 13:
        return {
          v: new Type("Primitive", [new PrimitiveType("Bool", [])])
        };

      case 14:
        return {
          v: new Type("Any", [])
        };

      case 15:
        return {
          v: new Type("Any", [])
        };

      case 16:
        return {
          v: new Type("Any", [])
        };

      case 17:
        return {
          v: new Type("Any", [])
        };

      case 18:
        return {
          v: new Type("Any", [])
        };

      case 19:
        return {
          v: new Type("Any", [])
        };

      case 20:
        return {
          v: new Type("Any", [])
        };

      case 21:
        return {
          v: new Type("Any", [])
        };

      case 22:
        return {
          v: new Type("Any", [])
        };
    }
  }();

  if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
}
function evaluateDelayedType(topLevel, t) {
  return function (builder_) {
    return builder_.Delay(function () {
      var $var135 = t.Case === "App" ? [0, t.Fields[1], t.Fields[0]] : t.Case === "Forall" ? [1, t.Fields[1], t.Fields[0]] : t.Case === "Object" ? topLevel ? [2, t.Fields[0]] : [3] : [3];

      switch ($var135[0]) {
        case 0:
          return builder_.Bind(evaluateDelayedType(topLevel, $var135[2]), function (_arg1) {
            return builder_.Return(new Type("App", [_arg1, $var135[1]]));
          });

        case 1:
          return builder_.Bind(evaluateDelayedType(topLevel, $var135[1]), function (_arg2) {
            return builder_.Return(new Type("Forall", [$var135[2], _arg2]));
          });

        case 2:
          return builder_.Bind(Async.Array.map(function (m) {
            return function (builder__1) {
              return builder__1.Delay(function () {
                return m.Case === "Method" ? builder__1.Bind(Async.map(function (tupledArg) {
                  return function (builder__2) {
                    return builder__2.Delay(function () {
                      return builder__2.Bind(evaluateDelayedType(false, tupledArg[2]), function (_arg3) {
                        return builder__2.Return([tupledArg[0], tupledArg[1], _arg3]);
                      });
                    });
                  }(singleton$2);
                }, m.Fields[1]), function (_arg4) {
                  return builder__1.Return(new Member("Method", [m.Fields[0], _arg4, m.Fields[2], m.Fields[3], m.Fields[4]]));
                }) : builder__1.Return(m);
              });
            }(singleton$2);
          }, $var135[1].Members), function (_arg5) {
            return builder_.Return(new Type("Object", [new ObjectType(_arg5)]));
          });

        case 3:
          if (t.Case === "Function") {
            return builder_.Bind(evaluateDelayedType(topLevel, t.Fields[1]), function (_arg6) {
              return builder_.Bind(Async.map(function (t_1) {
                return evaluateDelayedType(topLevel, t_1);
              }, t.Fields[0]), function (_arg7) {
                return builder_.Return(new Type("Function", [_arg7, _arg6]));
              });
            });
          } else if (t.Case === "List") {
            return builder_.Bind(evaluateDelayedType(topLevel, t.Fields[0]), function (_arg8) {
              return builder_.Return(new Type("List", [_arg8]));
            });
          } else if (t.Case === "Delayed") {
            return builder_.Bind(Async_AwaitFuture_Static(t.Fields[1]), function (_arg9) {
              return builder_.ReturnFrom(evaluateDelayedType(topLevel, _arg9));
            });
          } else {
            return builder_.Return(t);
          }

      }
    });
  }(singleton$2);
}
function typeCheckEntityAsync(ctx, e) {
  return function (builder_) {
    return builder_.Delay(function () {
      var visited = new _Map();

      var loop = function loop(e_1) {
        return function (builder__1) {
          return builder__1.Delay(function () {
            var isGlobal = e_1.Kind.Case === "GlobalValue" ? true : false;

            if (!visited.has(e_1.Symbol) ? isGlobal ? true : function () {
              return e_1.Type == null;
            }(null) : false) {
              visited.set(e_1.Symbol, true);
              return builder__1.Combine(builder__1.For(Entity_get_Antecedents.bind(e_1)(), function (_arg1) {
                return builder__1.Bind(loop(_arg1), function () {
                  return builder__1.Return(null);
                });
              }), builder__1.Delay(function () {
                Log.trace("typechecker", "Type of entity '%s' (%O) is: %O", Entity_get_Name.bind(e_1)(), e_1.Kind, getType$1(ctx, e_1));
                return builder__1.Bind(evaluateDelayedType(true, getType$1(ctx, e_1)), function (_arg3) {
                  Log.trace("typechecker", "Type of entity '%s' (%O) reduced to: %O", Entity_get_Name.bind(e_1)(), e_1.Kind, _arg3);
                  e_1.Type = _arg3;
                  return builder__1.Zero();
                });
              }));
            } else {
              return builder__1.Zero();
            }
          });
        }(singleton$2);
      };

      return builder_.Bind(loop(e), function () {
        return builder_.Return(getType$1(ctx, e));
      });
    });
  }(singleton$2);
}
function collectTypeErrors(entity) {
  var errors = [];
  var visited = new _Map();

  var loop = function loop(e) {
    if (!visited.has(e.Symbol)) {
      visited.set(e.Symbol, true);
      var inputSequence = Entity_get_Antecedents.bind(e)();
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = _getIterator(inputSequence), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var e_1 = _step5.value;
          loop(e_1);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      addRangeInPlace(e.Errors, errors);
    }
  };

  loop(entity);
  return _Array$from(errors);
}
function typeCheckProgram(globals, bound, prog) {
  return function (builder_) {
    return builder_.Delay(function () {
      Log.trace("typechecker", "Type checking program");
      return builder_.TryWith(builder_.Delay(function () {
        var rangeLookup = new _Map(toList(delay(function () {
          return collect$1(function (matchValue) {
            return singleton$1([matchValue[1].Symbol, matchValue[0]]);
          }, bound.Entities);
        })));
        var vars = new _Map(toList(delay(function () {
          return map$5(function (e) {
            return [Entity_get_Name.bind(e)(), e];
          }, globals);
        })));
        var ctx = new CheckingContext([], vars, rangeLookup);
        return builder_.Bind(typeCheckEntityAsync(ctx, prog), function (_arg1) {
          Log.trace("typechecker", "Completed type checking");
          return builder_.Zero();
        });
      }), function (_arg2) {
        Log.exn("typechecker", "Type checking program failed: %O", _arg2);
        return builder_.Zero();
      });
    });
  }(singleton$2);
}

var LineColumnRange = function () {
  function LineColumnRange(startLineNumber, startColumn, endLineNumber, endColumn) {
    _classCallCheck(this, LineColumnRange);

    this.StartLineNumber = startLineNumber;
    this.StartColumn = startColumn;
    this.EndLineNumber = endLineNumber;
    this.EndColumn = endColumn;
  }

  _createClass(LineColumnRange, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.LineColumnRange",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          StartLineNumber: "number",
          StartColumn: "number",
          EndLineNumber: "number",
          EndColumn: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return LineColumnRange;
}();
setType("TheGamma.LineColumnRange", LineColumnRange);
var LocationMapper = function () {
  _createClass(LocationMapper, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.LocationMapper",
        properties: {}
      };
    }
  }]);

  function LocationMapper(code) {
    _classCallCheck(this, LocationMapper);

    this.lengths = Int32Array.from(map$5(function (s) {
      return s.length;
    }, split$$1(code, "\n")));
  }

  _createClass(LocationMapper, [{
    key: "AbsoluteToLineCol",
    value: function (offs) {
      var line = 0;
      var col = 0;
      var offs_1 = offs;

      while (line <= this.lengths.length ? offs_1 > this.lengths[line] : false) {
        offs_1 = offs_1 - this.lengths[line] - 1;
        line = line + 1;
      }

      return [line + 1, offs_1 + 1];
    }
  }, {
    key: "LineColToAbsolute",
    value: function (line, col) {
      var offs = 0;

      for (var l = 1; l <= line - 1; l++) {
        offs = offs + this.lengths[l - 1] + 1;
      }

      return offs + col - 1;
    }
  }]);

  return LocationMapper;
}();
setType("TheGamma.LocationMapper", LocationMapper);

var LiveEditorZone = function () {
  function LiveEditorZone(line, preview) {
    _classCallCheck(this, LiveEditorZone);

    this.Line = line;
    this.Preview = preview;
  }

  _createClass(LiveEditorZone, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LiveEditorZone",
        interfaces: ["FSharpRecord"],
        properties: {
          Line: "number",
          Preview: DomNode
        }
      };
    }
  }]);

  return LiveEditorZone;
}();
setType("TheGamma.Live.Common.LiveEditorZone", LiveEditorZone);
var LivePreview = function () {
  function LivePreview(update, render$$1, initialState) {
    _classCallCheck(this, LivePreview);

    this.Update = update;
    this.Render = render$$1;
    this.InitialState = initialState;
  }

  _createClass(LivePreview, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LivePreview",
        interfaces: ["FSharpRecord"],
        properties: {
          Update: "function",
          Render: "function",
          InitialState: GenericParam("TState")
        }
      };
    }
  }]);

  return LivePreview;
}();
setType("TheGamma.Live.Common.LivePreview", LivePreview);
var LiveState = function () {
  function LiveState(globals, code, program, mapper, location, selection, state, currentPreview) {
    _classCallCheck(this, LiveState);

    this.Globals = globals;
    this.Code = code;
    this.Program = program;
    this.Mapper = mapper;
    this.Location = location;
    this.Selection = selection;
    this.State = state;
    this.CurrentPreview = currentPreview;
  }

  _createClass(LiveState, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LiveState",
        interfaces: ["FSharpRecord"],
        properties: {
          Globals: Interface("System.Collections.Generic.IEnumerable"),
          Code: "string",
          Program: Program$$1,
          Mapper: LocationMapper,
          Location: "number",
          Selection: Option(LineColumnRange),
          State: GenericParam("T"),
          CurrentPreview: Option(makeGeneric(LivePreview, {
            TState: Interface("TheGamma.Live.Common.CustomLiveState"),
            TEvent: Interface("TheGamma.Live.Common.CustomLiveEvent")
          }))
        }
      };
    }
  }]);

  return LiveState;
}();
setType("TheGamma.Live.Common.LiveState", LiveState);
var LiveEvent = function () {
  function LiveEvent(caseName, fields) {
    _classCallCheck(this, LiveEvent);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(LiveEvent, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LiveEvent",
        interfaces: ["FSharpUnion"],
        cases: {
          CustomEvent: [GenericParam("T")],
          InitializeGlobals: [Interface("System.Collections.Generic.IEnumerable")],
          UpdateLocation: ["number"],
          UpdateSource: ["string", "number", Program$$1, LocationMapper]
        }
      };
    }
  }]);

  return LiveEvent;
}();
setType("TheGamma.Live.Common.LiveEvent", LiveEvent);
function updateLiveState(state, event) {
  if (event.Case === "UpdateLocation") {
    return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, event.Fields[0], state.Selection, state.State, state.CurrentPreview);
  } else if (event.Case === "UpdateSource") {
    return new LiveState(state.Globals, event.Fields[0], event.Fields[2], event.Fields[3], event.Fields[1], state.Selection, state.State, state.CurrentPreview);
  } else if (event.Case === "CustomEvent") {
    return state;
  } else {
    return new LiveState(event.Fields[0], state.Code, state.Program, state.Mapper, state.Location, state.Selection, state.State, state.CurrentPreview);
  }
}

var EditorWorkerMessage = function () {
  function EditorWorkerMessage(caseName, fields) {
    _classCallCheck(this, EditorWorkerMessage);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(EditorWorkerMessage, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.EditorWorkerMessage",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Refersh: ["string"],
          Update: ["string"],
          UpdateNow: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return EditorWorkerMessage;
}();
setType("TheGamma.Services.EditorWorkerMessage", EditorWorkerMessage);
var EditorService = function () {
  _createClass(EditorService, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.EditorService",
        properties: {
          EditorsUpdated: Interface("Microsoft.FSharp.Control.IEvent")
        }
      };
    }
  }]);

  function EditorService(article, checker, delay$$1) {
    var _this = this;

    _classCallCheck(this, EditorService);

    this.article = article;
    this.checker = checker;
    this.renderEditors = new Event$2();
    this.agent = start$1(function (inbox) {
      var loop = function loop(lastText) {
        return function (pending) {
          return function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(inbox.receive(), function (_arg3) {
                if (_arg3.Case === "UpdateNow") {
                  return builder_.Combine(builder_.TryWith(builder_.Delay(function () {
                    Log.trace("editors", "updating...");

                    if (_arg3.Fields[0] !== lastText) {
                      return builder_.Bind(_this.update(_arg3.Fields[0]), function () {
                        return builder_.Return(null);
                      });
                    } else {
                      return builder_.Zero();
                    }
                  }), function (_arg6) {
                    Log.exn("editors", "update failed: %O", _arg6);
                    return builder_.Zero();
                  }), builder_.Delay(function () {
                    return builder_.ReturnFrom(loop(_arg3.Fields[0])(pending));
                  }));
                } else if (_arg3.Case === "Refersh") {
                  return builder_.Combine(pending === 1 ? builder_.TryWith(builder_.Delay(function () {
                    Log.trace("editors", "updating...");

                    if (_arg3.Fields[0] !== lastText) {
                      return builder_.Bind(_this.update(_arg3.Fields[0]), function () {
                        return builder_.Return(null);
                      });
                    } else {
                      return builder_.Zero();
                    }
                  }), function (_arg8) {
                    Log.exn("editors", "update failed: %O", _arg8);
                    return builder_.Zero();
                  }) : builder_.Zero(), builder_.Delay(function () {
                    return builder_.ReturnFrom(loop(_arg3.Fields[0])(pending - 1));
                  }));
                } else {
                  (function (arg00) {
                    startImmediate(arg00);
                  })(function (builder__1) {
                    return builder__1.Delay(function () {
                      return builder__1.Bind(sleep(delay$$1), function () {
                        inbox.post(new EditorWorkerMessage("Refersh", [_arg3.Fields[0]]));
                        return builder__1.Zero();
                      });
                    });
                  }(singleton$2));

                  return builder_.ReturnFrom(loop(lastText)(pending + 1));
                }
              });
            });
          }(singleton$2);
        };
      };

      return loop("")(0);
    });
  }

  _createClass(EditorService, [{
    key: "UpdateSource",
    value: function (text$$1, immediately) {
      if (equals(immediately, true)) {
        this.agent.post(new EditorWorkerMessage("UpdateNow", [text$$1]));
      } else {
        this.agent.post(new EditorWorkerMessage("Update", [text$$1]));
      }
    }
  }, {
    key: "update",
    value: function (text$$1) {
      var _this2 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          Log.event("options", "update", _this2.article, text$$1);
          return builder_.Bind(_this2.checker(text$$1), function (_arg1) {
            Log.trace("service", "Collecting editors");
            return builder_.Bind(Async.collect(function (cmd) {
              return collectCmdEditors(cmd);
            }, _arg1[2].Body.Node), function (_arg2) {
              var eds = mapIndexed$$1(function (i, v) {
                return [i, v];
              }, _arg2);
              var filteredEds = map$4(function (tuple) {
                return tuple[1];
              }, filter$1(function (tupledArg) {
                return !exists$1(function (tupledArg_1) {
                  return tupledArg_1[0] !== tupledArg[0] ? strictSubRange(tupledArg[1].Range, tupledArg_1[1].Range) : false;
                }, eds);
              }, eds));
              Log.trace("service", "Rendering %s out of %s", filteredEds.length, eds.length);

              _this2.renderEditors.Trigger(filteredEds);

              return builder_.Zero();
            });
          });
        });
      }(singleton$2);
    }
  }, {
    key: "EditorsUpdated",
    get: function () {
      return this.renderEditors.Publish;
    }
  }]);

  return EditorService;
}();
setType("TheGamma.Services.EditorService", EditorService);
var CheckingMessage = function () {
  function CheckingMessage(caseName, fields) {
    _classCallCheck(this, CheckingMessage);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(CheckingMessage, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.CheckingMessage",
        interfaces: ["FSharpUnion", "System.IEquatable"],
        cases: {
          IsWellTyped: ["string", Any],
          TypeCheck: ["string", Any]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }]);

  return CheckingMessage;
}();
setType("TheGamma.Services.CheckingMessage", CheckingMessage);
var Position$1 = function () {
  function Position(line, column) {
    _classCallCheck(this, Position);

    this.Line = line;
    this.Column = column;
  }

  _createClass(Position, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.Position",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Line: "number",
          Column: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Position;
}();
setType("TheGamma.Services.Position", Position$1);
var LineRange = function () {
  function LineRange(start$$1, end) {
    _classCallCheck(this, LineRange);

    this.Start = start$$1;
    this.End = end;
  }

  _createClass(LineRange, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.LineRange",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Start: Position$1,
          End: Position$1
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return LineRange;
}();
setType("TheGamma.Services.LineRange", LineRange);
function offsetToLocation(lines, offs, lengths) {
  offsetToLocation: while (true) {
    var $var208 = lengths.tail != null ? offs <= lengths.head ? [0, lengths.head, lengths.tail] : [1] : [1];

    switch ($var208[0]) {
      case 0:
        return new Position$1(lines, offs);

      case 1:
        if (lengths.tail == null) {
          return new Position$1(lines, offs);
        } else {
          lines = lines + 1;
          offs = offs - lengths.head - 1;
          lengths = lengths.tail;
          continue offsetToLocation;
        }

    }
  }
}
function rangeToLoc(lengths, rng) {
  return new LineRange(offsetToLocation(1, rng.Start, lengths), offsetToLocation(1, rng.Start, lengths));
}
var CheckingService = function () {
  _createClass(CheckingService, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.CheckingService",
        properties: {
          ErrorsReported: Interface("Microsoft.FSharp.Control.IEvent")
        }
      };
    }
  }]);

  function CheckingService(article, globals) {
    var _this3 = this;

    _classCallCheck(this, CheckingService);

    this.globals = globals;
    this.errorsReported = new Event$2();
    var emptyProg = new Program$$1(node(new _Range(0, 0), new List$2()));
    this.bindingContext = Async_StartAsFuture_Static(function (builder_) {
      return builder_.Delay(function () {
        return builder_.Bind(Async_AwaitFuture_Static(_this3.globals), function (_arg1) {
          return builder_.Return(createContext(_arg1, article));
        });
      });
    }(singleton$2));
    this.agent = start$1(function (inbox) {
      var loop = function loop(lastCode) {
        return function (lastResult) {
          return function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Bind(inbox.receive(), function (_arg6) {
                if (_arg6.Case === "TypeCheck") {
                  if (_arg6.Fields[0] === lastCode) {
                    Log.trace("service", "Returning previous result");

                    _arg6.Fields[1].reply(lastResult);

                    return builder__1.ReturnFrom(loop(lastCode)(lastResult));
                  } else if (_arg6.Case === "TypeCheck") {
                    Log.trace("service", "Type checking source code");
                    return builder__1.Bind(_this3.typeCheck(_arg6.Fields[0]), function (_arg8) {
                      if (_arg8 == null) {
                        _arg6.Fields[1].reply([false, new BindingResult([]), emptyProg]);

                        return builder__1.ReturnFrom(loop(lastCode)(lastResult));
                      } else {
                        var prog = _arg8[0];
                        var errors = _arg8[2];
                        var ents = _arg8[1];

                        _this3.errorsReported.Trigger([_arg6.Fields[0], errors]);

                        var result = [errors.length === 0, ents, prog];

                        _arg6.Fields[1].reply(result);

                        return builder__1.ReturnFrom(loop(_arg6.Fields[0])(result));
                      }
                    });
                  } else {
                    throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\services.fs", 120, 12);
                  }
                } else {
                  return builder__1.Bind(_this3.typeCheck(_arg6.Fields[0]), function (_arg7) {
                    return builder__1.Combine(function () {
                      var $var209 = _arg7 != null ? function () {
                        var errs = _arg7[2];
                        return errs.length === 0;
                      }() ? [0, _arg7[2]] : [1] : [1];

                      switch ($var209[0]) {
                        case 0:
                          _arg6.Fields[1].reply(true);

                          return builder__1.Zero();

                        case 1:
                          _arg6.Fields[1].reply(false);

                          return builder__1.Zero();
                      }
                    }(), builder__1.Delay(function () {
                      return builder__1.ReturnFrom(loop(lastCode)(lastResult));
                    }));
                  });
                }
              });
            });
          }(singleton$2);
        };
      };

      return loop("")([false, new BindingResult([]), emptyProg]);
    });
  }

  _createClass(CheckingService, [{
    key: "TypeCheck",
    value: function (code) {
      return this.agent.postAndAsyncReply(function (ch) {
        return new CheckingMessage("TypeCheck", [code, ch]);
      });
    }
  }, {
    key: "IsWellTyped",
    value: function (code) {
      return this.agent.postAndAsyncReply(function (ch) {
        return new CheckingMessage("IsWellTyped", [code, ch]);
      });
    }
  }, {
    key: "errorsToLineCol",
    value: function (code, errors) {
      var lengths = map$4(function (l) {
        return l.length;
      }, toList(split$$1(code, "\n")));
      return errors.map(function (e) {
        return new _Error(e.Number, e.Message, rangeToLoc(lengths, e.Range));
      });
    }
  }, {
    key: "typeCheck",
    value: function (code) {
      var _this4 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(_this4.globals), function (_arg2) {
            return builder_.TryWith(builder_.Delay(function () {
              var patternInput = parseProgram(code);
              return builder_.Bind(Async_AwaitFuture_Static(_this4.bindingContext), function (_arg3) {
                var patternInput_1 = bindProgram(_arg3, patternInput[0]);
                return builder_.Bind(typeCheckProgram(_arg2, patternInput_1[1], patternInput_1[0]), function () {
                  var typeErrors = collectTypeErrors(patternInput_1[0]);
                  Log.trace("service", "Type checking completed");
                  var errors_1 = void 0;
                  var errors = patternInput[1].concat(typeErrors);
                  errors_1 = _this4.errorsToLineCol(code, errors);
                  return builder_.Return([patternInput[0], patternInput_1[1], errors_1]);
                });
              });
            }), function (_arg5) {
              Log.exn("service", "Type checking failed: %O", _arg5);
              return builder_.Return(null);
            });
          });
        });
      }(singleton$2);
    }
  }, {
    key: "ErrorsReported",
    get: function () {
      return this.errorsReported.Publish;
    }
  }]);

  return CheckingService;
}();
setType("TheGamma.Services.CheckingService", CheckingService);
var PreviewService = function () {
  _createClass(PreviewService, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.PreviewService",
        properties: {
          ZoneHeight: "number",
          ZoneSizeChanged: Interface("Microsoft.FSharp.Control.IEvent")
        }
      };
    }
  }]);

  function PreviewService(checker, globals, ed, livePreviews) {
    var _this5 = this;

    _classCallCheck(this, PreviewService);

    this.checker = checker;
    this.globals = globals;
    this.ed = ed;
    this.livePreviews = livePreviews;
    this.zoneSizeChanged = new Event$2();
    this.currentZone = null;
    this.zoneHeight = 0;
    this.tree = {};
    this.container = document.createElement("div");
    this.lastCode = "";
    this.lastMapper = new LocationMapper("");
    this.changingEditor = false;

    var trigger = function (ed_1) {
      return _this5.createLivePreview(ed_1);
    }(this.ed);

    this.ed.onDidChangeCursorPosition(function (ce) {
      if (!_this5.changingEditor) {
        var code = _this5.ed.getModel().getValue(1, false);

        Log.trace("live", "Cursor position changed: code <> lastCode = %s", code !== _this5.lastCode);

        (function (arg00) {
          startImmediate(arg00);
        })(function (builder_) {
          return builder_.Delay(function () {
            return builder_.Bind(_this5.getUpdateEventAfterChange(), function (_arg6) {
              trigger(_arg6);
              return builder_.Zero();
            });
          });
        }(singleton$2));
      }
    });
  }

  _createClass(PreviewService, [{
    key: "removeZone",
    value: function () {
      var _this6 = this;

      var matchValue = this.currentZone;

      if (matchValue == null) {} else {
        (function () {
          var id = matchValue[0];

          _this6.ed.changeViewZones(function (accessor) {
            accessor.removeZone(id);
          });
        })();
      }

      this.currentZone = null;
      this.zoneSizeChanged.Trigger(null);
    }
  }, {
    key: "createAndAddZone",
    value: function (endLine) {
      var _this7 = this;

      var zoneId = -1;
      var zone = {};
      var node$$1 = document.createElement('div');
      node$$1.style.width = "1000px";
      node$$1.style.height = "1000px";
      this.container = document.createElement('div');
      this.tree = {};
      node$$1.appendChild(this.container);
      this.ed.changeViewZones(function (accessor) {
        var matchValue = _this7.currentZone;

        if (matchValue != null) {
          var id = matchValue[0];
          accessor.removeZone(id);
        }

        zone.afterLineNumber = endLine;
        zone.heightInPx = 1;
        zone.domNode = node$$1;
        _this7.zoneHeight = 1;
        zoneId = accessor.addZone(zone);
        _this7.currentZone = [zoneId, zone];
      });
    }
  }, {
    key: "updateZones",
    value: function (trigger, liveState) {
      var _this8 = this;

      var dom = defaultArg(liveState.CurrentPreview, null, function (p) {
        return p.Render(trigger)(liveState);
      });

      if (dom != null) {
        (function () {
          if (function () {
            return _this8.currentZone == null;
          }(null)) {
            var endLine = dom.Line;

            _this8.createAndAddZone(endLine);
          }

          var patternInput = _this8.currentZone;
          var newTree = renderVirtual(dom.Preview);
          var patches = diff(_this8.tree, newTree);
          _this8.container = patch(_this8.container, patches);
          _this8.tree = newTree;

          var waitForActualHeight = function waitForActualHeight(n) {
            return function (builder_) {
              return builder_.Delay(function () {
                var newHeight = _this8.container.clientHeight;

                if (n === 10 ? true : newHeight !== 0) {
                  return builder_.Return(newHeight);
                } else {
                  return builder_.Bind(sleep(n * n), function () {
                    return builder_.ReturnFrom(waitForActualHeight(n + 1));
                  });
                }
              });
            }(singleton$2);
          };

          (function (arg00) {
            startImmediate(arg00);
          })(function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Bind(waitForActualHeight(1), function (_arg2) {
                Log.trace("live", "Old height: %s, New height: %s", _this8.zoneHeight, _arg2);

                if (_this8.zoneHeight !== _arg2 ? true : patternInput[1].afterLineNumber !== dom.Line) {
                  patternInput[1].afterLineNumber = dom.Line;
                  patternInput[1].heightInPx = _arg2;
                  _this8.zoneHeight = _arg2;

                  _this8.ed.changeViewZones(function (accessor) {
                    accessor.layoutZone(patternInput[0]);
                  });

                  _this8.zoneSizeChanged.Trigger(null);

                  return builder__1.Zero();
                } else {
                  return builder__1.Zero();
                }
              });
            });
          }(singleton$2));
        })();
      } else {
        this.removeZone();
      }
    }
  }, {
    key: "getUpdateEventAfterChange",
    value: function () {
      var _this9 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          var code = _this9.ed.getModel().getValue(1, false);

          var position = _this9.ed.getPosition();

          if (code !== _this9.lastCode) {
            var _ret3 = function () {
              _this9.lastCode = code;
              _this9.lastMapper = new LocationMapper(code);

              var loc = _this9.lastMapper.LineColToAbsolute(~~position.lineNumber, ~~position.column);

              return {
                v: builder_.Bind(_this9.checker.TypeCheck(code), function (_arg3) {
                  return builder_.Return(new LiveEvent("UpdateSource", [code, loc, _arg3[2], _this9.lastMapper]));
                })
              };
            }();

            if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
          } else {
            var loc_1 = _this9.lastMapper.LineColToAbsolute(~~position.lineNumber, ~~position.column);

            return builder_.Return(new LiveEvent("UpdateLocation", [loc_1]));
          }
        });
      }(singleton$2);
    }
  }, {
    key: "createLivePreview",
    value: function (ed) {
      var _this10 = this;

      var liveEvent = new Event$2();
      var noState = void 0;
      var $var210 = this;
      noState = _defineProperty({}, _Symbol.reflection, function () {
        return {
          interfaces: ["TheGamma.Live.Common.CustomLiveState"]
        };
      });
      var liveState = void 0;
      var Mapper = new LocationMapper("");
      var Location = 0;
      var Program$$2 = new Program$$1(node(new _Range(0, 0), new List$2()));
      liveState = new LiveState(new List$2(), "", Program$$2, Mapper, Location, null, noState, null);

      var applyEvent = function applyEvent(evt) {
        var liveState_1 = updateLiveState(liveState, evt);
        var newState = liveState_1.CurrentPreview == null ? null : liveState_1.CurrentPreview.Update(function (arg00) {
          liveEvent.Trigger(arg00);
        })(liveState_1)(evt);
        var matchValue = [newState, evt];
        var $var211 = matchValue[0] != null ? [0] : matchValue[1].Case === "UpdateSource" ? [1] : matchValue[1].Case === "UpdateLocation" ? [1] : [2];

        switch ($var211[0]) {
          case 0:
            var newState_1 = matchValue[0];
            return newState_1;

          case 1:
            Log.trace("live", "Searching for available previews");
            var state_1 = tryPick(function (lp) {
              var state = void 0;
              var CurrentPreview = lp;
              state = new LiveState(liveState_1.Globals, liveState_1.Code, liveState_1.Program, liveState_1.Mapper, liveState_1.Location, liveState_1.Selection, lp.InitialState, CurrentPreview);
              return lp.Update(function (arg00_1) {
                liveEvent.Trigger(arg00_1);
              })(state)(evt);
            }, _this10.livePreviews);

            if (state_1 != null) {
              return state_1;
            } else {
              var CurrentPreview_1 = null;
              return new LiveState(liveState_1.Globals, liveState_1.Code, liveState_1.Program, liveState_1.Mapper, liveState_1.Location, liveState_1.Selection, noState, CurrentPreview_1);
            }

          case 2:
            var CurrentPreview_2 = null;
            return new LiveState(liveState_1.Globals, liveState_1.Code, liveState_1.Program, liveState_1.Mapper, liveState_1.Location, liveState_1.Selection, noState, CurrentPreview_2);
        }
      };

      add$5(function (evt_1) {
        try {
          Log.trace("live", "Updating state %O with event %O", liveState, evt_1);
          var oldState = liveState;
          liveState = applyEvent(evt_1);

          if ((evt_1.Case === "UpdateSource" ? false : true) ? oldState.Code !== liveState.Code : false) {
            _this10.changingEditor = true;
            ed.getModel().setValue(liveState.Code);
          }

          var matchValue_1 = liveState.Selection;

          if (matchValue_1 != null) {
            _this10.changingEditor = true;
            var mrng = {};
            mrng.startColumn = matchValue_1.StartColumn;
            mrng.startLineNumber = matchValue_1.StartLineNumber;
            mrng.endColumn = matchValue_1.EndColumn;
            mrng.endLineNumber = matchValue_1.EndLineNumber;
            ed.setSelection(mrng);
            var Selection = null;
            liveState = new LiveState(liveState.Globals, liveState.Code, liveState.Program, liveState.Mapper, liveState.Location, Selection, liveState.State, liveState.CurrentPreview);
          }

          if (_this10.changingEditor === true) {
            _this10.changingEditor = false;

            (function (arg00_2) {
              startImmediate(arg00_2);
            })(function (builder_) {
              return builder_.Delay(function () {
                Log.trace("live", "Editor changed. Getting after change event...");
                return builder_.Bind(_this10.getUpdateEventAfterChange(), function (_arg4) {
                  Log.trace("live", "Editor changed. Updating state %O with event %O", liveState, _arg4);
                  liveState = applyEvent(_arg4);
                  Log.trace("live", "Editor changed. New state %O", liveState);

                  var trigger = function trigger(arg00_3) {
                    liveEvent.Trigger(arg00_3);
                  };

                  _this10.updateZones(trigger, liveState);

                  return builder_.Zero();
                });
              });
            }(singleton$2));
          } else {
            var trigger_1 = function trigger_1(arg00_4) {
              liveEvent.Trigger(arg00_4);
            };

            _this10.updateZones(trigger_1, liveState);
          }
        } catch (e) {
          Log.exn("live", "Error when updating state %O with event %O: %O", liveState, evt_1, e);
        }
      }, liveEvent.Publish);

      (function (arg00_5) {
        startImmediate(arg00_5);
      })(function (builder__1) {
        return builder__1.Delay(function () {
          return builder__1.Bind(Async_AwaitFuture_Static(_this10.globals), function (_arg5) {
            liveEvent.Trigger(new LiveEvent("InitializeGlobals", [_arg5]));
            return builder__1.Zero();
          });
        });
      }(singleton$2));

      return function (arg00_6) {
        liveEvent.Trigger(arg00_6);
      };
    }
  }, {
    key: "ZoneSizeChanged",
    get: function () {
      return this.zoneSizeChanged.Publish;
    }
  }, {
    key: "ZoneHeight",
    get: function () {
      if (!equals(this.currentZone, null)) {
        return this.zoneHeight;
      } else {
        return 0;
      }
    }
  }]);

  return PreviewService;
}();
setType("TheGamma.Services.PreviewService", PreviewService);

var CompilationContext = function () {
  function CompilationContext(lineLengths, globals) {
    _classCallCheck(this, CompilationContext);

    this.LineLengths = lineLengths;
    this.Globals = globals;
  }

  _createClass(CompilationContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.CodeGenerator.CompilationContext",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          LineLengths: makeGeneric(List$2, {
            T: "number"
          }),
          Globals: makeGeneric(FableMap, {
            Key: "string",
            Value: Expression
          })
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return CompilationContext;
}();
setType("TheGamma.CodeGenerator.CompilationContext", CompilationContext);
function offsetToLocation$1(lines, offs, lengths) {
  offsetToLocation$1: while (true) {
    var $var122 = lengths.tail != null ? offs <= lengths.head ? [0, lengths.head, lengths.tail] : [1] : [1];

    switch ($var122[0]) {
      case 0:
        return new Position(lines, offs);

      case 1:
        if (lengths.tail == null) {
          return new Position(lines, offs);
        } else {
          lines = lines + 1;
          offs = offs - lengths.head - 1;
          lengths = lengths.tail;
          continue offsetToLocation$1;
        }

    }
  }
}
function rangeToLoc$1(ctx, rng) {
  return new SourceLocation(offsetToLocation$1(1, rng.Start, ctx.LineLengths), offsetToLocation$1(1, rng.Start, ctx.LineLengths));
}
function getEmitterAndParams(name, typ) {
  var matchValue = reduceType(typ);

  if (matchValue.Case === "Object") {
    return pick(function (_arg1) {
      var $var123 = _arg1.Case === "Method" ? _arg1.Fields[0] === name ? [0, _arg1.Fields[1], _arg1.Fields[4], _arg1.Fields[0]] : [1] : [1];

      switch ($var123[0]) {
        case 0:
          return [$var123[2], $var123[1]];

        case 1:
          var $var124 = _arg1.Case === "Property" ? _arg1.Fields[0] === name ? [0, _arg1.Fields[3], _arg1.Fields[0]] : [1] : [1];

          switch ($var124[0]) {
            case 0:
              return [$var124[1], new List$2()];

            case 1:
              return null;
          }

      }
    }, matchValue.Fields[0].Members);
  } else {
    Log.exn("codegen", "getEmitterAndParams: Not an object %O", matchValue);
    throw new Error("getEmitterAndParams: Not an object");
  }
}
function compileExpression(ctx, expr) {
  var $var125 = expr.Node.Case === "Binary" ? expr.Node.Fields[1].Node.Case === "Power" ? [0, expr.Node.Fields[0], expr.Node.Fields[2]] : [1, expr.Node.Fields[0], expr.Node.Fields[1], expr.Node.Fields[2]] : expr.Node.Case === "Call" ? expr.Node.Fields[0] == null ? [3, expr.Node.Fields[2], expr.Node.Fields[1]] : [2, expr.Node.Fields[2], expr.Node.Fields[0], expr.Node.Fields[1]] : expr.Node.Case === "Property" ? [4, expr.Node.Fields[0], expr.Node.Fields[1]] : expr.Node.Case === "Number" ? [5, expr.Node.Fields[0]] : expr.Node.Case === "String" ? [6, expr.Node.Fields[0]] : expr.Node.Case === "Boolean" ? [7, expr.Node.Fields[0]] : expr.Node.Case === "Variable" ? ctx.Globals.has(expr.Node.Fields[0].Node.Name) ? [8, expr.Node.Fields[0]] : [9] : [9];

  var _ret = function () {
    switch ($var125[0]) {
      case 0:
        var l = compileExpression(ctx, $var125[1]);
        var r = compileExpression(ctx, $var125[2]);
        var rng = rangeToLoc$1(ctx, expr.Range);
        var pow = new Expression("MemberExpression", [new Expression("IdentifierExpression", ["pow", rng]), new Expression("IdentifierExpression", ["Math", rng]), false, rng]);
        return {
          v: new Expression("CallExpression", [pow, ofArray([l, r]), rangeToLoc$1(ctx, expr.Range)])
        };

      case 1:
        var l_1 = compileExpression(ctx, $var125[1]);
        var r_1 = compileExpression(ctx, $var125[3]);
        var op = void 0;

        if ($var125[2].Node.Case === "Plus") {
          op = new BinaryOperator("BinaryPlus", []);
        } else if ($var125[2].Node.Case === "Minus") {
          op = new BinaryOperator("BinaryMinus", []);
        } else if ($var125[2].Node.Case === "Multiply") {
          op = new BinaryOperator("BinaryMultiply", []);
        } else if ($var125[2].Node.Case === "Divide") {
          op = new BinaryOperator("BinaryDivide", []);
        } else if ($var125[2].Node.Case === "GreaterThan") {
          op = new BinaryOperator("BinaryGreater", []);
        } else if ($var125[2].Node.Case === "LessThan") {
          op = new BinaryOperator("BinaryLess", []);
        } else if ($var125[2].Node.Case === "GreaterThanOrEqual") {
          op = new BinaryOperator("BinaryGreaterOrEqual", []);
        } else if ($var125[2].Node.Case === "LessThanOrEqual") {
          op = new BinaryOperator("BinaryLessOrEqual", []);
        } else if ($var125[2].Node.Case === "Power") {
          throw new Error("compileExpression: Power is not a binary operation");
        } else {
          op = new BinaryOperator("BinaryEqualStrict", []);
        }

        return {
          v: new Expression("BinaryExpression", [op, l_1, r_1, rangeToLoc$1(ctx, expr.Range)])
        };

      case 2:
        var compiledArgs = map$4(function (a) {
          return [a.Name, compileExpression(ctx, a.Value)];
        }, $var125[1].Node);

        var positionArgs = _Array$from(map$5(function (tuple) {
          return tuple[1];
        }, takeWhile(function (tupledArg) {
          return function () {
            return tupledArg[0] == null;
          }(null);
        }, compiledArgs)));

        var namedArgs = new _Map(choose$1(function (_arg1) {
          if (_arg1[0] != null) {
            var n = _arg1[0];
            return [n.Node.Name, _arg1[1]];
          } else {
            return null;
          }
        }, compiledArgs));
        var patternInput = getEmitterAndParams($var125[3].Node.Name, $var125[2].Entity.Type);
        var inst = compileExpression(ctx, $var125[2]);
        var pars = mapIndexed$$1(function (i, tupledArg_1) {
          return i < positionArgs.length ? positionArgs[i] : namedArgs.has(tupledArg_1[0]) ? namedArgs.get(tupledArg_1[0]) : new Expression("NullLiteral", [rangeToLoc$1(ctx, $var125[1].Range)]);
        }, patternInput[1]);
        return {
          v: patternInput[0].Emit([inst, pars])
        };

      case 3:
        throw new Error("compileExpression: Call without instance is not supported");

      case 4:
        var patternInput_1 = getEmitterAndParams($var125[2].Node.Name, $var125[1].Entity.Type);
        var inst_1 = compileExpression(ctx, $var125[1]);
        return {
          v: patternInput_1[0].Emit([inst_1, new List$2()])
        };

      case 5:
        return {
          v: new Expression("NumericLiteral", [$var125[1], rangeToLoc$1(ctx, expr.Range)])
        };

      case 6:
        return {
          v: new Expression("StringLiteral", [$var125[1], rangeToLoc$1(ctx, expr.Range)])
        };

      case 7:
        return {
          v: new Expression("BooleanLiteral", [$var125[1], rangeToLoc$1(ctx, expr.Range)])
        };

      case 8:
        return {
          v: ctx.Globals.get($var125[1].Node.Name)
        };

      case 9:
        if (expr.Node.Case === "Variable") {
          return {
            v: new Expression("IdentifierExpression", [expr.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, expr.Node.Fields[0].Range)])
          };
        } else if (expr.Node.Case === "List") {
          var es = map$4(function (expr_1) {
            return compileExpression(ctx, expr_1);
          }, expr.Node.Fields[0]);
          return {
            v: new Expression("ArrayExpression", [es, rangeToLoc$1(ctx, expr.Range)])
          };
        } else if (expr.Node.Case === "Function") {
          var _ret2 = function () {
            var _var = new Expression("IdentifierExpression", [expr.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, expr.Node.Fields[0].Range)]);

            var ce = compileExpression(function () {
              var Globals = add$1(expr.Node.Fields[0].Node.Name, _var, ctx.Globals);
              return new CompilationContext(ctx.LineLengths, Globals);
            }(), expr.Node.Fields[1]);
            var body = new Statement("BlockStatement", [ofArray([new Statement("ReturnStatement", [ce, rangeToLoc$1(ctx, expr.Node.Fields[1].Range)])]), rangeToLoc$1(ctx, expr.Node.Fields[1].Range)]);
            return {
              v: {
                v: new Expression("FunctionExpression", [null, ofArray([new Pattern("IdentifierPattern", [expr.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, expr.Node.Fields[0].Range)])]), body, false, false, rangeToLoc$1(ctx, expr.Range)])
              }
            };
          }();

          if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        } else if (expr.Node.Case === "Empty") {
          console.log("compileExpression: %O", expr.Node);
          throw new Error("!");
        } else {
          throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\codegen/codegen.fs", 37, 8);
        }

    }
  }();

  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}
function compileCommand(ctx, cmd) {
  if (cmd.Node.Case === "Expr") {
    var e = compileExpression(ctx, cmd.Node.Fields[0]);
    return new Statement("ExpressionStatement", [e, rangeToLoc$1(ctx, cmd.Range)]);
  } else {
    var e_1 = compileExpression(ctx, cmd.Node.Fields[1]);
    var name = new Pattern("IdentifierPattern", [cmd.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, cmd.Node.Fields[0].Range)]);
    var decl = new VariableDeclarator("VariableDeclarator", [name, e_1, rangeToLoc$1(ctx, cmd.Range)]);
    return new Statement("VariableDeclaration", [new VariableDeclarationKind("Var", []), ofArray([decl]), rangeToLoc$1(ctx, cmd.Range)]);
  }
}
function compileProgram(ctx, prog) {
  var body = map$4(function (cmd) {
    return compileCommand(ctx, cmd);
  }, prog.Body.Node);
  return new Program$1(rangeToLoc$1(ctx, prog.Body.Range), body);
}
var BabelOptions$1 = function () {
  function BabelOptions(presets) {
    _classCallCheck(this, BabelOptions);

    this.presets = presets;
  }

  _createClass(BabelOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.CodeGenerator.BabelOptions",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          presets: FableArray("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return BabelOptions;
}();
setType("TheGamma.CodeGenerator.BabelOptions", BabelOptions$1);
var BabelResult$1 = function () {
  function BabelResult(code) {
    _classCallCheck(this, BabelResult);

    this.code = code;
  }

  _createClass(BabelResult, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.CodeGenerator.BabelResult",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          code: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return BabelResult;
}();
setType("TheGamma.CodeGenerator.BabelResult", BabelResult$1);
function compile(globals, text, prog) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.TryWith(builder_.Delay(function () {
        return builder_.Bind(Async_AwaitFuture_Static(globals), function (_arg1) {
          var globals_1 = create$3(choose$$1(function (_arg2) {
            var $var126 = _arg2.Kind.Case === "GlobalValue" ? _arg2.Kind.Fields[1] != null ? [0, _arg2.Kind.Fields[1], _arg2.Kind.Fields[0]] : [1] : [1];

            switch ($var126[0]) {
              case 0:
                return [$var126[2].Name, $var126[1]];

              case 1:
                return null;
            }
          }, _arg1), new GenericComparer(compare));
          var ctx = new CompilationContext(toList(delay(function () {
            return map$5(function (l) {
              return l.length;
            }, split$$1(text, "\n"));
          })), globals_1);
          var res = compileProgram(ctx, prog);
          var code = Babel.transformFromAst(Serializer.serializeProgram(res), text, new BabelOptions$1(["es2015"]));
          Log.trace("codegen", "Evaluating: %O", code);
          return builder_.Return(code.code);
        });
      }), function (_arg3) {
        Log.exn("codegen", "Evaluating code failed: %O", _arg3);
        return builder_.Return("");
      });
    });
  }(singleton$2);
}

var Aggregation = function () {
  function Aggregation(caseName, fields) {
    _classCallCheck(this, Aggregation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Aggregation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Aggregation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          ConcatValues: ["string"],
          CountAll: [],
          CountDistinct: ["string"],
          GroupKey: [],
          Mean: ["string"],
          ReturnUnique: ["string"],
          Sum: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Aggregation;
}();
setType("TheGamma.TypeProviders.Pivot.Aggregation", Aggregation);
var SortDirection = function () {
  function SortDirection(caseName, fields) {
    _classCallCheck(this, SortDirection);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(SortDirection, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.SortDirection",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Ascending: [],
          Descending: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return SortDirection;
}();
setType("TheGamma.TypeProviders.Pivot.SortDirection", SortDirection);
var Paging = function () {
  function Paging(caseName, fields) {
    _classCallCheck(this, Paging);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Paging, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Paging",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Skip: ["string"],
          Take: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Paging;
}();
setType("TheGamma.TypeProviders.Pivot.Paging", Paging);
var Transformation = function () {
  function Transformation(caseName, fields) {
    _classCallCheck(this, Transformation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Transformation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Transformation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          DropColumns: [makeGeneric(List$2, {
            T: "string"
          })],
          Empty: [],
          FilterBy: [makeGeneric(List$2, {
            T: Tuple(["string", "boolean", "string"])
          })],
          GetRange: ["string"],
          GetSeries: ["string", "string"],
          GetTheData: [],
          GroupBy: [makeGeneric(List$2, {
            T: "string"
          }), makeGeneric(List$2, {
            T: Aggregation
          })],
          Metadata: [],
          Paging: [makeGeneric(List$2, {
            T: Paging
          })],
          SortBy: [makeGeneric(List$2, {
            T: Tuple(["string", SortDirection])
          })]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Transformation;
}();
setType("TheGamma.TypeProviders.Pivot.Transformation", Transformation);
var Field = function () {
  function Field(name, type) {
    _classCallCheck(this, Field);

    this.Name = name;
    this.Type = type;
  }

  _createClass(Field, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Field",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Name: "string",
          Type: PrimitiveType
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Field;
}();
setType("TheGamma.TypeProviders.Pivot.Field", Field);
var Transform = function (__exports) {
  var formatAgg = function formatAgg(_arg1) {
    if (_arg1.Case === "CountAll") {
      return "count-all";
    } else if (_arg1.Case === "CountDistinct") {
      return "count-dist " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "ReturnUnique") {
      return "unique " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "ConcatValues") {
      return "concat-vals " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "Sum") {
      return "sum " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "Mean") {
      return "mean " + escapeIdent(_arg1.Fields[0]);
    } else {
      return "key";
    }
  };

  var toUrl = __exports.toUrl = function (transforms) {
    return join("$", map$4(function (tupledArg) {
      return tupledArg[1].tail == null ? tupledArg[0] : tupledArg[0] + "(" + join(",", tupledArg[1]) + ")";
    }, concat$$1(toList(delay(function () {
      return map$5(function (t) {
        return t.Case === "Metadata" ? ofArray([["metadata", new List$2()]]) : t.Case === "GetRange" ? ofArray([["range", ofArray([t.Fields[0]])]]) : t.Case === "FilterBy" ? ofArray([["filter", map$4(function (tupledArg_1) {
          return tupledArg_1[0] + (tupledArg_1[1] ? " eq " : " neq ") + tupledArg_1[2];
        }, t.Fields[0])]]) : t.Case === "DropColumns" ? ofArray([["drop", t.Fields[0]]]) : t.Case === "SortBy" ? ofArray([["sort", map$4(function (tupledArg_2) {
          return tupledArg_2[0] + (tupledArg_2[1].Equals(new SortDirection("Ascending", [])) ? " asc" : " desc");
        }, t.Fields[0])]]) : t.Case === "GroupBy" ? ofArray([["groupby", append$$1(map$4(function (fld) {
          return "by " + escapeIdent(fld);
        }, t.Fields[0]), map$4(function (_arg1) {
          return formatAgg(_arg1);
        }, t.Fields[1]))]]) : t.Case === "Paging" ? map$4(function (_arg1_1) {
          return _arg1_1.Case === "Skip" ? ["skip", ofArray([_arg1_1.Fields[0]])] : ["take", ofArray([_arg1_1.Fields[0]])];
        }, t.Fields[0]) : t.Case === "GetSeries" ? ofArray([["series", ofArray([t.Fields[0], t.Fields[1]])]]) : t.Case === "Empty" ? new List$2() : new List$2();
      }, transforms);
    })))));
  };

  var singleTransformFields = __exports.singleTransformFields = function (fields, _arg1) {
    if (_arg1.Case === "Metadata") {
      throw new Error("Metadata should not appear in normal queries");
    } else if (_arg1.Case === "GetRange") {
      throw new Error("GetRange should not appear in normal queries");
    } else if (_arg1.Case === "GetTheData") {
      return fields;
    } else if (_arg1.Case === "SortBy") {
      return fields;
    } else if (_arg1.Case === "Paging") {
      return fields;
    } else if (_arg1.Case === "FilterBy") {
      return fields;
    } else if (_arg1.Case === "GetSeries") {
      return ofArray([find(function (f) {
        return f.Name === _arg1.Fields[0];
      }, fields), find(function (f_1) {
        return f_1.Name === _arg1.Fields[1];
      }, fields)]);
    } else if (_arg1.Case === "DropColumns") {
      var _ret = function () {
        var dropped = create$2(_arg1.Fields[0], new GenericComparer(compare));
        return {
          v: filter$1(function (f_2) {
            return !dropped.has(f_2.Name);
          }, fields)
        };
      }();

      if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    } else if (_arg1.Case === "GroupBy") {
      var _ret2 = function () {
        var oldFields = new _Map(toList(delay(function () {
          return map$5(function (f_3) {
            return [f_3.Name, f_3];
          }, fields);
        })));
        return {
          v: collect$$1(function (_arg2) {
            var $var149 = _arg2.Case === "ReturnUnique" ? [1, _arg2.Fields[0]] : _arg2.Case === "ConcatValues" ? [1, _arg2.Fields[0]] : _arg2.Case === "Sum" ? [1, _arg2.Fields[0]] : _arg2.Case === "Mean" ? [2] : _arg2.Case === "CountAll" ? [3] : _arg2.Case === "CountDistinct" ? [4] : [0];

            switch ($var149[0]) {
              case 0:
                return map$4(function (f_4) {
                  return oldFields.get(f_4);
                }, _arg1.Fields[0]);

              case 1:
                return ofArray([oldFields.get($var149[1])]);

              case 2:
                return ofArray([oldFields.get(_arg2.Fields[0])]);

              case 3:
                return ofArray([new Field("count", new PrimitiveType("Number", []))]);

              case 4:
                return ofArray([new Field(oldFields.get(_arg2.Fields[0]).Name, new PrimitiveType("Number", []))]);
            }
          }, _arg1.Fields[1])
        };
      }();

      if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    } else {
      return fields;
    }
  };

  var transformFields = __exports.transformFields = function (fields, tfs) {
    return toList(function () {
      var state = toList(fields);
      return function (list) {
        return fold$1(function (fields_1, _arg1) {
          return singleTransformFields(fields_1, _arg1);
        }, state, list);
      };
    }()(tfs));
  };

  return __exports;
}({});



function makeObjectType(members) {
  return new Type("Object", [new ObjectType(_Array$from(members))]);
}
function isNumeric(fld) {
  return fld.Equals(new PrimitiveType("Number", []));
}
function isConcatenable(fld) {
  return fld.Equals(new PrimitiveType("String", []));
}
function ident(s) {
  return new Expression("IdentifierExpression", [s, null]);
}
function str(v) {
  return new Expression("StringLiteral", [v, null]);
}
function bool(v) {
  return new Expression("BooleanLiteral", [v, null]);
}
function arr(l) {
  return new Expression("ArrayExpression", [l, null]);
}
function op_Dynamic(e, s) {
  return new Expression("MemberExpression", [e, new Expression("IdentifierExpression", [s, null]), false, null]);
}
function op_DivideQmarkDivide(e, a) {
  return new Expression("MemberExpression", [e, a, true, null]);
}
function op_DivideAtDivide(e, args) {
  return new Expression("CallExpression", [e, args, null]);
}

function getTypeAndEmitter(_arg1) {
  if (_arg1.Case === "Number") {
    return [new Type("Primitive", [new PrimitiveType("Number", [])]), function (e) {
      return op_DivideAtDivide(ident("Number"), ofArray([e]));
    }];
  } else if (_arg1.Case === "Bool") {
    return [new Type("Primitive", [new PrimitiveType("Number", [])]), function (e_1) {
      return op_DivideAtDivide(ident("Boolean"), ofArray([e_1]));
    }];
  } else if (_arg1.Case === "Unit") {
    return [new Type("Primitive", [new PrimitiveType("Unit", [])]), function (e_2) {
      return new Expression("NullLiteral", [null]);
    }];
  } else {
    return [new Type("Primitive", [new PrimitiveType("String", [])]), function (x) {
      return x;
    }];
  }
}
var propertyEmitter = new Emitter(function (tupledArg) {
  return tupledArg[0];
});
function makeMethodEmitter(callid, pars) {
  return new Emitter(function (tupledArg) {
    var args = arr(toList(delay(function () {
      return map$5(function (v) {
        return v;
      }, tupledArg[1]);
    })));
    return op_DivideAtDivide(op_Dynamic(tupledArg[0], "addCall"), ofArray([str(callid), args]));
  });
}
function makeDataEmitter(isPreview, isSeries, tfs) {
  return new Emitter(function (tupledArg) {
    return isSeries ? op_DivideAtDivide(op_Dynamic(ident("series"), "create"), ofArray([op_DivideAtDivide(op_Dynamic(tupledArg[0], "getData"), ofArray([str(Transform.toUrl(reverse$$1(tfs))), bool(isPreview)])), str("key"), str("value"), str("")])) : op_DivideAtDivide(op_Dynamic(ident("series"), "ordinal"), ofArray([op_DivideAtDivide(op_Dynamic(tupledArg[0], "getData"), ofArray([str(Transform.toUrl(reverse$$1(tfs))), bool(isPreview)])), str("key"), str("value"), str("")]));
  });
}
var Context$2 = function () {
  function Context(root, lookupNamed, inputFields, fields) {
    _classCallCheck(this, Context);

    this.Root = root;
    this.LookupNamed = lookupNamed;
    this.InputFields = inputFields;
    this.Fields = fields;
  }

  _createClass(Context, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Context",
        interfaces: ["FSharpRecord"],
        properties: {
          Root: "string",
          LookupNamed: "function",
          InputFields: makeGeneric(List$2, {
            T: Field
          }),
          Fields: makeGeneric(List$2, {
            T: Field
          })
        }
      };
    }
  }]);

  return Context;
}();
setType("TheGamma.TypeProviders.Pivot.Context", Context$2);
function makeProperty(ctx, name, tfs) {
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", tfs);
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", ctx.Fields);
  return new Member("Property", [name, makePivotType(ctx, tfs), ofArray([meta1, meta2]), propertyEmitter]);
}
function makeMethod(ctx, name, tfs, callid, args) {
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", tfs);
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", ctx.Fields);
  return new Member("Method", [name, toList(delay(function () {
    return collect$1(function (matchValue) {
      return singleton$1([matchValue[0], false, new Type("Primitive", [matchValue[1]])]);
    }, args);
  })), makePivotType(ctx, tfs), ofArray([meta1, meta2]), makeMethodEmitter(callid, args)]);
}
function makeDataMember(ctx, name, isPreview, tfs) {
  var fields = Transform.transformFields(ctx.InputFields, reverse$$1(tfs));
  Log.trace("providers", "Make data member using transform %O. Got fields: %O", tfs, fields);
  var patternInput_1 = void 0;
  var $var150 = tfs.tail != null ? tfs.head.Case === "GetSeries" ? [0] : [1] : [1];

  switch ($var150[0]) {
    case 0:
      var $var151 = fields.tail != null ? fields.tail.tail != null ? fields.tail.tail.tail == null ? [0, fields.head, fields.tail.head] : [1] : [1] : [1];

      switch ($var151[0]) {
        case 0:
          patternInput_1 = [ctx.LookupNamed("series")(ofArray([new Type("Primitive", [$var151[1].Type]), new Type("Primitive", [$var151[2].Type])])), true];
          break;

        case 1:
          throw new Error("makeDataMember: Series should have key and value");
          break;
      }

      break;

    case 1:
      var membs = _Array$from(fields).map(function (fld) {
        var patternInput = getTypeAndEmitter(fld.Type);
        var emitter = new Emitter(function (tupledArg) {
          return patternInput[1](op_DivideQmarkDivide(tupledArg[0], str(fld.Name)));
        });
        return new Member("Property", [fld.Name, patternInput[0], ofArray([ProviderHelpers.docMeta(new Documentation("Text", [""]))]), emitter]);
      });

      var recTyp = new Type("Object", [new ObjectType(membs)]);
      patternInput_1 = [ctx.LookupNamed("series")(ofArray([new Type("Primitive", [new PrimitiveType("Number", [])]), recTyp])), false];
      break;
  }

  var tfs_1 = patternInput_1[1] ? tfs : new List$2(new Transformation("GetTheData", []), tfs);
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", tfs_1);
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", ctx.Fields);
  return new Member("Property", [name, patternInput_1[0], ofArray([meta1, meta2]), makeDataEmitter(isPreview, patternInput_1[1], tfs_1)]);
}
function handleGetSeriesRequest(ctx, rest, k, v) {
  var matchValue = [k, v];
  var $var152 = matchValue[0] === "!" ? matchValue[1] === "!" ? [0] : [2] : matchValue[1] === "!" ? [1] : [2];

  switch ($var152[0]) {
    case 0:
      return makeObjectType(toList(delay(function () {
        return map$5(function (field) {
          return makeProperty(ctx, "with key " + field.Name, new List$2(new Transformation("GetSeries", [field.Name, "!"]), rest));
        }, ctx.Fields);
      })));

    case 1:
      return makeObjectType(toList(delay(function () {
        return map$5(function (field_1) {
          return makeDataMember(ctx, "and value " + field_1.Name, false, new List$2(new Transformation("GetSeries", [matchValue[0], field_1.Name]), rest));
        }, ctx.Fields);
      })));

    case 2:
      throw new Error("handleGetSeriesRequest: Should not happen");
  }
}
function handlePagingRequest(ctx, rest, pgid, ops) {
  var takeMemb = makeMethod(ctx, "take", ofArray([new Transformation("Empty", []), new Transformation("Paging", [reverse$$1(new List$2(new Paging("Take", [pgid + "-take"]), ops))])], rest), pgid + "-take", ofArray([["count", new PrimitiveType("Number", [])]]));
  var skipMemb = makeMethod(ctx, "skip", new List$2(new Transformation("Paging", [new List$2(new Paging("Skip", [pgid + "-skip"]), ops)]), rest), pgid + "-skip", ofArray([["count", new PrimitiveType("Number", [])]]));
  var thenMemb = makeProperty(ctx, "then", ofArray([new Transformation("Empty", []), new Transformation("Paging", [reverse$$1(ops)])], rest));
  return makeObjectType(function () {
    var $var153 = ops.tail != null ? ops.head.Case === "Skip" ? ops.tail.tail == null ? [1] : [2] : [2] : [0];

    switch ($var153[0]) {
      case 0:
        return ofArray([skipMemb, takeMemb, thenMemb]);

      case 1:
        return ofArray([takeMemb, thenMemb]);

      case 2:
        throw new Error("handlePagingRequest: Shold not happen");
    }
  }());
}
function handleDropRequest(ctx, rest, dropped) {
  var droppedFields = create$2(dropped, new GenericComparer(compare));
  return makeObjectType(toList(delay(function () {
    return append$1(singleton$1(makeProperty(ctx, "then", ofArray([new Transformation("Empty", []), new Transformation("DropColumns", [dropped])], rest))), delay(function () {
      return collect$1(function (field) {
        return !droppedFields.has(field.Name) ? singleton$1(makeProperty(ctx, "drop " + field.Name, new List$2(new Transformation("DropColumns", [new List$2(field.Name, dropped)]), rest))) : empty();
      }, ctx.Fields);
    }));
  })));
}
function handleSortRequest(ctx, rest, keys) {
  var usedKeys = create$2(map$4(function (tuple) {
    return tuple[0];
  }, keys), new GenericComparer(compare));
  return makeObjectType(toList(delay(function () {
    return append$1(singleton$1(makeProperty(ctx, "then", ofArray([new Transformation("Empty", []), new Transformation("SortBy", [keys])], rest))), delay(function () {
      return collect$1(function (field) {
        if (!usedKeys.has(field.Name)) {
          var _ret3 = function () {
            var doc = fsFormat("Use the field '%s' as the next sorting keys")(function (x) {
              return x;
            })(field.Name);
            var prefix = keys.Equals(new List$2()) ? "by " : "and by ";
            return {
              v: append$1(singleton$1(makeProperty(ctx, prefix + field.Name, new List$2(new Transformation("SortBy", [new List$2([field.Name, new SortDirection("Ascending", [])], keys)]), rest))), delay(function () {
                return singleton$1(makeProperty(ctx, prefix + field.Name + " descending", new List$2(new Transformation("SortBy", [new List$2([field.Name, new SortDirection("Descending", [])], keys)]), rest)));
              }))
            };
          }();

          if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
        } else {
          return empty();
        }
      }, ctx.Fields);
    }));
  })));
}
function aggregationMembers(ctx, rest, keys, aggs) {
  var containsCountAll = exists$1(function () {
    var x = new Aggregation("CountAll", []);
    return function (y) {
      return x.Equals(y);
    };
  }(), aggs);

  var containsField = function containsField(fld) {
    return exists$1(function (_arg1) {
      var $var154 = _arg1.Case === "ReturnUnique" ? [0, _arg1.Fields[0]] : _arg1.Case === "ConcatValues" ? [0, _arg1.Fields[0]] : _arg1.Case === "Sum" ? [0, _arg1.Fields[0]] : _arg1.Case === "Mean" ? [0, _arg1.Fields[0]] : _arg1.Case === "CountAll" ? [1] : _arg1.Case === "GroupKey" ? [1] : [0, _arg1.Fields[0]];

      switch ($var154[0]) {
        case 0:
          return $var154[1] === fld;

        case 1:
          return false;
      }
    }, aggs);
  };

  var makeAggMember = function makeAggMember(name) {
    return function (agg) {
      return makeProperty(ctx, name, new List$2(new Transformation("GroupBy", [keys, new List$2(agg, aggs)]), rest));
    };
  };

  return toList(delay(function () {
    return append$1(singleton$1(makeProperty(ctx, "then", ofArray([new Transformation("Empty", []), new Transformation("GroupBy", [keys, aggs])], rest))), delay(function () {
      return append$1(!containsCountAll ? singleton$1(makeAggMember("count all")(new Aggregation("CountAll", []))) : empty(), delay(function () {
        return collect$1(function (fld_1) {
          return !containsField(fld_1.Name) ? append$1(singleton$1(makeAggMember("count distinct " + fld_1.Name)(new Aggregation("CountDistinct", [fld_1.Name]))), delay(function () {
            return append$1(singleton$1(makeAggMember("return unique " + fld_1.Name)(new Aggregation("ReturnUnique", [fld_1.Name]))), delay(function () {
              return append$1(isConcatenable(fld_1.Type) ? singleton$1(makeAggMember("concatenate values of " + fld_1.Name)(new Aggregation("ConcatValues", [fld_1.Name]))) : empty(), delay(function () {
                return isNumeric(fld_1.Type) ? append$1(singleton$1(makeAggMember("average " + fld_1.Name)(new Aggregation("Mean", [fld_1.Name]))), delay(function () {
                  return singleton$1(makeAggMember("sum " + fld_1.Name)(new Aggregation("Sum", [fld_1.Name])));
                })) : empty();
              }));
            }));
          })) : empty();
        }, ctx.Fields);
      }));
    }));
  }));
}
function handleGroupAggRequest(ctx, rest, keys, aggs) {
  return makeObjectType(aggregationMembers(ctx, rest, keys, aggs));
}
function handleGroupRequest(ctx, rest, keys) {
  var prefix = keys.tail == null ? "by " : "and ";
  return makeObjectType(toList(delay(function () {
    return append$1(map$5(function (field) {
      return makeProperty(ctx, prefix + field.Name, new List$2(new Transformation("GroupBy", [new List$2(field.Name, keys), new List$2()]), rest));
    }, ctx.Fields), delay(function () {
      return !(keys.tail == null) ? aggregationMembers(ctx, rest, keys, ofArray([new Aggregation("GroupKey", [])])) : empty();
    }));
  })));
}
function handleFilterEqNeqRequest(ctx, rest, fld, eq, conds) {
  return function (builder_) {
    return builder_.Delay(function () {
      var tfs = conds.tail == null ? rest : new List$2(new Transformation("FilterBy", [conds]), rest);
      var url = ctx.Root + "?" + Transform.toUrl(reverse$$1(new List$2(new Transformation("GetRange", [fld]), tfs)));
      return builder_.Bind(Http.Request("GET", url), function (_arg2) {
        var options = JSON.parse(_arg2);
        return builder_.Return(makeObjectType(toList(delay(function () {
          return map$5(function (opt) {
            return makeProperty(ctx, opt, new List$2(new Transformation("FilterBy", [new List$2([fld, eq, opt], conds)]), rest));
          }, options);
        }))));
      });
    });
  }(singleton$2);
}
function handleFilterRequest(ctx, rest, conds) {
  var prefix = conds.tail == null ? "" : "and ";
  return makeObjectType(toList(delay(function () {
    return append$1(collect$1(function (field) {
      return append$1(singleton$1(makeProperty(ctx, prefix + field.Name + " is", new List$2(new Transformation("FilterBy", [new List$2([field.Name, true, "!"], conds)]), rest))), delay(function () {
        return singleton$1(makeProperty(ctx, prefix + field.Name + " is not", new List$2(new Transformation("FilterBy", [new List$2([field.Name, false, "!"], conds)]), rest)));
      }));
    }, ctx.Fields), delay(function () {
      return !(conds.tail == null) ? singleton$1(makeProperty(ctx, "then", ofArray([new Transformation("Empty", []), new Transformation("FilterBy", [conds])], rest))) : empty();
    }));
  })));
}
function makePivotTypeImmediate(ctx, tfs) {
  return function (builder_) {
    return builder_.Delay(function () {
      var patternInput = tfs.tail != null ? [tfs.head, tfs.tail] : [new Transformation("Empty", []), new List$2()];
      var ctx_1 = void 0;
      var Fields = Transform.transformFields(ctx.InputFields, reverse$$1(patternInput[1]));
      ctx_1 = new Context$2(ctx.Root, ctx.LookupNamed, ctx.InputFields, Fields);
      var $var155 = patternInput[0].Case === "GetSeries" ? [1, patternInput[0].Fields[0], patternInput[0].Fields[1]] : patternInput[0].Case === "Paging" ? [2, patternInput[0].Fields[0]] : patternInput[0].Case === "SortBy" ? [3, patternInput[0].Fields[0]] : patternInput[0].Case === "DropColumns" ? [4, patternInput[0].Fields[0]] : patternInput[0].Case === "FilterBy" ? patternInput[0].Fields[0].tail != null ? patternInput[0].Fields[0].head[2] === "!" ? [5, patternInput[0].Fields[0].tail, patternInput[0].Fields[0].head[1], patternInput[0].Fields[0].head[0]] : [6, patternInput[0].Fields[0]] : [6, patternInput[0].Fields[0]] : patternInput[0].Case === "GroupBy" ? patternInput[0].Fields[1].tail == null ? [7, patternInput[0].Fields[0]] : [8, patternInput[0].Fields[1], patternInput[0].Fields[0]] : patternInput[0].Case === "GetTheData" ? [9] : patternInput[0].Case === "GetRange" ? [9] : patternInput[0].Case === "Metadata" ? [9] : [0];

      switch ($var155[0]) {
        case 0:
          return builder_.Return(makeObjectType(ofArray([makeProperty(ctx_1, "group data", new List$2(new Transformation("GroupBy", [new List$2(), new List$2()]), patternInput[1])), makeProperty(ctx_1, "filter data", new List$2(new Transformation("FilterBy", [new List$2()]), patternInput[1])), makeProperty(ctx_1, "sort data", new List$2(new Transformation("SortBy", [new List$2()]), patternInput[1])), makeProperty(ctx_1, "drop columns", new List$2(new Transformation("DropColumns", [new List$2()]), patternInput[1])), makeProperty(ctx_1, "paging", new List$2(new Transformation("Paging", [new List$2()]), patternInput[1])), makeProperty(ctx_1, "get series", new List$2(new Transformation("GetSeries", ["!", "!"]), patternInput[1])), makeDataMember(ctx_1, "get the data", false, patternInput[1])])));

        case 1:
          return builder_.Return(handleGetSeriesRequest(ctx_1, patternInput[1], $var155[1], $var155[2]));

        case 2:
          var pgid = fsFormat("pgid-%d")(function (x) {
            return x;
          })(sumBy(function (_arg3) {
            return _arg3.Case === "Paging" ? 1 : 0;
          }, patternInput[1]));
          return builder_.Return(handlePagingRequest(ctx_1, patternInput[1], pgid, $var155[1]));

        case 3:
          return builder_.Return(handleSortRequest(ctx_1, patternInput[1], $var155[1]));

        case 4:
          return builder_.Return(handleDropRequest(ctx_1, patternInput[1], $var155[1]));

        case 5:
          return builder_.ReturnFrom(handleFilterEqNeqRequest(ctx_1, patternInput[1], $var155[3], $var155[2], $var155[1]));

        case 6:
          return builder_.Return(handleFilterRequest(ctx_1, patternInput[1], $var155[1]));

        case 7:
          return builder_.Return(handleGroupRequest(ctx_1, patternInput[1], $var155[1]));

        case 8:
          return builder_.Return(handleGroupAggRequest(ctx_1, patternInput[1], $var155[2], $var155[1]));

        case 9:
          return builder_.Return(function () {
            throw new Error("makePivotTypeImmediate: GetTheData, GetRange and Metadata shouldn't be of pivot type");
          }());
      }
    });
  }(singleton$2);
}
function adjustForPreview(tfs) {
  var $var156 = tfs.tail != null ? tfs.head.Case === "GroupBy" ? tfs.head.Fields[0].tail == null ? [0, tfs.tail] : tfs.head.Fields[1].tail == null ? [1, tfs.head.Fields[0], tfs.tail] : [3] : tfs.head.Case === "GetSeries" ? [2, tfs.tail] : [3] : [3];

  switch ($var156[0]) {
    case 0:
      return $var156[1];

    case 1:
      return new List$2(new Transformation("GroupBy", [$var156[1], ofArray([new Aggregation("GroupKey", [])])]), $var156[2]);

    case 2:
      return $var156[1];

    case 3:
      return tfs;
  }
}
function withPreview(ctx, tfs, typ) {
  if (typ.Case === "Object") {
    var preview = makeDataMember(ctx, "preview", true, adjustForPreview(tfs));
    return new Type("Object", [new ObjectType([preview].concat(typ.Fields[0].Members))]);
  } else {
    throw new Error("withPreview: Expected object type");
  }
}
function makePivotType(ctx, tfs) {
  var guid = Transform.toUrl(tfs);

  var typ = function (builder_) {
    return builder_.Delay(function () {
      return builder_.TryWith(builder_.Delay(function () {
        return builder_.Bind(makePivotTypeImmediate(ctx, tfs), function (_arg4) {
          return builder_.Return(withPreview(ctx, tfs, _arg4));
        });
      }), function (_arg5) {
        Log.exn("providers", "Failed when generating type for %O with exception %O", tfs, _arg5);
        return builder_.Return(function () {
          throw _arg5;
        }());
      });
    });
  }(singleton$2);

  return new Type("Delayed", ["pivot: " + guid, function (arg00) {
    return function (arg10) {
      return Async_CreateNamedFuture_Static(arg00, arg10);
    };
  }(guid)(typ)]);
}
function providePivotType(root, name, lookupNamed, fields) {
  var fields_1 = toList(delay(function () {
    return collect$1(function (matchValue) {
      return singleton$1(new Field(matchValue[0], matchValue[1]));
    }, fields);
  }));
  var typ = makePivotType(new Context$2(root, lookupNamed, fields_1, fields_1), new List$2());
  var ctx = ident("PivotContext");
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", new List$2());
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", fields_1);
  return new ProvidedType("GlobalValue", [name, ofArray([meta1, meta2]), new Expression("NewExpression", [ctx, ofArray([str(root), new Expression("ArrayExpression", [new List$2(), null])]), null]), typ]);
}

function pickMetaByType(ctx, typ, metas) {
  return tryPick(function (m) {
    return (m.Context === ctx ? m.Type === typ : false) ? m.Data : null;
  }, metas);
}
function pickPivotFields(expr) {
  var matchValue = expr.Entity;
  var $var157 = matchValue != null ? matchValue.Kind.Case === "ChainElement" ? [0, matchValue.Meta] : matchValue.Kind.Case === "GlobalValue" ? [0, matchValue.Meta] : matchValue.Kind.Case === "Variable" ? [0, matchValue.Kind.Fields[1].Meta] : [1] : [1];

  switch ($var157[0]) {
    case 0:
      var matchValue_1 = pickMetaByType("http://schema.thegamma.net/pivot", "Fields", $var157[1]);

      if (matchValue_1 != null) {
        return matchValue_1;
      } else {
        return null;
      }

    case 1:
      return null;
  }
}
function pickPivotTransformations(expr) {
  var matchValue = expr.Entity;
  var $var158 = matchValue != null ? matchValue.Kind.Case === "ChainElement" ? [0, matchValue.Meta] : matchValue.Kind.Case === "GlobalValue" ? [1, matchValue.Meta] : [2] : [2];

  switch ($var158[0]) {
    case 0:
      var matchValue_1 = pickMetaByType("http://schema.thegamma.net/pivot", "Transformations", $var158[1]);

      if (matchValue_1 != null) {
        return matchValue_1;
      } else {
        return null;
      }

    case 1:
      return new List$2();

    case 2:
      return null;
  }
}
function commandAtLocation(loc, program) {
  return tryFind(function (cmd) {
    return cmd.Range.Start <= loc ? cmd.Range.End + 1 >= loc : false;
  }, program.Body.Node);
}
function transformName(_arg1) {
  if (_arg1.Case === "DropColumns") {
    return "drop columns";
  } else if (_arg1.Case === "Empty") {
    return "empty";
  } else if (_arg1.Case === "FilterBy") {
    return "filter by";
  } else if (_arg1.Case === "GetSeries") {
    return "get series";
  } else if (_arg1.Case === "GetTheData") {
    return "get the data";
  } else if (_arg1.Case === "GroupBy") {
    return "group by";
  } else if (_arg1.Case === "Paging") {
    return "paging";
  } else if (_arg1.Case === "SortBy") {
    return "sort by";
  } else {
    throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\live/pivot.fs", 57, 20);
  }
}
var PivotSection = function () {
  function PivotSection(transformation, nodes) {
    _classCallCheck(this, PivotSection);

    this.Transformation = transformation;
    this.Nodes = nodes;
  }

  _createClass(PivotSection, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotSection",
        interfaces: ["FSharpRecord"],
        properties: {
          Transformation: Transformation,
          Nodes: makeGeneric(List$2, {
            T: makeGeneric(_Node, {
              T: Expr
            })
          })
        }
      };
    }
  }]);

  return PivotSection;
}();
setType("TheGamma.Live.Pivot.PivotSection", PivotSection);
function createPivotSections(tfss) {
  var loop = function loop(acc) {
    return function (tupledArg) {
      return function (_arg1) {
        loop: while (true) {
          var $var159 = _arg1.tail != null ? function () {
            var tfs_1 = _arg1.head[1];
            var e_1 = _arg1.head[0];

            if (transformName(tfs_1.head) === transformName(tupledArg[0])) {
              return tfs_1.length === tupledArg[2];
            } else {
              return false;
            }
          }() ? [0, _arg1.head[0], _arg1.head[1], _arg1.tail] : [1] : [1];

          switch ($var159[0]) {
            case 0:
              acc = acc;
              tupledArg = [$var159[2].head, new List$2($var159[1], tupledArg[1]), tupledArg[2]];
              _arg1 = $var159[3];
              continue loop;

            case 1:
              if (_arg1.tail == null) {
                var current = new PivotSection(tupledArg[0], reverse$$1(tupledArg[1]));
                return reverse$$1(new List$2(current, acc));
              } else {
                var tfs = _arg1.head[1];
                var e = _arg1.head[0];
                var current_1 = new PivotSection(tupledArg[0], reverse$$1(tupledArg[1]));
                acc = new List$2(current_1, acc);
                tupledArg = [tfs.head, ofArray([e]), tfs.length];
                _arg1 = _arg1.tail;
                continue loop;
              }

          }
        }
      };
    };
  };

  var tfss_1 = choose$$1(function (node$$1) {
    var matchValue = pickPivotTransformations(node$$1);

    if (matchValue == null) {
      return null;
    } else {
      var tfs_2 = filter$1(function (_arg2) {
        return _arg2.Case === "Empty" ? false : true;
      }, matchValue);

      if (tfs_2.tail == null) {
        return null;
      } else {
        return [node$$1, tfs_2];
      }
    }
  }, tfss);

  if (tfss_1.tail == null) {
    return new List$2();
  } else {
    var tfs_3 = tfss_1.head[1];
    var e_2 = tfss_1.head[0];
    return loop(new List$2())([tfs_3.head, ofArray([e_2]), tfs_3.length])(tfss_1.tail);
  }
}
function collectChain(acc, node$$1) {
  collectChain: while (true) {
    var $var160 = node$$1.Node.Case === "Call" ? node$$1.Node.Fields[0] != null ? [0, node$$1.Node.Fields[0], node$$1.Node.Fields[1]] : [2] : node$$1.Node.Case === "Property" ? [0, node$$1.Node.Fields[0], node$$1.Node.Fields[1]] : node$$1.Node.Case === "Variable" ? [1, node$$1.Node.Fields[0]] : [2];

    switch ($var160[0]) {
      case 0:
        acc = new List$2([$var160[2].Range.Start, node$$1], acc);
        node$$1 = $var160[1];
        continue collectChain;

      case 1:
        return new List$2([$var160[1].Range.Start, node$$1], acc);

      case 2:
        return null;
    }
  }
}
function collectFirstChain(expr) {
  var matchValue = collectChain(new List$2(), expr);
  var $var161 = matchValue != null ? matchValue.tail != null ? [0, matchValue] : [1] : [1];

  var _ret = function () {
    switch ($var161[0]) {
      case 0:
        return {
          v: [function (x) {
            return x;
          }, $var161[1]]
        };

      case 1:
        var activePatternResult6960 = _ExprLeaf_ExprNode_(expr.Node);

        if (activePatternResult6960.Case === "Choice2Of2") {
          var _ret2 = function () {
            var loop = function loop(acc) {
              return function (es) {
                loop: while (true) {
                  if (es.tail != null) {
                    var matchValue_1 = collectFirstChain(es.head);

                    if (matchValue_1 != null) {
                      var _ret3 = function () {
                        var recreate = matchValue_1[0];
                        var chain = matchValue_1[1];

                        var recreate_1 = function recreate_1(newChain) {
                          var _Node$$1 = rebuildExprNode(es.head.Node, append$$1(reverse$$1(acc), append$$1(ofArray([recreate(newChain)]), es.tail)), activePatternResult6960.Fields[0][1]);

                          return new _Node(expr.WhiteBefore, expr.WhiteAfter, expr.Range, _Node$$1, expr.Entity);
                        };

                        return {
                          v: [recreate_1, chain]
                        };
                      }();

                      if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
                    } else {
                      acc = new List$2(es.head, acc);
                      es = es.tail;
                      continue loop;
                    }
                  } else {
                    return null;
                  }
                }
              };
            };

            return {
              v: {
                v: loop(new List$2())(activePatternResult6960.Fields[0][0])
              }
            };
          }();

          if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        } else {
          return {
            v: null
          };
        }

    }
  }();

  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}
var PivotEditorMenus = function () {
  function PivotEditorMenus(caseName, fields) {
    _classCallCheck(this, PivotEditorMenus);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(PivotEditorMenus, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotEditorMenus",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          AddDropdownOpen: [],
          ContextualDropdownOpen: [],
          Hidden: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return PivotEditorMenus;
}();
setType("TheGamma.Live.Pivot.PivotEditorMenus", PivotEditorMenus);
var PivotEditorAction = function () {
  function PivotEditorAction(caseName, fields) {
    _classCallCheck(this, PivotEditorAction);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(PivotEditorAction, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotEditorAction",
        interfaces: ["FSharpUnion"],
        cases: {
          AddElement: [Interface("TheGamma.Common.Symbol"), "string", Option(makeGeneric(List$2, {
            T: Expr
          }))],
          AddTransform: [Transformation],
          RemoveElement: [Interface("TheGamma.Common.Symbol")],
          RemoveSection: [Interface("TheGamma.Common.Symbol")],
          ReplaceElement: [Interface("TheGamma.Common.Symbol"), "string", Option(makeGeneric(List$2, {
            T: Expr
          }))],
          ReplaceRange: [_Range, "string"],
          SelectChainElement: ["number"],
          SelectRange: [_Range],
          SwitchMenu: [PivotEditorMenus],
          UpdatePreview: [DomNode]
        }
      };
    }
  }]);

  return PivotEditorAction;
}();
setType("TheGamma.Live.Pivot.PivotEditorAction", PivotEditorAction);
var PivotEditorState = function () {
  function PivotEditorState(body, firstNode, preview, sections, selectedEntity, menus, focus) {
    _classCallCheck(this, PivotEditorState);

    this.Body = body;
    this.FirstNode = firstNode;
    this.Preview = preview;
    this.Sections = sections;
    this.SelectedEntity = selectedEntity;
    this.Menus = menus;
    this.Focus = focus;
  }

  _createClass(PivotEditorState, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotEditorState",
        interfaces: ["FSharpRecord"],
        properties: {
          Body: makeGeneric(_Node, {
            T: Expr
          }),
          FirstNode: makeGeneric(_Node, {
            T: Expr
          }),
          Preview: DomNode,
          Sections: makeGeneric(List$2, {
            T: PivotSection
          }),
          SelectedEntity: Entity,
          Menus: PivotEditorMenus,
          Focus: Option(Tuple(["string", Option("number")]))
        }
      };
    }
  }]);

  return PivotEditorState;
}();
setType("TheGamma.Live.Pivot.PivotEditorState", PivotEditorState);
function withPivotState(pivotState, state) {
  return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, state.Selection, pivotState, state.CurrentPreview);
}
function findPreview(trigger, globals, ent) {
  var nm = new Name("preview");
  var matchValue = defaultArg(ent.Type, null, function (t) {
    return reduceType(t);
  });
  var $var162 = void 0;

  if (matchValue != null) {
    if (matchValue.Case === "Object") {
      var activePatternResult6994 = _FindMethod___$1(nm, matchValue.Fields[0]);

      if (activePatternResult6994 != null) {
        $var162 = [0];
      } else {
        var activePatternResult6995 = _FindProperty___$1(nm, matchValue.Fields[0]);

        if (activePatternResult6995 != null) {
          $var162 = [0];
        } else {
          $var162 = [1];
        }
      }
    } else {
      $var162 = [1];
    }
  } else {
    $var162 = [1];
  }

  var _ret4 = function () {
    switch ($var162[0]) {
      case 0:
        var res = evaluate(globals, ent);
        var res_1 = defaultArg(res, null, function (p) {
          return p.Preview.value;
        });

        if (res_1 != null) {
          var _ret5 = function () {
            Log.trace("live", "Found preview value: %O", res_1);

            var node$$1 = function (arg0) {
              return function (arg1) {
                return El.op_Dynamic(arg0, arg1);
              };
            }(h$$1)("div")(ofArray([op_EqualsGreater("class", "placeholder")]))(ofArray([text("Loading preview...")]));

            var returned = false;

            (function (arg00) {
              startImmediate(arg00);
            })(function (builder_) {
              return builder_.Delay(function () {
                return builder_.Bind(table.create(res_1).render(), function (_arg4) {
                  return builder_.Combine(returned ? function () {
                    trigger(new LiveEvent("CustomEvent", [new PivotEditorAction("UpdatePreview", [_arg4])]));
                    return builder_.Zero();
                  }() : function () {
                    node$$1 = _arg4;
                    return builder_.Zero();
                  }(), builder_.Delay(function () {
                    Log.trace("live", "Evaluated to a node");
                    return builder_.Zero();
                  }));
                });
              });
            }(singleton$2));

            returned = true;
            Log.trace("live", "After evaluation started: %O", node$$1);
            return {
              v: {
                v: node$$1
              }
            };
          }();

          if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
        } else {
          return {
            v: function (arg0_1) {
              return function (arg1_1) {
                return El.op_Dynamic(arg0_1, arg1_1);
              };
            }(h$$1)("div")(ofArray([op_EqualsGreater("class", "placeholder")]))(ofArray([text("Preview could not be evaluated")]))
          };
        }

      case 1:
        return {
          v: function (arg0_2) {
            return function (arg1_2) {
              return El.op_Dynamic(arg0_2, arg1_2);
            };
          }(h$$1)("div")(ofArray([op_EqualsGreater("class", "placeholder")]))(ofArray([text("This block does not have a preview")]))
        };
    }
  }();

  if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
}
function updateBody(trigger, state) {
  var matchValue = commandAtLocation(state.Location, state.Program);

  if (matchValue != null) {
    var patternInput = state.Mapper.AbsoluteToLineCol(matchValue.Range.End + 1);
    var $var163 = matchValue.Node.Case === "Let" ? [0, matchValue.Node.Fields[1]] : [0, matchValue.Node.Fields[0]];

    switch ($var163[0]) {
      case 0:
        var matchValue_1 = collectFirstChain($var163[1]);

        if (matchValue_1 != null) {
          var _ret6 = function () {
            var recreate = matchValue_1[0];
            var chain = matchValue_1[1];
            var sections = createPivotSections(map$4(function (tuple) {
              return tuple[1];
            }, chain));
            var patternInput_1 = chain.head;
            var matchValue_2 = tryLast(filter$1(function (tupledArg) {
              return state.Location >= tupledArg[0];
            }, chain));
            var $var164 = matchValue_2 != null ? function () {
              var selNode = matchValue_2[1];
              return !(sections.tail == null);
            }() ? [0, matchValue_2[1]] : [1] : [1];

            var _ret7 = function () {
              switch ($var164[0]) {
                case 0:
                  var preview = findPreview(trigger, state.Globals, $var164[1].Entity);
                  var ps = void 0;
                  var Menus = new PivotEditorMenus("Hidden", []);
                  var Focus = null;
                  var SelectedEntity = $var164[1].Entity;
                  ps = new PivotEditorState($var163[1], patternInput_1[1], preview, sections, SelectedEntity, Menus, Focus);
                  return {
                    v: {
                      v: function (state_1) {
                        return withPivotState(ps, state_1);
                      }(state)
                    }
                  };

                case 1:
                  return {
                    v: {
                      v: null
                    }
                  };
              }
            }();

            if ((typeof _ret7 === "undefined" ? "undefined" : _typeof(_ret7)) === "object") return _ret7.v;
          }();

          if ((typeof _ret6 === "undefined" ? "undefined" : _typeof(_ret6)) === "object") return _ret6.v;
        } else {
          return null;
        }

    }
  } else {
    return null;
  }
}
function hideMenus(state) {
  var State = void 0;
  var Menus = new PivotEditorMenus("Hidden", []);
  State = new PivotEditorState(state.State.Body, state.State.FirstNode, state.State.Preview, state.State.Sections, state.State.SelectedEntity, Menus, state.State.Focus);
  return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, state.Selection, State, state.CurrentPreview);
}
function editorLocation(mapper, startIndex, endIndex) {
  var patternInput = mapper.AbsoluteToLineCol(startIndex);
  var patternInput_1 = mapper.AbsoluteToLineCol(endIndex);
  var rng = {};
  return new LineColumnRange(patternInput[0], patternInput[1], patternInput_1[0], patternInput_1[1]);
}
function selectName(nd, state) {
  var rng = void 0;
  var $var165 = nd.Node.Case === "Call" ? [0, nd.Node.Fields[1]] : nd.Node.Case === "Property" ? [0, nd.Node.Fields[1]] : [1];

  switch ($var165[0]) {
    case 0:
      rng = $var165[1].Range;
      break;

    case 1:
      rng = nd.Range;
      break;
  }

  var loc = editorLocation(state.Mapper, rng.Start, rng.End + 1);
  var Selection = loc;
  return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, Selection, state.State, state.CurrentPreview);
}
function tryTransformChain(f, state) {
  var matchValue = collectFirstChain(state.State.Body);

  if (matchValue != null) {
    var recreate = matchValue[0];
    var chain = matchValue[1];
    var sections = createPivotSections(map$4(function (tuple) {
      return tuple[1];
    }, chain));
    return hideMenus(f(state.State.Body)(recreate)(map$4(function (tuple_1) {
      return tuple_1[1];
    }, chain))(sections));
  } else {
    return hideMenus(state);
  }
}
var marker = "InsertPropertyHere";
function replaceAndSelectMarker(newName, state) {
  var startIndex = state.Code.indexOf(marker);
  var newCode = replace$$1(state.Code, marker, escapeIdent(newName));
  var mapper = new LocationMapper(state.Code);
  var rng = editorLocation(mapper, startIndex, startIndex + escapeIdent(newName).length);
  var Selection = rng;
  return new LiveState(state.Globals, newCode, state.Program, state.Mapper, state.Location, Selection, state.State, state.CurrentPreview);
}
function reconstructChain(state, body, newNodes) {
  var newBody = fold$1(function (prev, part) {
    if (part.Node.Case === "Property") {
      var _Node$$1 = new Expr("Property", [prev, part.Node.Fields[1]]);

      return new _Node(part.WhiteBefore, part.WhiteAfter, part.Range, _Node$$1, part.Entity);
    } else if (part.Node.Case === "Call") {
      var _Node_1 = new Expr("Call", [prev, part.Node.Fields[1], part.Node.Fields[2]]);

      return new _Node(part.WhiteBefore, part.WhiteAfter, part.Range, _Node_1, part.Entity);
    } else {
      throw new Error("Unexpected node in call chain");
    }
  }, newNodes.head, newNodes.tail);
  var newCode = trim(formatSingleExpression(newBody), "both");
  var newCode_1 = state.Code.substr(0, body.Range.Start) + newCode + state.Code.substr(body.Range.End + 1);
  return new LiveState(state.Globals, newCode_1, state.Program, state.Mapper, state.Location, state.Selection, state.State, state.CurrentPreview);
}
function createChainNode(args, name) {
  var node$$1 = function node$$1(nd) {
    return node(new _Range(0, 0), nd);
  };

  if (args != null) {
    var args_1 = map$4(function (a) {
      return new Argument(null, node$$1(a));
    }, args);
    return node$$1(new Expr("Call", [null, node$$1(new Name(name)), node$$1(args_1)]));
  } else {
    return node$$1(new Expr("Property", [node$$1(new Expr("Empty", [])), node$$1(new Name(name))]));
  }
}
function getWhiteBeforeAndAfterSections(firstNode, sections) {
  var dominantWhite = function dominantWhite(whites) {
    var whites_1 = toList(toList(countBy(function (x) {
      return x;
    }, whites)));
    return reduce(function (f) {
      return function (x, y) {
        return f(x) > f(y) ? x : y;
      };
    }(function (tupledArg) {
      return tupledArg[0] === "" ? 0 : tupledArg[1];
    }), new List$2(["", 0], whites_1))[0];
  };

  var patternInput = [dominantWhite(function (list) {
    return map$4(function (nd) {
      return formatWhiteBeforeExpr(nd);
    }, list);
  }(map$4(function (sec) {
    return sec.Nodes.head;
  }, sections))), dominantWhite(function (list_1) {
    return map$4(function (nd_1) {
      return formatWhiteAfterExpr(nd_1);
    }, list_1);
  }(append$$1(ofArray([firstNode]), map$4(function (sec_1) {
    return last(sec_1.Nodes);
  }, sections))))];
  Log.trace("live", "Inserting whitespace before '%s' and after '%s' for sections: %O", patternInput[0], patternInput[1], sections);
  return [ofArray([new Token(new TokenKind("White", [patternInput[0]]), new _Range(0, 0))]), ofArray([new Token(new TokenKind("White", [patternInput[1]]), new _Range(0, 0))])];
}
function insertWhiteAroundSection(before, after, section) {
  var lastIdx = section.Nodes.length - 1;
  return new PivotSection(section.Transformation, mapIndexed$$1(function (i, node$$1) {
    var node_1 = void 0;
    var matchValue = [before, node$$1];
    var $var166 = matchValue[0] != null ? matchValue[1].Node.Case === "Property" ? function () {
      var n_1 = matchValue[1].Node.Fields[1];
      var inst_1 = matchValue[1].Node.Fields[0];
      var before_2 = matchValue[0];
      return i === 0;
    }() ? [0, matchValue[0], matchValue[1].Node.Fields[0], matchValue[1].Node.Fields[1]] : [1] : [1] : [1];

    switch ($var166[0]) {
      case 0:
        var _Node$$1 = new Expr("Property", [$var166[2], new _Node($var166[1], $var166[3].WhiteAfter, $var166[3].Range, $var166[3].Node, $var166[3].Entity)]);

        node_1 = new _Node(node$$1.WhiteBefore, node$$1.WhiteAfter, node$$1.Range, _Node$$1, node$$1.Entity);
        break;

      case 1:
        var $var167 = matchValue[0] != null ? matchValue[1].Node.Case === "Call" ? function () {
          var n = matchValue[1].Node.Fields[1];
          var inst = matchValue[1].Node.Fields[0];
          var before_1 = matchValue[0];
          var args = matchValue[1].Node.Fields[2];
          return i === 0;
        }() ? [0, matchValue[1].Node.Fields[2], matchValue[0], matchValue[1].Node.Fields[0], matchValue[1].Node.Fields[1]] : [1] : [1] : [1];

        switch ($var167[0]) {
          case 0:
            var _Node_1 = new Expr("Call", [$var167[3], new _Node($var167[2], $var167[4].WhiteAfter, $var167[4].Range, $var167[4].Node, $var167[4].Entity), $var167[1]]);

            node_1 = new _Node(node$$1.WhiteBefore, node$$1.WhiteAfter, node$$1.Range, _Node_1, node$$1.Entity);
            break;

          case 1:
            node_1 = node$$1;
            break;
        }

        break;
    }

    var node_2 = void 0;
    var matchValue_1 = [after, node_1];
    var $var168 = matchValue_1[0] != null ? function () {
      var after_1 = matchValue_1[0];
      return i === lastIdx;
    }() ? [0, matchValue_1[0], matchValue_1[1]] : [1] : [1];

    switch ($var168[0]) {
      case 0:
        node_2 = new _Node($var168[2].WhiteBefore, $var168[1], $var168[2].Range, $var168[2].Node, $var168[2].Entity);
        break;

      case 1:
        node_2 = node_1;
        break;
    }

    return node_2;
  }, section.Nodes));
}
function updatePivotState(trigger, state, event) {
  var $var169 = event.Case === "UpdateLocation" ? [0] : event.Case === "InitializeGlobals" ? [1] : event.Case === "CustomEvent" ? [2] : [0];

  switch ($var169[0]) {
    case 0:
      return function (state_1) {
        return updateBody(trigger, state_1);
      }(hideMenus(state));

    case 1:
      return state;

    case 2:
      if (event.Fields[0].Case === "SwitchMenu") {
        return withPivotState(new PivotEditorState(state.State.Body, state.State.FirstNode, state.State.Preview, state.State.Sections, state.State.SelectedEntity, event.Fields[0].Fields[0], state.State.Focus), state);
      } else if (event.Fields[0].Case === "SelectChainElement") {
        return tryTransformChain(function (body) {
          return function (recreate) {
            return function (chain) {
              return function (sections) {
                var loop = function loop(before) {
                  return function (chain_1) {
                    loop: while (true) {
                      var $var170 = chain_1.tail != null ? chain_1.head.Range.End + 1 < state.Location ? [0, chain_1.head, chain_1.tail] : [1] : [1];

                      switch ($var170[0]) {
                        case 0:
                          before = $var170[1];
                          chain_1 = $var170[2];
                          continue loop;

                        case 1:
                          if (chain_1.tail == null) {
                            return [before, before, before];
                          } else if (chain_1.tail.tail == null) {
                            return [before, chain_1.head, chain_1.head];
                          } else {
                            return [before, chain_1.head, chain_1.tail.head];
                          }

                      }
                    }
                  };
                };

                var patternInput = loop(chain.head)(chain.tail);
                return selectName(event.Fields[0].Fields[0] < 0 ? patternInput[0] : event.Fields[0].Fields[0] > 0 ? patternInput[2] : patternInput[1], state);
              };
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "SelectRange") {
        return function () {
          var Selection = editorLocation(state.Mapper, event.Fields[0].Fields[0].Start, event.Fields[0].Fields[0].End + 1);
          return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, Selection, state.State, state.CurrentPreview);
        }();
      } else if (event.Fields[0].Case === "ReplaceRange") {
        var _ret8 = function () {
          Log.trace("live", "Replace '%s' with '%s'", state.Code.substr(event.Fields[0].Fields[0].Start, event.Fields[0].Fields[0].End - event.Fields[0].Fields[0].Start + 1), event.Fields[0].Fields[1]);
          var newCode = state.Code.substr(0, event.Fields[0].Fields[0].Start) + event.Fields[0].Fields[1] + state.Code.substr(event.Fields[0].Fields[0].End + 1);
          var location = editorLocation(new LocationMapper(newCode), event.Fields[0].Fields[0].Start, event.Fields[0].Fields[0].Start + event.Fields[0].Fields[1].length);
          return {
            v: function () {
              var Selection_1 = location;
              return new LiveState(state.Globals, newCode, state.Program, state.Mapper, state.Location, Selection_1, state.State, state.CurrentPreview);
            }()
          };
        }();

        if ((typeof _ret8 === "undefined" ? "undefined" : _typeof(_ret8)) === "object") return _ret8.v;
      } else if (event.Fields[0].Case === "AddElement") {
        return tryTransformChain(function (body_1) {
          return function (recreate_1) {
            return function (chain_2) {
              return function (sections_1) {
                var newNodes = collect$$1(function (nd) {
                  return !equals(nd.Entity.Symbol, event.Fields[0].Fields[0]) ? ofArray([nd]) : ofArray([nd, createChainNode(event.Fields[0].Fields[2], marker)]);
                }, chain_2);
                return function (state_2) {
                  return replaceAndSelectMarker(event.Fields[0].Fields[1], state_2);
                }(reconstructChain(state, body_1, newNodes));
              };
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "ReplaceElement") {
        return tryTransformChain(function (body_2) {
          return function (recreate_2) {
            return function (chain_3) {
              return function (sections_2) {
                var newNodes_1 = map$4(function (nd_1) {
                  return !equals(nd_1.Entity.Symbol, event.Fields[0].Fields[0]) ? nd_1 : createChainNode(event.Fields[0].Fields[2], marker);
                }, chain_3);
                return function (state_3) {
                  return replaceAndSelectMarker(event.Fields[0].Fields[1], state_3);
                }(reconstructChain(state, body_2, newNodes_1));
              };
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "RemoveElement") {
        return tryTransformChain(function (body_3) {
          return function (recreate_3) {
            return function (chain_4) {
              return function (sections_3) {
                var beforeDropped = tryLast(toList(takeWhile(function (nd_2) {
                  return !equals(nd_2.Entity.Symbol, event.Fields[0].Fields[0]);
                }, chain_4)));
                var beforeDropped_1 = beforeDropped != null ? beforeDropped : chain_4.head;
                var newNodes_2 = filter$1(function (nd_3) {
                  return !equals(nd_3.Entity.Symbol, event.Fields[0].Fields[0]);
                }, chain_4);
                return function (state_4) {
                  return selectName(beforeDropped_1, state_4);
                }(reconstructChain(state, body_3, newNodes_2));
              };
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "RemoveSection") {
        return tryTransformChain(function (body_4) {
          return function (recreate_4) {
            return function (chain_5) {
              return function (sections_4) {
                var beforeDropped_2 = tryLast(toList(takeWhile(function (nd_4) {
                  return !equals(nd_4.Entity.Symbol, event.Fields[0].Fields[0]);
                }, map$4(function (sec) {
                  return sec.Nodes.head;
                }, sections_4))));
                var beforeDropped_3 = beforeDropped_2 != null ? beforeDropped_2 : chain_5.head;
                var newSections = filter$1(function (sec_1) {
                  return !equals(sec_1.Nodes.head.Entity.Symbol, event.Fields[0].Fields[0]);
                }, sections_4);
                var newNodes_3 = new List$2(chain_5.head, collect$$1(function (sec_2) {
                  return sec_2.Nodes;
                }, newSections));
                return function (state_5) {
                  return selectName(beforeDropped_3, state_5);
                }(reconstructChain(state, body_4, newNodes_3));
              };
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "AddTransform") {
        return tryTransformChain(function (body_5) {
          return function (recreate_5) {
            return function (chain_6) {
              return function (sections_5) {
                var patternInput_1 = getWhiteBeforeAndAfterSections(chain_6.head, sections_5);

                var node$$1 = function node$$1(n) {
                  return node(new _Range(0, 0), n);
                };

                var fields = tryPick(function (expr) {
                  return pickPivotFields(expr);
                }, reverse$$1(collect$$1(function (s$$1) {
                  return s$$1.Nodes;
                }, sections_5)));
                var patternInput_2 = void 0;

                if (event.Fields[0].Fields[0].Case === "DropColumns") {
                  patternInput_2 = ["drop columns", ofArray([marker, "then"])];
                } else if (event.Fields[0].Fields[0].Case === "SortBy") {
                  patternInput_2 = ["sort data", ofArray([marker, "then"])];
                } else if (event.Fields[0].Fields[0].Case === "FilterBy") {
                  patternInput_2 = ["filter data", ofArray([marker, "then"])];
                } else if (event.Fields[0].Fields[0].Case === "Paging") {
                  patternInput_2 = ["paging", ofArray([marker, "then"])];
                } else if (event.Fields[0].Fields[0].Case === "GetSeries") {
                  patternInput_2 = ["get series", ofArray([marker])];
                } else if (event.Fields[0].Fields[0].Case === "GetTheData") {
                  patternInput_2 = ["get the data", ofArray([marker])];
                } else if (event.Fields[0].Fields[0].Case === "GroupBy") {
                  patternInput_2 = ["group data", function () {
                    var $var171 = fields != null ? fields.tail != null ? [0, fields.head] : [1] : [1];

                    switch ($var171[0]) {
                      case 0:
                        return ofArray([marker, "by " + $var171[1].Name, "then"]);

                      case 1:
                        return ofArray([marker, "by Property", "then"]);
                    }
                  }()];
                } else if (event.Fields[0].Fields[0].Case === "Empty") {
                  patternInput_2 = ["", new List$2()];
                } else {
                  throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\live/pivot.fs", 365, 16);
                }

                var newSection = insertWhiteAroundSection(patternInput_1[0], patternInput_1[1], new PivotSection(event.Fields[0].Fields[0], map$4(function () {
                  var args = null;
                  return function (name) {
                    return createChainNode(args, name);
                  };
                }(), patternInput_2[1])));

                var closeFirstSection = function closeFirstSection(_arg1) {
                  if (_arg1.tail == null) {
                    return new List$2();
                  } else {
                    var _ret9 = function () {
                      var section = void 0;
                      var matchValue = [_arg1.head.Transformation, last(_arg1.head.Nodes)];
                      var $var172 = matchValue[0].Case === "Paging" ? matchValue[1].Node.Case === "Call" ? function () {
                        var n_2 = matchValue[1].Node.Fields[1];
                        return n_2.Node.Name === "take";
                      }() ? [0, matchValue[1].Node.Fields[1]] : [1] : [1] : [1];

                      switch ($var172[0]) {
                        case 0:
                          section = _arg1.head;
                          break;

                        case 1:
                          var $var173 = matchValue[1].Node.Case === "Property" ? function () {
                            var n_1 = matchValue[1].Node.Fields[1];
                            return n_1.Node.Name === "then";
                          }() ? [0, matchValue[1].Node.Fields[1]] : [1] : [1];

                          switch ($var173[0]) {
                            case 0:
                              section = _arg1.head;
                              break;

                            case 1:
                              var Nodes = append$$1(_arg1.head.Nodes, ofArray([createChainNode(null, "then")]));
                              section = new PivotSection(_arg1.head.Transformation, Nodes);
                              break;
                          }

                          break;
                      }

                      return {
                        v: new List$2(insertWhiteAroundSection(null, patternInput_1[1], section), _arg1.tail)
                      };
                    }();

                    if ((typeof _ret9 === "undefined" ? "undefined" : _typeof(_ret9)) === "object") return _ret9.v;
                  }
                };

                var newSections_1 = void 0;
                var matchValue_1 = reverse$$1(sections_5);
                var $var174 = matchValue_1.tail != null ? matchValue_1.head.Transformation.Case === "GetSeries" ? [0, matchValue_1.head, matchValue_1.tail] : matchValue_1.head.Transformation.Case === "GetTheData" ? [0, matchValue_1.head, matchValue_1.tail] : [1, matchValue_1] : [1, matchValue_1];

                switch ($var174[0]) {
                  case 0:
                    newSections_1 = reverse$$1(ofArray([$var174[1], newSection], closeFirstSection($var174[2])));
                    break;

                  case 1:
                    newSections_1 = reverse$$1(new List$2(newSection, closeFirstSection($var174[1])));
                    break;
                }

                Log.trace("live", "Inserted section: %O", _Array$from(newSections_1));
                var newNodes_4 = new List$2(chain_6.head, collect$$1(function (sec_3) {
                  return sec_3.Nodes;
                }, newSections_1));
                return function (state_6) {
                  return replaceAndSelectMarker(patternInput_2[0], state_6);
                }(reconstructChain(state, body_5, newNodes_4));
              };
            };
          };
        }, state);
      } else {
        return withPivotState(new PivotEditorState(state.State.Body, state.State.FirstNode, event.Fields[0].Fields[0], state.State.Sections, state.State.SelectedEntity, state.State.Menus, state.State.Focus), state);
      }

  }
}
function renderNodeList(trigger, nodes) {
  return toList(delay(function () {
    return collect$1(function (nd) {
      var $var175 = nd.Node.Case === "Property" ? nd.Node.Fields[1].Node.Name !== "then" ? [0, nd.Node.Fields[1]] : [1] : [1];

      switch ($var175[0]) {
        case 0:
          return singleton$1(function (arg0) {
            return function (arg1) {
              return El.op_Dynamic(arg0, arg1);
            };
          }(h$$1)("span")(new List$2())(ofArray([function (arg0_1) {
            return function (arg1_1) {
              return El.op_Dynamic(arg0_1, arg1_1);
            };
          }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [$var175[1].Range])))]))(ofArray([text($var175[1].Node.Name)])), function (arg0_2) {
            return function (arg1_2) {
              return El.op_Dynamic(arg0_2, arg1_2);
            };
          }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("RemoveElement", [nd.Entity.Symbol])))]))(ofArray([function (arg0_3) {
            return function (arg1_3) {
              return El.op_Dynamic(arg0_3, arg1_3);
            };
          }(h$$1)("i")(ofArray([op_EqualsGreater("class", "gfa gfa-times")]))(new List$2())]))])));

        case 1:
          return empty();
      }
    }, nodes);
  }));
}
function renderContextMenu(trigger) {
  return function (arg0) {
    return function (arg1) {
      return El.op_Dynamic(arg0, arg1);
    };
  }(h$$1)("a")(ofArray([op_EqualsGreater("class", "right"), op_EqualsBangGreater("click", trigger(new PivotEditorAction("SwitchMenu", [new PivotEditorMenus("ContextualDropdownOpen", [])])))]))(ofArray([function (arg0_1) {
    return function (arg1_1) {
      return El.op_Dynamic(arg0_1, arg1_1);
    };
  }(h$$1)("i")(ofArray([op_EqualsGreater("class", "gfa gfa-plus")]))(new List$2())]));
}
function renderAddPropertyMenu(trigger, f, nodes) {
  return toList(delay(function () {
    var lastNode = find(function (_arg1) {
      if (_arg1.Node.Case === "Property") {
        var n = _arg1.Node.Fields[1];
        return n.Node.Name !== "then";
      } else {
        return true;
      }
    }, reverse$$1(nodes));
    var matchValue = lastNode.Entity.Type;
    var $var176 = matchValue != null ? matchValue.Case === "Object" ? [0, matchValue.Fields[0]] : [1] : [1];

    var _ret10 = function () {
      switch ($var176[0]) {
        case 0:
          var members = sortWith(function (x, y) {
            return compare(x, y);
          }, choose$1(function (_arg2) {
            var $var177 = _arg2.Case === "Property" ? f(_arg2.Fields[0]) ? [0, _arg2.Fields[0]] : [1] : [1];

            switch ($var177[0]) {
              case 0:
                return $var177[1];

              case 1:
                return null;
            }
          }, $var176[1].Members));
          return {
            v: singleton$1(function (arg0) {
              return function (arg1) {
                return El.op_Dynamic(arg0, arg1);
              };
            }(h$$1)("ul")(new List$2())(toList(delay(function () {
              return map$5(function (n_1) {
                return function (arg0_1) {
                  return function (arg1_1) {
                    return El.op_Dynamic(arg0_1, arg1_1);
                  };
                }(h$$1)("li")(new List$2())(ofArray([function (arg0_2) {
                  return function (arg1_2) {
                    return El.op_Dynamic(arg0_2, arg1_2);
                  };
                }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("AddElement", [lastNode.Entity.Symbol, n_1, null])))]))(ofArray([text(n_1)]))]));
              }, members);
            }))))
          };

        case 1:
          return {
            v: empty()
          };
      }
    }();

    if ((typeof _ret10 === "undefined" ? "undefined" : _typeof(_ret10)) === "object") return _ret10.v;
  }));
}
function renderSection(triggerEvent, section) {
  var trigger = function trigger(action) {
    return function (_arg1) {
      return function (e) {
        e.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [action]));
      };
    };
  };

  var triggerWith = function triggerWith(f) {
    return function (el) {
      return function (e_1) {
        e_1.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [f(el)]));
      };
    };
  };

  var getNodeNameAndSymbol = function getNodeNameAndSymbol(_arg1_1) {
    var $var178 = _arg1_1 != null ? _arg1_1.Node.Case === "Property" ? _arg1_1.Entity != null ? [0, _arg1_1.Entity, _arg1_1.Node.Fields[1]] : [1] : [1] : [1];

    switch ($var178[0]) {
      case 0:
        return [$var178[2].Node.Name, $var178[1].Symbol];

      case 1:
        return ["", null];
    }
  };

  return toList(delay(function () {
    var $var179 = section != null ? section.Transformation.Case === "GetSeries" ? [0, section.Nodes] : section.Transformation.Case === "GroupBy" ? [1, section.Nodes] : section.Transformation.Case === "Paging" ? [2, section.Nodes] : section.Transformation.Case === "SortBy" ? [3, section.Nodes] : section.Transformation.Case === "DropColumns" ? [4, section.Nodes] : [5] : [5];

    var _ret11 = function () {
      switch ($var179[0]) {
        case 0:
          var patternInput = void 0;

          if ($var179[1].tail != null) {
            if ($var179[1].tail.tail != null) {
              if ($var179[1].tail.tail.tail != null) {
                patternInput = [$var179[1].head, $var179[1].tail.head, $var179[1].tail.tail.head];
              } else {
                patternInput = [$var179[1].head, $var179[1].tail.head, null];
              }
            } else {
              patternInput = [$var179[1].head, null, null];
            }
          } else {
            throw new Error("No get series node in get series transformation");
          }

          var patternInput_1 = getNodeNameAndSymbol(patternInput[1]);
          var patternInput_2 = getNodeNameAndSymbol(patternInput[2]);
          return {
            v: append$1(function () {
              var matchValue = patternInput[0].Entity.Type;
              var $var180 = matchValue != null ? matchValue.Case === "Object" ? [0, matchValue.Fields[0]] : [1] : [1];

              switch ($var180[0]) {
                case 0:
                  return append$1(singleton$1(function (arg0) {
                    return function (arg1) {
                      return El.op_Dynamic(arg0, arg1);
                    };
                  }(h$$1)("span")(new List$2())(ofArray([text("with key")]))), delay(function () {
                    return singleton$1(function (arg0_1) {
                      return function (arg1_1) {
                        return El.op_Dynamic(arg0_1, arg1_1);
                      };
                    }(h$$1)("select")(ofArray([op_EqualsBangGreater("change", triggerWith(function (el_1) {
                      return patternInput_1[1] != null ? new PivotEditorAction("ReplaceElement", [patternInput_1[1], el_1.value, null]) : new PivotEditorAction("AddElement", [patternInput[0].Entity.Symbol, el_1.value, null]);
                    }))]))(toList(delay(function () {
                      return append$1(patternInput_1[0] === "" ? singleton$1(function (arg0_2) {
                        return function (arg1_2) {
                          return El.op_Dynamic(arg0_2, arg1_2);
                        };
                      }(h$$1)("option")(ofArray([op_EqualsGreater("value", ""), op_EqualsGreater("selected", "selected")]))(ofArray([text("")]))) : empty(), delay(function () {
                        return collect$1(function (m) {
                          var $var181 = m.Case === "Property" ? m.Fields[0].indexOf("with key") === 0 ? [0, m.Fields[0]] : [1] : [1];

                          switch ($var181[0]) {
                            case 0:
                              return singleton$1(function (arg0_3) {
                                return function (arg1_3) {
                                  return El.op_Dynamic(arg0_3, arg1_3);
                                };
                              }(h$$1)("option")(toList(delay(function () {
                                return append$1(singleton$1(op_EqualsGreater("value", $var181[1])), delay(function () {
                                  return patternInput_1[0] === $var181[1] ? singleton$1(op_EqualsGreater("selected", "selected")) : empty();
                                }));
                              })))(ofArray([text(replace$$1($var181[1], "with key ", ""))])));

                            case 1:
                              return empty();
                          }
                        }, $var180[1].Members);
                      }));
                    }))));
                  }));

                case 1:
                  return empty();
              }
            }(), delay(function () {
              var $var182 = patternInput[1] != null ? patternInput[1].Entity != null ? patternInput[1].Entity.Type != null ? patternInput[1].Entity.Type.Case === "Object" ? [0, patternInput[1].Entity, patternInput[1].Entity.Type.Fields[0]] : [1] : [1] : [1] : [1];

              switch ($var182[0]) {
                case 0:
                  return append$1(singleton$1(function (arg0_4) {
                    return function (arg1_4) {
                      return El.op_Dynamic(arg0_4, arg1_4);
                    };
                  }(h$$1)("span")(new List$2())(ofArray([text("and value")]))), delay(function () {
                    return singleton$1(function (arg0_5) {
                      return function (arg1_5) {
                        return El.op_Dynamic(arg0_5, arg1_5);
                      };
                    }(h$$1)("select")(ofArray([op_EqualsBangGreater("change", triggerWith(function (el_2) {
                      return patternInput_2[1] != null ? new PivotEditorAction("ReplaceElement", [patternInput_2[1], el_2.value, null]) : new PivotEditorAction("AddElement", [$var182[1].Symbol, el_2.value, null]);
                    }))]))(toList(delay(function () {
                      return append$1(patternInput_2[0] === "" ? singleton$1(function (arg0_6) {
                        return function (arg1_6) {
                          return El.op_Dynamic(arg0_6, arg1_6);
                        };
                      }(h$$1)("option")(ofArray([op_EqualsGreater("value", ""), op_EqualsGreater("selected", "selected")]))(ofArray([text("")]))) : empty(), delay(function () {
                        return collect$1(function (m_1) {
                          var $var183 = m_1.Case === "Property" ? m_1.Fields[0].indexOf("and value") === 0 ? [0, m_1.Fields[0]] : [1] : [1];

                          switch ($var183[0]) {
                            case 0:
                              return singleton$1(function (arg0_7) {
                                return function (arg1_7) {
                                  return El.op_Dynamic(arg0_7, arg1_7);
                                };
                              }(h$$1)("option")(toList(delay(function () {
                                return append$1(singleton$1(op_EqualsGreater("value", $var183[1])), delay(function () {
                                  return patternInput_2[0] === $var183[1] ? singleton$1(op_EqualsGreater("selected", "selected")) : empty();
                                }));
                              })))(ofArray([text(replace$$1($var183[1], "and value ", ""))])));

                            case 1:
                              return empty();
                          }
                        }, $var182[2].Members);
                      }));
                    }))));
                  }));

                case 1:
                  return empty();
              }
            }))
          };

        case 1:
          var patternInput_3 = void 0;

          if ($var179[1].tail != null) {
            if ($var179[1].tail.tail != null) {
              patternInput_3 = [$var179[1].head, $var179[1].tail.head, $var179[1].tail.tail];
            } else {
              patternInput_3 = [$var179[1].head, null, new List$2()];
            }
          } else {
            throw new Error("No group by node in group by transformation");
          }

          var patternInput_4 = getNodeNameAndSymbol(patternInput_3[1]);
          return {
            v: append$1(function () {
              var matchValue_1 = patternInput_3[0].Entity.Type;
              var $var184 = matchValue_1 != null ? matchValue_1.Case === "Object" ? [0, matchValue_1.Fields[0]] : [1] : [1];

              switch ($var184[0]) {
                case 0:
                  return singleton$1(function (arg0_8) {
                    return function (arg1_8) {
                      return El.op_Dynamic(arg0_8, arg1_8);
                    };
                  }(h$$1)("select")(ofArray([op_EqualsBangGreater("change", triggerWith(function (el_3) {
                    return patternInput_4[1] != null ? new PivotEditorAction("ReplaceElement", [patternInput_4[1], el_3.value, null]) : new PivotEditorAction("AddElement", [patternInput_3[0].Entity.Symbol, el_3.value, null]);
                  }))]))(toList(delay(function () {
                    return append$1(patternInput_4[0] === "" ? singleton$1(function (arg0_9) {
                      return function (arg1_9) {
                        return El.op_Dynamic(arg0_9, arg1_9);
                      };
                    }(h$$1)("option")(ofArray([op_EqualsGreater("value", ""), op_EqualsGreater("selected", "selected")]))(ofArray([text("")]))) : empty(), delay(function () {
                      return collect$1(function (m_2) {
                        var $var185 = m_2.Case === "Property" ? m_2.Fields[0].indexOf("by") === 0 ? [0, m_2.Fields[0]] : [1] : [1];

                        switch ($var185[0]) {
                          case 0:
                            return singleton$1(function (arg0_10) {
                              return function (arg1_10) {
                                return El.op_Dynamic(arg0_10, arg1_10);
                              };
                            }(h$$1)("option")(toList(delay(function () {
                              return append$1(singleton$1(op_EqualsGreater("value", $var185[1])), delay(function () {
                                return patternInput_4[0] === $var185[1] ? singleton$1(op_EqualsGreater("selected", "selected")) : empty();
                              }));
                            })))(ofArray([text($var185[1])])));

                          case 1:
                            return empty();
                        }
                      }, $var184[1].Members);
                    }));
                  }))));

                case 1:
                  return empty();
              }
            }(), delay(function () {
              return append$1(renderNodeList(trigger, patternInput_3[2]), delay(function () {
                return singleton$1(renderContextMenu(trigger));
              }));
            }))
          };

        case 2:
          var methods = create$2(map$4(function (_arg35) {
            if (_arg35.Node.Case === "Call") {
              var n = _arg35.Node.Fields[1];
              return n.Node.Name;
            } else {
              return "";
            }
          }, $var179[1]), new GenericComparer(compare));
          return {
            v: append$1(collect$1(function (nd) {
              var $var186 = nd.Node.Case === "Call" ? nd.Node.Fields[2].Node.tail != null ? nd.Node.Fields[2].Node.tail.tail == null ? [0, nd.Node.Fields[2].Node.head, nd.Node.Fields[1]] : [1] : [1] : [1];

              switch ($var186[0]) {
                case 0:
                  var removeOp = $var186[2].Node.Name === "take" ? new PivotEditorAction("ReplaceElement", [nd.Entity.Symbol, "then", null]) : new PivotEditorAction("RemoveElement", [nd.Entity.Symbol]);
                  return singleton$1(function (arg0_11) {
                    return function (arg1_11) {
                      return El.op_Dynamic(arg0_11, arg1_11);
                    };
                  }(h$$1)("span")(new List$2())(ofArray([function (arg0_12) {
                    return function (arg1_12) {
                      return El.op_Dynamic(arg0_12, arg1_12);
                    };
                  }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [$var186[2].Range])))]))(ofArray([text($var186[2].Node.Name)])), function (arg0_13) {
                    return function (arg1_13) {
                      return El.op_Dynamic(arg0_13, arg1_13);
                    };
                  }(h$$1)("input")(ofArray([op_EqualsGreater("id", "input-pg-" + $var186[2].Node.Name), op_EqualsBangGreater("input", function (el_4) {
                    return function (_arg2) {
                      var input = el_4;
                      var patternInput_5 = parseProgram(input.value);

                      if (patternInput_5[1].length === 0 ? patternInput_5[0].Body.Node.length === 1 : false) {
                        el_4.setCustomValidity("");
                        triggerEvent(new LiveEvent("CustomEvent", [new PivotEditorAction("ReplaceRange", [$var186[1].Value.Range, input.value])]));
                      } else {
                        el_4.setCustomValidity("Cannot parse expression");
                      }
                    };
                  }), op_EqualsGreater("value", formatSingleExpression($var186[1].Value))]))(new List$2()), function (arg0_14) {
                    return function (arg1_14) {
                      return El.op_Dynamic(arg0_14, arg1_14);
                    };
                  }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(removeOp))]))(ofArray([function (arg0_15) {
                    return function (arg1_15) {
                      return El.op_Dynamic(arg0_15, arg1_15);
                    };
                  }(h$$1)("i")(ofArray([op_EqualsGreater("class", "gfa gfa-times")]))(new List$2())]))])));

                case 1:
                  return empty();
              }
            }, $var179[1]), delay(function () {
              return !(methods.has("take") ? methods.has("skip") : false) ? singleton$1(renderContextMenu(trigger)) : empty();
            }))
          };

        case 3:
          var props = choose$$1(function (_arg51) {
            var $var187 = _arg51.Node.Case === "Property" ? _arg51.Entity != null ? function () {
              var sym = _arg51.Entity.Symbol;
              var n_1 = _arg51.Node.Fields[1];

              if (n_1.Node.Name !== "then") {
                return n_1.Node.Name !== "sort data";
              } else {
                return false;
              }
            }() ? [0, _arg51.Node.Fields[1], _arg51.Entity.Symbol] : [1] : [1] : [1];

            switch ($var187[0]) {
              case 0:
                return [$var187[2], $var187[1]];

              case 1:
                return null;
            }
          }, $var179[1]);
          var last$$1 = tryLast(props);
          return {
            v: append$1(collect$1(function (matchValue_2) {
              return singleton$1(function (arg0_16) {
                return function (arg1_16) {
                  return El.op_Dynamic(arg0_16, arg1_16);
                };
              }(h$$1)("span")(new List$2())(toList(delay(function () {
                return append$1(singleton$1(function (arg0_17) {
                  return function (arg1_17) {
                    return El.op_Dynamic(arg0_17, arg1_17);
                  };
                }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [matchValue_2[1].Range])))]))(ofArray([text(matchValue_2[1].Node.Name)]))), delay(function () {
                  return matchValue_2[1].Node.Name === last$$1[1].Node.Name ? singleton$1(function (arg0_18) {
                    return function (arg1_18) {
                      return El.op_Dynamic(arg0_18, arg1_18);
                    };
                  }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("RemoveElement", [matchValue_2[0]])))]))(ofArray([function (arg0_19) {
                    return function (arg1_19) {
                      return El.op_Dynamic(arg0_19, arg1_19);
                    };
                  }(h$$1)("i")(ofArray([op_EqualsGreater("class", "gfa gfa-times")]))(new List$2())]))) : empty();
                }));
              }))));
            }, props), delay(function () {
              return singleton$1(renderContextMenu(trigger));
            }))
          };

        case 4:
          return {
            v: append$1(renderNodeList(trigger, $var179[1].tail), delay(function () {
              return singleton$1(renderContextMenu(trigger));
            }))
          };

        case 5:
          return {
            v: empty()
          };
      }
    }();

    if ((typeof _ret11 === "undefined" ? "undefined" : _typeof(_ret11)) === "object") return _ret11.v;
  }));
}
function renderPivot(triggerEvent, state) {
  var trigger = function trigger(action) {
    return function (_arg1) {
      return function (e) {
        e.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [action]));
      };
    };
  };

  var triggerWith = function triggerWith(f) {
    return function (el) {
      return function (e_1) {
        e_1.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [f(el)]));
      };
    };
  };

  var selSec = tryFind(function (sec) {
    return exists$1(function (secEnt) {
      return equals(state.State.SelectedEntity.Symbol, secEnt.Entity.Symbol);
    }, sec.Nodes);
  }, state.State.Sections);
  var firstNode = state.State.FirstNode;

  var dom = function (arg0) {
    return function (arg1) {
      return El.op_Dynamic(arg0, arg1);
    };
  }(h$$1)("div")(toList(delay(function () {
    return append$1(singleton$1(op_EqualsGreater("class", "pivot-preview")), delay(function () {
      return !state.State.Menus.Equals(new PivotEditorMenus("Hidden", [])) ? singleton$1(op_EqualsBangGreater("click", trigger(new PivotEditorAction("SwitchMenu", [new PivotEditorMenus("Hidden", [])])))) : empty();
    }));
  })))(ofArray([function (arg0_1) {
    return function (arg1_1) {
      return El.op_Dynamic(arg0_1, arg1_1);
    };
  }(h$$1)("ul")(ofArray([op_EqualsGreater("class", "tabs")]))(toList(delay(function () {
    return append$1(singleton$1(function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("li")(ofArray([op_EqualsGreater("class", equals(state.State.SelectedEntity.Symbol, firstNode.Entity.Symbol) ? "selected" : "")]))(ofArray([function (arg0_3) {
      return function (arg1_3) {
        return El.op_Dynamic(arg0_3, arg1_3);
      };
    }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [firstNode.Range])))]))(toList(delay(function () {
      return firstNode.Node.Case === "Variable" ? singleton$1(text(firstNode.Node.Fields[0].Node.Name)) : singleton$1(text("data"));
    })))]))), delay(function () {
      return append$1(map$5(function (sec_1) {
        var selected = exists$1(function (secEnt_1) {
          return equals(state.State.SelectedEntity.Symbol, secEnt_1.Entity.Symbol);
        }, sec_1.Nodes);
        var secSymbol = sec_1.Nodes.head.Entity.Symbol;
        var identRange = void 0;
        var $var188 = sec_1.Nodes.tail != null ? sec_1.Nodes.head.Node.Case === "Variable" ? [0, sec_1.Nodes.head.Node.Fields[0]] : sec_1.Nodes.head.Node.Case === "Call" ? [0, sec_1.Nodes.head.Node.Fields[1]] : sec_1.Nodes.head.Node.Case === "Property" ? [0, sec_1.Nodes.head.Node.Fields[1]] : [1] : [1];

        switch ($var188[0]) {
          case 0:
            identRange = $var188[1].Range;
            break;

          case 1:
            throw new Error("Unexpected node in pivot call chain");
            break;
        }

        return function (arg0_4) {
          return function (arg1_4) {
            return El.op_Dynamic(arg0_4, arg1_4);
          };
        }(h$$1)("li")(ofArray([op_EqualsGreater("class", selected ? "selected" : "")]))(ofArray([function (arg0_5) {
          return function (arg1_5) {
            return El.op_Dynamic(arg0_5, arg1_5);
          };
        }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [identRange])))]))(ofArray([text(transformName(sec_1.Transformation))])), function (arg0_6) {
          return function (arg1_6) {
            return El.op_Dynamic(arg0_6, arg1_6);
          };
        }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("RemoveSection", [secSymbol])))]))(ofArray([function (arg0_7) {
          return function (arg1_7) {
            return El.op_Dynamic(arg0_7, arg1_7);
          };
        }(h$$1)("i")(ofArray([op_EqualsGreater("class", "gfa gfa-times")]))(new List$2())]))]));
      }, state.State.Sections), delay(function () {
        return singleton$1(function (arg0_8) {
          return function (arg1_8) {
            return El.op_Dynamic(arg0_8, arg1_8);
          };
        }(h$$1)("li")(ofArray([op_EqualsGreater("class", state.State.Menus.Equals(new PivotEditorMenus("AddDropdownOpen", [])) ? "add selected" : "add")]))(ofArray([function (arg0_9) {
          return function (arg1_9) {
            return El.op_Dynamic(arg0_9, arg1_9);
          };
        }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SwitchMenu", [new PivotEditorMenus("AddDropdownOpen", [])])))]))(ofArray([function (arg0_10) {
          return function (arg1_10) {
            return El.op_Dynamic(arg0_10, arg1_10);
          };
        }(h$$1)("i")(ofArray([op_EqualsGreater("class", "gfa gfa-plus")]))(new List$2())]))])));
      }));
    }));
  }))), function (arg0_11) {
    return function (arg1_11) {
      return El.op_Dynamic(arg0_11, arg1_11);
    };
  }(h$$1)("div")(ofArray([op_EqualsGreater("class", "add-menu")]))(toList(delay(function () {
    var clickHandler = function clickHandler(tfs) {
      return op_EqualsBangGreater("click", trigger(new PivotEditorAction("AddTransform", [tfs])));
    };

    if (state.State.Menus.Equals(new PivotEditorMenus("AddDropdownOpen", []))) {
      return singleton$1(function (arg0_12) {
        return function (arg1_12) {
          return El.op_Dynamic(arg0_12, arg1_12);
        };
      }(h$$1)("ul")(new List$2())(toList(delay(function () {
        return append$1(singleton$1(function (arg0_13) {
          return function (arg1_13) {
            return El.op_Dynamic(arg0_13, arg1_13);
          };
        }(h$$1)("li")(new List$2())(ofArray([function (arg0_14) {
          return function (arg1_14) {
            return El.op_Dynamic(arg0_14, arg1_14);
          };
        }(h$$1)("a")(ofArray([clickHandler(new Transformation("DropColumns", [new List$2()]))]))(ofArray([text("drop columns")]))]))), delay(function () {
          return append$1(singleton$1(function (arg0_15) {
            return function (arg1_15) {
              return El.op_Dynamic(arg0_15, arg1_15);
            };
          }(h$$1)("li")(new List$2())(ofArray([function (arg0_16) {
            return function (arg1_16) {
              return El.op_Dynamic(arg0_16, arg1_16);
            };
          }(h$$1)("a")(ofArray([clickHandler(new Transformation("FilterBy", [new List$2()]))]))(ofArray([text("filter by")]))]))), delay(function () {
            return append$1(singleton$1(function (arg0_17) {
              return function (arg1_17) {
                return El.op_Dynamic(arg0_17, arg1_17);
              };
            }(h$$1)("li")(new List$2())(ofArray([function (arg0_18) {
              return function (arg1_18) {
                return El.op_Dynamic(arg0_18, arg1_18);
              };
            }(h$$1)("a")(ofArray([clickHandler(new Transformation("GroupBy", [new List$2(), new List$2()]))]))(ofArray([text("group by")]))]))), delay(function () {
              return append$1(singleton$1(function (arg0_19) {
                return function (arg1_19) {
                  return El.op_Dynamic(arg0_19, arg1_19);
                };
              }(h$$1)("li")(new List$2())(ofArray([function (arg0_20) {
                return function (arg1_20) {
                  return El.op_Dynamic(arg0_20, arg1_20);
                };
              }(h$$1)("a")(ofArray([clickHandler(new Transformation("Paging", [new List$2()]))]))(ofArray([text("paging")]))]))), delay(function () {
                return append$1(singleton$1(function (arg0_21) {
                  return function (arg1_21) {
                    return El.op_Dynamic(arg0_21, arg1_21);
                  };
                }(h$$1)("li")(new List$2())(ofArray([function (arg0_22) {
                  return function (arg1_22) {
                    return El.op_Dynamic(arg0_22, arg1_22);
                  };
                }(h$$1)("a")(ofArray([clickHandler(new Transformation("SortBy", [new List$2()]))]))(ofArray([text("sort by")]))]))), delay(function () {
                  var getDataCalled = exists$1(function (_arg70) {
                    var $var189 = _arg70.Transformation.Case === "GetTheData" ? [0] : _arg70.Transformation.Case === "GetSeries" ? [0] : [1];

                    switch ($var189[0]) {
                      case 0:
                        return true;

                      case 1:
                        return false;
                    }
                  }, state.State.Sections);

                  if (!getDataCalled) {
                    return append$1(singleton$1(function (arg0_23) {
                      return function (arg1_23) {
                        return El.op_Dynamic(arg0_23, arg1_23);
                      };
                    }(h$$1)("li")(new List$2())(ofArray([function (arg0_24) {
                      return function (arg1_24) {
                        return El.op_Dynamic(arg0_24, arg1_24);
                      };
                    }(h$$1)("a")(ofArray([clickHandler(new Transformation("GetTheData", []))]))(ofArray([text("get the data")]))]))), delay(function () {
                      return singleton$1(function (arg0_25) {
                        return function (arg1_25) {
                          return El.op_Dynamic(arg0_25, arg1_25);
                        };
                      }(h$$1)("li")(new List$2())(ofArray([function (arg0_26) {
                        return function (arg1_26) {
                          return El.op_Dynamic(arg0_26, arg1_26);
                        };
                      }(h$$1)("a")(ofArray([clickHandler(new Transformation("GetSeries", ["!", "!"]))]))(ofArray([text("get series")]))])));
                    }));
                  } else {
                    return empty();
                  }
                }));
              }));
            }));
          }));
        }));
      }))));
    } else {
      return empty();
    }
  }))), function (arg0_27) {
    return function (arg1_27) {
      return El.op_Dynamic(arg0_27, arg1_27);
    };
  }(h$$1)("div")(ofArray([op_EqualsGreater("class", "toolbar")]))(toList(delay(function () {
    return append$1(singleton$1(function (arg0_28) {
      return function (arg1_28) {
        return El.op_Dynamic(arg0_28, arg1_28);
      };
    }(h$$1)("span")(ofArray([op_EqualsGreater("class", "navig")]))(ofArray([function (arg0_29) {
      return function (arg1_29) {
        return El.op_Dynamic(arg0_29, arg1_29);
      };
    }(h$$1)("a")(new List$2())(ofArray([function (arg0_30) {
      return function (arg1_30) {
        return El.op_Dynamic(arg0_30, arg1_30);
      };
    }(h$$1)("i")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectChainElement", [-1]))), op_EqualsGreater("class", "gfa gfa-chevron-left")]))(new List$2())])), function (arg0_31) {
      return function (arg1_31) {
        return El.op_Dynamic(arg0_31, arg1_31);
      };
    }(h$$1)("a")(new List$2())(ofArray([function (arg0_32) {
      return function (arg1_32) {
        return El.op_Dynamic(arg0_32, arg1_32);
      };
    }(h$$1)("i")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectChainElement", [0]))), op_EqualsGreater("class", "gfa gfa-circle")]))(new List$2())])), function (arg0_33) {
      return function (arg1_33) {
        return El.op_Dynamic(arg0_33, arg1_33);
      };
    }(h$$1)("a")(new List$2())(ofArray([function (arg0_34) {
      return function (arg1_34) {
        return El.op_Dynamic(arg0_34, arg1_34);
      };
    }(h$$1)("i")(ofArray([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectChainElement", [1]))), op_EqualsGreater("class", "gfa gfa-chevron-right")]))(new List$2())]))]))), delay(function () {
      return renderSection(triggerEvent, selSec);
    }));
  }))), function (arg0_35) {
    return function (arg1_35) {
      return El.op_Dynamic(arg0_35, arg1_35);
    };
  }(h$$1)("div")(ofArray([op_EqualsGreater("class", "add-menu")]))(toList(delay(function () {
    var matchValue = [state.State.Menus, selSec];
    var $var190 = matchValue[0].Case === "ContextualDropdownOpen" ? matchValue[1] != null ? matchValue[1].Transformation.Case === "Paging" ? [0, matchValue[1].Nodes] : matchValue[1].Transformation.Case === "GroupBy" ? [1, matchValue[1].Nodes] : matchValue[1].Transformation.Case === "SortBy" ? [2, matchValue[1].Nodes] : matchValue[1].Transformation.Case === "DropColumns" ? [3, matchValue[1].Nodes] : [4] : [4] : [4];

    var _ret12 = function () {
      switch ($var190[0]) {
        case 0:
          var methods = new _Map(choose$$1(function (_arg110) {
            var $var191 = _arg110.Node.Case === "Property" ? [0, _arg110.Entity, _arg110.Node.Fields[1]] : _arg110.Node.Case === "Call" ? [0, _arg110.Entity, _arg110.Node.Fields[1]] : [1];

            switch ($var191[0]) {
              case 0:
                return [$var191[2].Node.Name, $var191[1].Symbol];

              case 1:
                return null;
            }
          }, $var190[1]));
          var lastSym = last($var190[1]).Entity.Symbol;
          var firstSym = $var190[1].head.Entity.Symbol;
          return {
            v: singleton$1(function (arg0_36) {
              return function (arg1_36) {
                return El.op_Dynamic(arg0_36, arg1_36);
              };
            }(h$$1)("ul")(new List$2())(toList(delay(function () {
              return append$1(!methods.has("take") ? function () {
                var op = methods.has("then") ? new PivotEditorAction("ReplaceElement", [methods.get("then"), "take", ofArray([new Expr("Number", [10])])]) : new PivotEditorAction("AddElement", [lastSym, "take", ofArray([new Expr("Number", [10])])]);
                return singleton$1(function (arg0_37) {
                  return function (arg1_37) {
                    return El.op_Dynamic(arg0_37, arg1_37);
                  };
                }(h$$1)("li")(new List$2())(ofArray([function (arg0_38) {
                  return function (arg1_38) {
                    return El.op_Dynamic(arg0_38, arg1_38);
                  };
                }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(op))]))(ofArray([text("take")]))])));
              }() : empty(), delay(function () {
                if (!methods.has("skip")) {
                  var op_1 = new PivotEditorAction("AddElement", [firstSym, "skip", ofArray([new Expr("Number", [10])])]);
                  return singleton$1(function (arg0_39) {
                    return function (arg1_39) {
                      return El.op_Dynamic(arg0_39, arg1_39);
                    };
                  }(h$$1)("li")(new List$2())(ofArray([function (arg0_40) {
                    return function (arg1_40) {
                      return El.op_Dynamic(arg0_40, arg1_40);
                    };
                  }(h$$1)("a")(ofArray([op_EqualsBangGreater("click", trigger(op_1))]))(ofArray([text("skip")]))])));
                } else {
                  return empty();
                }
              }));
            }))))
          };

        case 1:
          return {
            v: renderAddPropertyMenu(trigger, function (n) {
              return (n !== "then" ? n !== "preview" : false) ? !(n.indexOf("and") === 0) : false;
            }, $var190[1])
          };

        case 2:
          return {
            v: renderAddPropertyMenu(trigger, function (n_1) {
              return n_1 !== "then" ? n_1 !== "preview" : false;
            }, $var190[1])
          };

        case 3:
          return {
            v: renderAddPropertyMenu(trigger, function (n_2) {
              return n_2 !== "then" ? n_2 !== "preview" : false;
            }, $var190[1])
          };

        case 4:
          return {
            v: empty()
          };
      }
    }();

    if ((typeof _ret12 === "undefined" ? "undefined" : _typeof(_ret12)) === "object") return _ret12.v;
  }))), function (arg0_41) {
    return function (arg1_41) {
      return El.op_Dynamic(arg0_41, arg1_41);
    };
  }(h$$1)("div")(ofArray([op_EqualsGreater("class", "preview-body")]))(toList(delay(function () {
    return singleton$1(state.State.Preview);
  })))]));

  var patternInput = state.Mapper.AbsoluteToLineCol(state.State.Body.Range.End);
  return new LiveEditorZone(patternInput[0], dom);
}
var preview = new LivePreview(function (trigger) {
  return function (state) {
    return function (event) {
      return updatePivotState(trigger, state, event);
    };
  };
}, function (triggerEvent) {
  return function (state_1) {
    return renderPivot(triggerEvent, state_1);
  };
}, function () {
  var Body = node(new _Range(0, 0), new Expr("Empty", []));
  var FirstNode = node(new _Range(0, 0), new Expr("Empty", []));
  var SelectedEntity = null;
  return new PivotEditorState(Body, FirstNode, text("not created"), new List$2(), SelectedEntity, new PivotEditorMenus("Hidden", []), null);
}());

function commandAtLocation$1(loc, program) {
  return tryFind(function (cmd) {
    return cmd.Range.Start <= loc ? cmd.Range.End + 1 >= loc : false;
  }, program.Body.Node);
}
var ShowableEditorState = function () {
  function ShowableEditorState(endLocation, preview, previewSymbol, previewID) {
    _classCallCheck(this, ShowableEditorState);

    this.EndLocation = endLocation;
    this.Preview = preview;
    this.PreviewSymbol = previewSymbol;
    this.PreviewID = previewID;
  }

  _createClass(ShowableEditorState, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Showable.ShowableEditorState",
        interfaces: ["FSharpRecord"],
        properties: {
          EndLocation: "number",
          Preview: DomNode,
          PreviewSymbol: Interface("TheGamma.Common.Symbol"),
          PreviewID: "number"
        }
      };
    }
  }]);

  return ShowableEditorState;
}();
setType("TheGamma.Live.Showable.ShowableEditorState", ShowableEditorState);
function updateBody$1(trigger, state) {
  Log.trace("live", "Showable - updating body");
  var matchValue = commandAtLocation$1(state.Location, state.Program);
  var $var192 = matchValue != null ? matchValue.Node.Case === "Expr" ? matchValue.Entity != null ? matchValue.Entity.Kind.Case === "RunCommand" ? [0, matchValue, matchValue.Node.Fields[0], matchValue.Entity.Kind.Fields[0]] : [1] : [1] : [1] : [1];

  switch ($var192[0]) {
    case 0:
      var matchValue_1 = reduceType($var192[3].Type);

      if (matchValue_1.Case === "Object") {
        var members = matchValue_1.Fields[0].Members;
        var hasShow = members.some(function (_arg1) {
          var $var193 = _arg1.Case === "Method" ? _arg1.Fields[0] === "show" ? _arg1.Fields[1].tail != null ? _arg1.Fields[1].head[2].Case === "Primitive" ? _arg1.Fields[1].head[2].Fields[0].Case === "String" ? _arg1.Fields[1].tail.tail == null ? [0] : [1] : [1] : [1] : [1] : [1] : [1];

          switch ($var193[0]) {
            case 0:
              return true;

            case 1:
              return false;
          }
        });

        if (hasShow) {
          var _ret = function () {
            var res = evaluate(state.Globals, $var192[3]);

            if (res != null) {
              var _ret2 = function () {
                var id = !equals($var192[3].Symbol, state.State.PreviewSymbol) ? state.State.PreviewID + 1 : state.State.PreviewID;

                var placeholder = function (arg0) {
                  return function (arg1) {
                    return El.op_Dynamic(arg0, arg1);
                  };
                }(h$$1)("div")(ofArray([op_EqualsGreater("class", "placeholder")]))(ofArray([text("Loading preview...")]));

                var dom = function (arg0_1) {
                  return function (arg1_1) {
                    return El.op_Dynamic(arg0_1, arg1_1);
                  };
                }(h$$1)("div")(new List$2())(ofArray([function (arg00) {
                  return function (arg10) {
                    return function (arg20) {
                      return h$$1.delayed(arg00, arg10, arg20);
                    };
                  };
                }(String(id))(placeholder)(function (id_1) {
                  Log.trace("live", "Show: %O", res.Value);
                  res.Value.show(id_1);
                })]));

                return {
                  v: {
                    v: function () {
                      var State = new ShowableEditorState($var192[1].Range.End, dom, $var192[3].Symbol, id);
                      return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, state.Selection, State, state.CurrentPreview);
                    }()
                  }
                };
              }();

              if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
            } else {
              return {
                v: null
              };
            }
          }();

          if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
        } else {
          return null;
        }
      } else {
        return null;
      }

    case 1:
      return null;
  }
}
function updateShowableState(trigger, state, event) {
  var $var194 = event.Case === "UpdateLocation" ? [0] : event.Case === "InitializeGlobals" ? [1] : event.Case === "CustomEvent" ? [1] : [0];

  switch ($var194[0]) {
    case 0:
      return function (state_1) {
        return updateBody$1(trigger, state_1);
      }(state);

    case 1:
      return state;
  }
}
function renderShowable(trigger, state) {
  var patternInput = state.Mapper.AbsoluteToLineCol(state.State.EndLocation);

  var dom = function (arg0) {
    return function (arg1) {
      return El.op_Dynamic(arg0, arg1);
    };
  }(h$$1)("div")(ofArray([op_EqualsGreater("class", "pivot-preview")]))(ofArray([function (arg0_1) {
    return function (arg1_1) {
      return El.op_Dynamic(arg0_1, arg1_1);
    };
  }(h$$1)("ul")(ofArray([op_EqualsGreater("class", "tabs")]))(ofArray([function (arg0_2) {
    return function (arg1_2) {
      return El.op_Dynamic(arg0_2, arg1_2);
    };
  }(h$$1)("li")(ofArray([op_EqualsGreater("class", "selected")]))(ofArray([function (arg0_3) {
    return function (arg1_3) {
      return El.op_Dynamic(arg0_3, arg1_3);
    };
  }(h$$1)("a")(new List$2())(ofArray([text("preview")]))]))])), function (arg0_4) {
    return function (arg1_4) {
      return El.op_Dynamic(arg0_4, arg1_4);
    };
  }(h$$1)("div")(ofArray([op_EqualsGreater("class", "preview-body")]))(toList(delay(function () {
    return singleton$1(state.State.Preview);
  })))]));

  return new LiveEditorZone(patternInput[0], dom);
}
var preview$1 = new LivePreview(function (trigger) {
  return function (state) {
    return function (event) {
      return updateShowableState(trigger, state, event);
    };
  };
}, function (trigger_1) {
  return function (state_1) {
    return renderShowable(trigger_1, state_1);
  };
}, function () {
  var PreviewID = 0;

  var PreviewSymbol = _Symbol2();

  return new ShowableEditorState(0, text("not created"), PreviewSymbol, PreviewID);
}());

var i$2 = 1;
eval('monaco$' + i$2 + ' = monaco');
monaco = monaco;
var noState = _defineProperty({
  clone: function () {
    return this;
  },
  equals: function (other) {
    return true;
  }
}, _Symbol.reflection, function () {
  return {
    interfaces: ["Fable.Import.monaco.languages.IState"]
  };
});
function getColorClass(_arg1) {
  var $var212 = _arg1.Case === "String" ? [0] : _arg1.Case === "QIdent" ? [1] : _arg1.Case === "Ident" ? [1] : _arg1.Case === "Dot" ? [2] : _arg1.Case === "By" ? [3] : _arg1.Case === "To" ? [3] : _arg1.Case === "Let" ? [3] : _arg1.Case === "Boolean" ? [3] : _arg1.Case === "Fun" ? [3] : _arg1.Case === "Arrow" ? [3] : _arg1.Case === "Number" ? [4] : [5];

  switch ($var212[0]) {
    case 0:
      return "string";

    case 1:
      return "ident";

    case 2:
      return "operator";

    case 3:
      return "keyword";

    case 4:
      return "number";

    case 5:
      return "";
  }
}
var tokensProvider = _defineProperty({
  tokenize: function (line, state) {
    var tokens = {};
    tokens.endState = noState;
    tokens.tokens = [];

    var patternInput = tokenize(line);

    for (var idx = 0; idx <= patternInput[0].length - 1; idx++) {
      var t = patternInput[0][idx];
      var tok = {};
      tok.startIndex = t.Range.Start;
      tok.scopes = getColorClass(t.Token);
      tokens.tokens.push(tok);
    }

    return tokens;
  },
  getInitialState: function () {
    return noState;
  }
}, _Symbol.reflection, function () {
  return {
    interfaces: ["Fable.Import.monaco.languages.TokensProvider"]
  };
});
function createCompletionProvider(getService) {
  return _defineProperty({
    get triggerCharacters() {
      return _Array$from(ofArray(["."]));
    },

    provideCompletionItems: function (model, position, token) {
      return function (arg00) {
        return startAsPromise(arg00);
      }(function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            var svc = getService(model.uri.toString());
            var input = model.getValue(1, false);
            Log.event("editor", "completions", "", {
              source: input,
              position: position
            });
            var conv = new LocationMapper(input);
            var loc = conv.LineColToAbsolute(~~position.lineNumber, ~~position.column);
            return builder_.Bind(svc.TypeCheck(input), function (_arg1) {
              var optMembers = tryPick(function (tupledArg) {
                var $var213 = tupledArg[1].Kind.Case === "NamedMember" ? tupledArg[1].Kind.Fields[1].Type != null ? function () {
                  var t = tupledArg[1].Kind.Fields[1].Type;

                  if (loc >= tupledArg[0].Start) {
                    return loc <= tupledArg[0].End + 1;
                  } else {
                    return false;
                  }
                }() ? [0, tupledArg[1].Kind.Fields[1].Type] : [1] : [1] : [1];

                switch ($var213[0]) {
                  case 0:
                    Log.trace("completions", "Antecedant at current location: %O", $var213[1]);
                    var matchValue = reduceType($var213[1]);

                    if (matchValue.Case === "Object") {
                      var mems = matchValue.Fields[0].Members;
                      return [tupledArg[0], mems];
                    } else {
                      return null;
                    }

                  case 1:
                    var $var214 = tupledArg[1].Kind.Case === "NamedMember" ? tupledArg[1].Kind.Fields[1].Type != null ? [0, tupledArg[1].Kind.Fields[0], tupledArg[1].Kind.Fields[1].Type] : [1] : [1];

                    switch ($var214[0]) {
                      case 0:
                        Log.trace("completions", "Ignoring '%s' at location %s-%s (current=%s)", $var214[1].Name, tupledArg[0].Start, tupledArg[0].End, loc);
                        return null;

                      case 1:
                        return null;
                    }

                }
              }, _arg1[1].Entities);

              var convertRange = function convertRange(rng) {
                var patternInput = conv.AbsoluteToLineCol(rng.Start);
                var patternInput_1 = conv.AbsoluteToLineCol(rng.End);
                var res = {};
                res.startColumn = patternInput[1];
                res.startLineNumber = patternInput[0];
                res.endColumn = patternInput_1[1] + 1;
                res.endLineNumber = patternInput_1[0];
                return res;
              };

              if (optMembers != null) {
                var _ret = function () {
                  var nameRange = optMembers[0];
                  var members = optMembers[1];
                  var nameRange_1 = convertRange(nameRange);
                  Log.trace("completions", "providing %s members at %O", members.length, nameRange_1);
                  var completion = toList(delay(function () {
                    return map$5(function (m) {
                      var ci = {};
                      var patternInput_2 = m.Case === "Property" ? [m.Fields[0], 9] : [m.Fields[0], 1];
                      ci.kind = patternInput_2[1];
                      ci.label = patternInput_2[0];
                      ci.insertText = escapeIdent(patternInput_2[0]);
                      ci.filterText = patternInput_2[0];

                      if (m.Case === "Method") {
                        var patternInput_3 = function () {
                          var folder = function folder(tupledArg_1) {
                            return function (s) {
                              if (tupledArg_1[1].length > 100) {
                                return [new List$2(tupledArg_1[1], tupledArg_1[0]), s];
                              } else {
                                return [tupledArg_1[0], tupledArg_1[1] === "" ? s : tupledArg_1[1] + "," + s];
                              }
                            };
                          };

                          var arg = [new List$2(), ""];
                          return function (source) {
                            return fold$1(function ($var215, $var216) {
                              return folder($var215)($var216);
                            }, [arg[0], arg[1]], source);
                          };
                        }()(toList(delay(function () {
                          return collect$1(function (matchValue_1) {
                            return singleton$1((matchValue_1[1] ? "?" : "") + matchValue_1[0]);
                          }, m.Fields[1]);
                        })));

                        var args = join(",\n", reverse$$1(new List$2(patternInput_3[1], patternInput_3[0])));
                        ci.documentation = "(" + args + ")";
                      }

                      var eo = {};
                      eo.text = escapeIdent(patternInput_2[0]);
                      eo.range = nameRange_1;
                      ci.textEdit = eo;
                      return ci;
                    }, members);
                  }));
                  Log.trace("completions", "returning %O", _Array$from(completion));
                  return {
                    v: builder_.Return(_Array$from(completion))
                  };
                }();

                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
              } else {
                Log.trace("completions", "no members at %s", loc);
                return builder_.Return(_Array$from(new List$2()));
              }
            });
          }), function (_arg2) {
            Log.exn("completions", "completions failed %O", _arg2);
            return builder_.Return([]);
          });
        });
      }(singleton$2));
    },
    resolveCompletionItem: function (item$$1, token) {
      return item$$1;
    }
  }, _Symbol.reflection, function () {
    return {
      interfaces: ["Fable.Import.monaco.languages.CompletionItemProvider"]
    };
  });
}
var createdEditors = new _Map();
function getService(uri) {
  return createdEditors.get(uri);
}
function setupMonacoServices() {
  var lang = {};
  lang.id = "thegamma";
  monaco$1.languages.register(lang);
  monaco$1.languages.setTokensProvider("thegamma", tokensProvider);
  monaco$1.languages.registerCompletionItemProvider("thegamma", createCompletionProvider(function (uri) {
    return getService(uri);
  }));
}
function createMonacoEditor(id, code, svc, customize) {
  if (createdEditors.size === 0) {
    setupMonacoServices();
  }

  var services = {};
  var options = {};
  var scroll = {};
  scroll.vertical = "none";
  scroll.horizontal = "auto";
  options.scrollbar = scroll;
  options.value = code;
  options.language = "thegamma";
  options.lineNumbersMinChars = 3;
  options.contextmenu = false;
  options.scrollBeyondLastLine = false;
  options.overviewRulerLanes = 0;
  customize(options);
  var ed = monaco$1.editor.create(document.getElementById(id), options, services);
  createdEditors.set(ed.getModel().uri.toString(), svc);
  return ed;
}

function buildGlobalsTable(provideTypes) {
  return function (arg00) {
    return function (arg10) {
      return Async_StartAsNamedFuture_Static(arg00, arg10);
    };
  }("buildGlobalsTable")(function (builder_) {
    return builder_.Delay(function () {
      var named = create$3(null, new GenericComparer(compare));

      var lookupNamed = function lookupNamed(n) {
        return function (tyargs) {
          var matchValue = tryFind$1(n, named);

          if (matchValue == null) {
            Log.error("Could not find named type '%s'", n);
            throw new Error(fsFormat("Could not find named type '%s'")(function (x) {
              return x;
            })(n));
          } else {
            var tya = matchValue[1];
            var r = matchValue[0];

            if (tya.length !== tyargs.length) {
              Log.error("Named type '%s' has mismatching length of type arguments", n);
              throw new Error(fsFormat("Named type '%s' has mismatching length of type arguments")(function (x) {
                return x;
              })(n));
            }

            if (tya.length > 0) {
              return new Type("App", [r, tyargs]);
            } else {
              return r;
            }
          }
        };
      };

      return builder_.Bind(provideTypes(lookupNamed), function (_arg1) {
        var allTypes = toList(delay(function () {
          return append$1(singleton$1(new ProvidedType("NamedType", ["value", ofArray(["a"]), new Type("Any", [])])), delay(function () {
            return append$1(singleton$1(new ProvidedType("NamedType", ["object", new List$2(), new Type("Any", [])])), delay(function () {
              return append$1(singleton$1(new ProvidedType("NamedType", ["seq", ofArray(["a"]), new Type("Any", [])])), delay(function () {
                return append$1(singleton$1(new ProvidedType("NamedType", ["async", ofArray(["a"]), new Type("Any", [])])), delay(function () {
                  return _arg1;
                }));
              }));
            }));
          }));
        }));
        named = create$3(choose$1(function (_arg2) {
          return _arg2.Case === "NamedType" ? [_arg2.Fields[0], [_arg2.Fields[2], _arg2.Fields[1]]] : null;
        }, allTypes), new GenericComparer(compare));
        var globalEntities = choose$$1(function (_arg3) {
          return _arg3.Case === "GlobalValue" ? globalEntity(_arg3.Fields[0], _arg3.Fields[1], _arg3.Fields[3], _arg3.Fields[2]) : null;
        }, allTypes);
        return builder_.Return(globalEntities);
      });
    });
  }(singleton$2));
}
var TheGammaProviders = function () {
  function TheGammaProviders(globals) {
    _classCallCheck(this, TheGammaProviders);

    this.globals = globals;
  }

  _createClass(TheGammaProviders, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Main.TheGammaProviders",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          globals: Interface("TheGamma.Common.Future")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return TheGammaProviders;
}();
setType("Main.TheGammaProviders", TheGammaProviders);
var TheGammaContext = function () {
  function TheGammaContext(checkingService, providers) {
    _classCallCheck(this, TheGammaContext);

    this.checkingService = checkingService;
    this.providers = providers;
  }

  _createClass(TheGammaContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Main.TheGammaContext",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          checkingService: CheckingService,
          providers: TheGammaProviders
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return TheGammaContext;
}();
setType("Main.TheGammaContext", TheGammaContext);
function callShowMethod(outputId, cmd) {
  var $var217 = cmd.Node.Case === "Expr" ? cmd.Node.Fields[0].Entity != null ? cmd.Node.Fields[0].Entity.Type != null ? [0, cmd.Node.Fields[0], cmd.Node.Fields[0].Entity.Type] : [1] : [1] : [1];

  switch ($var217[0]) {
    case 0:
      var matchValue = reduceType($var217[2]);

      if (matchValue.Case === "Object") {
        var members = matchValue.Fields[0].Members;
        var hasShow = members.some(function (_arg1) {
          var $var218 = _arg1.Case === "Method" ? _arg1.Fields[0] === "show" ? _arg1.Fields[1].tail != null ? _arg1.Fields[1].head[2].Case === "Primitive" ? _arg1.Fields[1].head[2].Fields[0].Case === "String" ? _arg1.Fields[1].tail.tail == null ? [0] : [1] : [1] : [1] : [1] : [1] : [1];

          switch ($var218[0]) {
            case 0:
              return true;

            case 1:
              return false;
          }
        });

        if (hasShow) {
          var rng = new _Range(cmd.Range.End, cmd.Range.End);
          var outExpr = node(rng, new Expr("String", [outputId]));
          var args = ofArray([new Argument(null, outExpr)]);
          var expr = node(rng, new Expr("Call", [$var217[1], node(rng, new Name("show")), node(rng, args)]));
          return node(cmd.Range, new Command("Expr", [expr]));
        } else {
          return cmd;
        }
      } else {
        return cmd;
      }

    case 1:
      return cmd;
  }
}

function _evaluate(ctx, code, outputId) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(ctx.checkingService.TypeCheck(code), function (_arg1) {
        var newBody = outputId != null ? map$4(function (cmd) {
          return callShowMethod(outputId, cmd);
        }, _arg1[2].Body.Node) : _arg1[2].Body.Node;
        var prog = new Program$$1(new _Node(_arg1[2].Body.WhiteBefore, _arg1[2].Body.WhiteAfter, _arg1[2].Body.Range, newBody, _arg1[2].Body.Entity));
        return builder_.Bind(compile(ctx.providers.globals, code, prog), function (_arg2) {
          var s = series.create(function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Return([]);
            });
          }(singleton$2), "", "", "");
          new RuntimeContext("lol", "", "troll");

          (function (c) {
            return function (s_1) {
              return trimLeft(c, s_1);
            };
          });

          (function (arg00) {
            return chart.bar(arg00);
          });

          table.create(s);
          timeline.create(s);
          series.values(new Int32Array([1]));
          placeholder.create("");

          (function (arg00_1) {
            return youdraw.create(arg00_1);
          });

          return builder_.Return(eval(_arg2));
        });
      });
    });
  }(singleton$2);
}

var previews = ofArray([preview, preview$1]);
var editorOptions = function () {
  function editorOptions(width, height, maxHeight, autoHeight, monacoOptions) {
    _classCallCheck(this, editorOptions);

    this.width = width;
    this.height = height;
    this.maxHeight = maxHeight;
    this.autoHeight = autoHeight;
    this.monacoOptions = monacoOptions;
  }

  _createClass(editorOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Main.editorOptions",
        interfaces: ["FSharpRecord"],
        properties: {
          width: Option("number"),
          height: Option("number"),
          maxHeight: Option("number"),
          autoHeight: Option("boolean"),
          monacoOptions: Option("function")
        }
      };
    }
  }]);

  return editorOptions;
}();
setType("Main.editorOptions", editorOptions);
var error = function () {
  function error(number, message, startLine, startColumn, endLine, endColumn) {
    _classCallCheck(this, error);

    this.number = number;
    this.message = message;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
  }

  _createClass(error, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Main.error",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          number: "number",
          message: "string",
          startLine: "number",
          startColumn: "number",
          endLine: "number",
          endColumn: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return error;
}();
setType("Main.error", error);
var defaultEditorOptions = new editorOptions(null, null, null, null, null);
var editor$1 = function () {
  _createClass(editor$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Main.editor",
        properties: {}
      };
    }
  }]);

  function editor$$1(ed) {
    _classCallCheck(this, editor$$1);

    this.ed = ed;
  }

  _createClass(editor$$1, [{
    key: "getValue",
    value: function () {
      return this.ed.getModel().getValue(1, false);
    }
  }, {
    key: "setValue",
    value: function (text) {
      this.ed.getModel().setValue(text);
    }
  }]);

  return editor$$1;
}();
setType("Main.editor", editor$1);
var gamma = function () {
  _createClass(gamma, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Main.gamma",
        properties: {}
      };
    }
  }]);

  function gamma(ctx) {
    _classCallCheck(this, gamma);

    this.ctx = ctx;
  }

  _createClass(gamma, [{
    key: "evaluate",
    value: function (code, outputId) {
      var _this = this;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            return builder_.Bind(_evaluate(_this.ctx, code, outputId), function () {
              return builder_.Return(null);
            });
          }), function (_arg2) {
            Log.exn("api", "Evaluating code '%O' failed with error '%O'.", code, _arg2);
            return builder_.Zero();
          });
        });
      }(singleton$2));
    }
  }, {
    key: "errorsReported",
    value: function (f) {
      add$5(function (tupledArg) {
        f(_Array$from(sortWith(function (x, y) {
          return compare(function (e_1) {
            return e_1.Range.Start;
          }(x), function (e_1) {
            return e_1.Range.Start;
          }(y));
        }, tupledArg[1])).map(function (e) {
          return new error(e.Number, e.Message, e.Range.Start.Line, e.Range.Start.Column, e.Range.End.Line, e.Range.End.Column);
        }));
      }, this.ctx.checkingService.ErrorsReported);
    }
  }, {
    key: "createEditor",
    value: function (id, source, options) {
      var lineHeight = 20;
      var options_1 = options != null ? options : defaultEditorOptions;
      var el = document.getElementById(id);
      var width = defaultArg(options_1.width, el.clientWidth);
      var height = defaultArg(options_1.height, el.clientHeight);
      var maxHeight = defaultArg(options_1.maxHeight, 2147483647);
      var ed = createMonacoEditor(id, source, this.ctx.checkingService, function (opts) {
        opts.fontSize = 15;
        opts.lineHeight = 20;
        defaultArg(options_1.monacoOptions, function (value) {
          value;
        })(opts);
        var matchValue = opts.lineHeight;

        if (matchValue != null) {
          lineHeight = matchValue;
        }
      });
      var dim = {};
      dim.width = width;
      dim.height = height;
      ed.layout(dim);
      var previewService = new PreviewService(this.ctx.checkingService, this.ctx.providers.globals, ed, previews);
      var lastHeight = -1;

      var autosizeEditor = function autosizeEditor() {
        var text = ed.getModel().getValue(1, false);
        var lines = 1 + split$$1(text, "\n").length;
        var height_1 = maxHeight < (200 > lines * 20 + previewService.ZoneHeight ? 200 : lines * 20 + previewService.ZoneHeight) ? maxHeight : 200 > lines * 20 + previewService.ZoneHeight ? 200 : lines * 20 + previewService.ZoneHeight;

        if (height_1 !== lastHeight) {
          lastHeight = height_1;
          var dim_1 = {};
          dim_1.width = width;
          dim_1.height = height_1;
          ed.layout(dim_1);
          el.style.height = String(dim_1.height) + "px";
          el.style.width = String(dim_1.width) + "px";
        }
      };

      if (equals(options_1.autoHeight, true)) {
        ed.getModel().onDidChangeContent(function (_arg1) {
          autosizeEditor(null);
        });
        add$5(function () {
          autosizeEditor(null);
        }, previewService.ZoneSizeChanged);
        autosizeEditor(null);
      }

      return new editor$1(ed);
    }
  }], [{
    key: "createContext",
    value: function (providers) {
      var checkingSvc = new CheckingService("", providers.globals);
      return new gamma(new TheGammaContext(checkingSvc, providers));
    }
  }]);

  return gamma;
}();
setType("Main.gamma", gamma);
var providers = function () {
  function providers() {
    _classCallCheck(this, providers);
  }

  _createClass(providers, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Main.providers",
        properties: {}
      };
    }
  }], [{
    key: "createProviders",
    value: function (providers_1) {
      var globals = buildGlobalsTable(function (lookup) {
        return function (builder_) {
          return builder_.Delay(function () {
            var providers_2 = function (o) {
              return _Object$keys(o).map(function (k) {
                return {
                  "key": k,
                  "value": o[k]
                };
              });
            }(providers_1).map(function (kv) {
              return kv.value(kv.key)(lookup);
            });

            return builder_.Bind(parallel(providers_2), function (_arg1) {
              return builder_.Return(concat$1(_arg1));
            });
          });
        }(singleton$2);
      });
      return new TheGammaProviders(globals);
    }
  }, {
    key: "rest",
    value: function (url, cookies) {
      return function (name) {
        return function (lookup) {
          return function (builder_) {
            return builder_.Delay(function () {
              return builder_.Return(ofArray([RestProvider.provideRestType(lookup, name, url, cookies != null ? cookies : "")]));
            });
          }(singleton$2);
        };
      };
    }
  }, {
    key: "library",
    value: function (url) {
      return function (_arg3) {
        return function (lookup) {
          return FSharpProvider.provideFSharpTypes(lookup, url);
        };
      };
    }
  }, {
    key: "pivot",
    value: function (url) {
      return function (name) {
        return function (lookup) {
          return function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Http.Request("GET", url + "?metadata"), function (_arg2) {
                var members = function (o) {
                  return _Object$keys(o).map(function (k) {
                    return {
                      "key": k,
                      "value": o[k]
                    };
                  });
                }(JSON.parse(_arg2)).map(function (kv) {
                  var typ = void 0;
                  var matchValue = kv.value;

                  switch (matchValue) {
                    case "string":
                      typ = new PrimitiveType("String", []);
                      break;

                    case "bool":
                      typ = new PrimitiveType("Bool", []);
                      break;

                    case "number":
                      typ = new PrimitiveType("Number", []);
                      break;

                    default:
                      throw new Error(fsFormat("The property '%s' has invalid type '%s'. Only 'string', 'number' and 'bool' are supported.")(function (x) {
                        return x;
                      })(kv.key)(matchValue));
                  }

                  return [kv.key, typ];
                });

                return builder_.Return(ofArray([providePivotType(url, name, lookup, members)]));
              });
            });
          }(singleton$2);
        };
      };
    }
  }]);

  return providers;
}();
setType("Main.providers", providers);

exports.evaluate = _evaluate;
exports.buildGlobalsTable = buildGlobalsTable;
exports.TheGammaProviders = TheGammaProviders;
exports.TheGammaContext = TheGammaContext;
exports.callShowMethod = callShowMethod;
exports.previews = previews;
exports.editorOptions = editorOptions;
exports.error = error;
exports.defaultEditorOptions = defaultEditorOptions;
exports.editor = editor$1;
exports.gamma = gamma;
exports.providers = providers;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=thegamma.js.map